using System;

using ObjCRuntime;
using Foundation;
using UIKit;
using CoreData;

namespace GoodDynamics
{
	/** \defgroup iccerrors Good Inter-Container Communication Errors
	* These constants can be used for handling or generating errors when
	* using the Good Inter-Container Communication (ICC) sytem.
	*
	* Errors can be generated by the ICC system itself, or by service provider
	* applications working within the system. See the individual error codes'
	* documentation for a description of when each code is to be used, and note the
	* following.
	*
	* The <EM>NotFound</EM> codes are for use when the service, service version, or
	* method in a request is not offered by the provider application to which the
	* request was sent.
	* 
	* The <EM>Disabled</EM> codes are for use when the service, service version,
	* and method are generally offered by the provider application, but support is
	* currently disabled by a policy setting or other condition that is, in
	* principle, temporary.
	* \{
	*/
	/// <summary>
	/// Good Inter-Container Communication Errors
	/// </summary>
	[Static]
	[BaseType (typeof(NSObject))]
	public interface ICCErrorConstants
	{
		/// <summary>
		/// </summary>
		[Static, Field ("MTGDServicesErrorDomain", "__Internal")]
		NSString GDServicesErrorDomain { get; }
		/*< The error domain for Good Inter-Container Communication errors.
		 * This domain is for service errors in the Good Dynamics
		 * Inter-Container Communication (ICC) system. Note that this domain is not used
		 * for errors that are specific to a service or service provider application.
		 * 
		 * For an overall description of ICC see the   \link GDService GDService class reference\endlink.
		 *
		 * An <TT>NSError</TT> with this value as its domain could be encountered as
		 * any of the following:
		 * - In the <TT>error</TT> parameter following a call to
		 *    \link GDServiceClient::sendTo:withService:withVersion:withMethod:withParams:withAttachments:bringServiceToFront:requestID:error: SendTo (GDServiceClient)\endlink where the request was not accepted by the ICC
		 *   system.
		 * - In the <TT>error</TT> parameter following a call to
		 *    \link GDService::replyTo:withParams:bringClientToFront:withAttachments:requestID:error: ReplyTo (GDService)\endlink where the response was not accepted by the ICC
		 *   system.
		 * - As the <TT>params</TT> object passed to an invocation of
		 *    \link GDServiceClientDelegate::GDServiceClientDidReceiveFrom:withParams:withAttachments:correspondingToRequestID: DidReceiveFrom\endlink where a request that had
		 *   been accepted subsequently failed in the system.
		 * .
		 * Of the above, <TT>sendTo:</TT> and
		 * <TT>GDServiceClientDidReceiveFrom:</TT> are part of the service consumer
		 * side of the ICC API, and <TT>replyTo:</TT> is part of the service provider
		 * side.
		 */

		/// <summary>
		/// </summary>
		[Static, Field ("MTGDServicesErrorGeneral", "__Internal")]
		int GDServicesErrorGeneral { get; }

		/**< A general Inter-Container Communication error occurred.*/

		/// <summary>
		/// </summary>
		[Static, Field ("MTGDServicesErrorApplicationNotFound", "__Internal")]
		int GDServicesErrorApplicationNotFound { get; }

		/**< The service consumer sent a request to an application that could not be
		 * found on the device.
		 */

		/// <summary>
		/// </summary>
		[Static, Field ("MTGDServicesErrorServiceNotFound", "__Internal")]
		int GDServicesErrorServiceNotFound { get; }

		/**< The service consumer sent a request that specified a service that is not
		 * supported by the service provider.
		 */

		/// <summary>
		/// </summary>
		[Static, Field ("MTGDServicesErrorServiceVersionNotFound", "__Internal")]
		int GDServicesErrorServiceVersionNotFound { get; }

		/**< The service consumer sent a request that specified a service version that
		 * is not supported by the service provider.
		 */

		/// <summary>
		/// </summary>
		[Static, Field ("MTGDServicesErrorMethodNotFound", "__Internal")]
		int GDServicesErrorMethodNotFound { get; }

		/**< The service consumer sent a request that specified a method that is not
		 * supported by the service provider.
		 */

		/// <summary>
		/// </summary>
		[Static, Field ("MTGDServicesErrorNotAllowed", "__Internal")]
		int GDServicesErrorNotAllowed { get; }

		/**< The service consumer sent a request to an application that could not be
		 * unlocked.
		 */

		/// <summary>
		/// </summary>
		[Static, Field ("MTGDServicesErrorInvalidParams", "__Internal")]
		int GDServicesErrorInvalidParams { get; }

		/**< The application attempted to utilize an unsupported type as a service
		 * parameter, either in a service request or in a service response.
		 */

		/// <summary>
		/// </summary>
		[Static, Field ("MTGDServicesErrorCertificateNotFound", "__Internal")]
		int GDServicesErrorCertificateNotFound { get; }

		/**< The application attempted to establish a connection but could not find
		 * a valid X509 certificate.
		 */

		/// <summary>
		/// </summary>
		[Field ("MTGDServicesMethodDisabled", "__Internal")]
		int GDServicesMethodDisabled { get; }

		/**< The service consumer sent a request that specified a method that has been
		 * disabled in the service provider.
		 */

		/// <summary>
		/// </summary>
		[Field ("MTGDServicesVersionDisabled", "__Internal")]
		int GDServicesVersionDisabled { get; }

		/**< The service consumer sent a request that specified a service version that
		 * has been disabled in the service provider.
		 */

		/// <summary>
		/// </summary>
		[Field ("MTGDServicesServiceDisabled", "__Internal")]
		int GDServicesServiceDisabled { get; }
		/**< The service consumer sent a request that specified a service that has been
		 * disabled in the service provider.
		 */
	}

	/** \}
	 */

	/**
	* \addtogroup gdfilesystemerrordomain GDFileSystem Error Domain
	* These constants can be used when handling errors returned by
	* \ref GDFileSystem, \ref GDCReadStream, and \ref GDCWriteStream functions.
	*
	* \{
	*/
	/// <summary>
	/// GDFileSystem Error Domain Constants
	/// </summary>
	[Static]
	[BaseType (typeof(NSObject))]
	public interface GDFileSystemErrorDomainConstants
	{
		/// <summary>
		/// </summary>
		[Static, Field ("MTGDFileSystemErrorDomain", "__Internal")]
		NSString GDFileSystemErrorDomain { get; }
		/**< The error domain for filesystem errors.
	 	*/
	}

	/** \}
	 */

	/** \addtogroup iccconstants Good Inter-Container Communication Miscellaneous Constants
	* These miscellaneous constants can be used with the Good Inter-Container
	* Communication (ICC) sytem.
	*
	* For an overall description of ICC see the   \link GDService GDService class reference\endlink.
	* 
	* \{
	*/
	/// <summary>
	/// Good Inter-Container Communication Miscellaneous Constants
	/// </summary>
	[Static]
	[BaseType (typeof(NSObject))]
	public interface ICCMiscConstants
	{
		/// <summary>
		/// </summary>
		[Static, Field ("MTGDFrontRequestService", "__Internal")]
		NSString GDFrontRequestService { get; }

		/**< Good Dynamics service ID for the Front Request API.
		 * Use this constant when sending or identifying front requests. See under
		 * Foreground Execution and Front Request API in the   \link GDService GDService class reference\endlink.
		 */

		/// <summary>
		/// </summary>
		[Static, Field ("MTGDFrontRequestMethod", "__Internal")]
		NSString GDFrontRequestMethod { get; }
		/**< Method name for the Front Request API.
		 * Use this constant for identifying the front request method. See under
		 * Foreground Execution and Front Request API in the   \link GDService GDService class reference\endlink.
		 */
	}

	/** \}
	 */

	
	/// <summary>
	/// </summary>
	/* Service provider details (deprecated).
	* \deprecated This class is deprecated and will be removed in a future release.
	* This class is used to return information about a service provider in the
	* deprecated service discovery API. The replacement service discovery API uses
	* a different class to return information. See  \link GDiOS.GetServiceProviders  GetServiceProviders  (GDiOS)\endlink.
	* 
	* This class is used to return information about a service provider. An
	* instance of this class either represents an application or a server.
	*
	* The information returned for an application could be used to send a service
	* request to the service provider using Good Inter-Container Communication. See
	* the   \link GDService GDService class reference\endlink for details of the API.
	*
	* The information returned for a server could be used to establish
	* HTTP or TCP socket communications with an instance of the server.
	*/
	[BaseType (typeof(NSObject))]
	[Obsolete ("This class is deprecated and will be removed in a future release.", false)]
	public interface GDAppDetail
	{
		/// <summary>
		/// </summary>
		[Export ("applicationId", ArgumentSemantic.Retain)]
		string ApplicationId { get; set; }

		/**< Good Dynamics Application ID of the service provider.
     	*/

		/// <summary>
		/// </summary>
		[Export ("applicationVersion", ArgumentSemantic.Retain)]
		string ApplicationVersion{ get; set; }

		/**< Good Dynamics Application Version of the service provider.
     	*/
		
		/// <summary>
		/// </summary>
		[Export ("name", ArgumentSemantic.Retain)]
		string Name { get; set; }

		/**< Display name of the service provider.
     	*/

		/// <summary>
		/// </summary>
		[Export ("address", ArgumentSemantic.Retain)]
		string Address { get; set; }

		/**< Native application identifier of the service provider, if it is an
	     * application.\ This is the value that would be passed as the
	     * <TT>application</TT> parameter in a call to
	     *  \link GDServiceClient.SendTo SendTo (GDServiceClient)\endlink.
	     */

		/// <summary>
		/// </summary>
		[Export ("versionId", ArgumentSemantic.Retain)]
		string VersionId { get; set; }

		/**< Version of the service that the application provides.\ Note that
	     * services have versions, in the same way that applications have
	     * versions.\ The details of a service's API, as declared in its schema may
	     * change from version to version.
	     */

		/// <summary>
		/// </summary>
		[Export ("icon", ArgumentSemantic.Retain)]
		UIImage Icon { get; set; }

		/**< Application icon of the service provider, if it is an application and 
	     * an icon has been uploaded by the developer.\ Otherwise, <TT>nil</TT>.
	     */
		
		/// <summary>
		/// </summary>
		[Export ("providerType", ArgumentSemantic.Retain)]
		GDServiceProviderType ProviderType { get; set; }

		/**< Indicator of the type of the service provider, either application-based
	      * or server-based.\ This is provided for diagnostic purposes only; the
	      * original call to the service discovery API will have specified the type
	      * of service provider.
	     */

		/// <summary>
		/// </summary>
		[Export ("serverList", ArgumentSemantic.Retain)]
		NSMutableArray ServerList { get; set; }
		/**< Collection of <TT>GDAppServer</TT> objects, each representing an
	     * instance of a server that provides the service.\ If there is more than
	     * one then the application should use a server selection algorithm, such as
	     * that outlined under the Application Server Selection heading in the
	     * \link GDiOS.GetApplicationConfig GetApplicationConfig (GDiOS)\endlink documentation.
	     */
	}

	/// <summary>
	/// </summary>
	/** Service provider details.
	 * This class is used to return information about a service provider. See
	 *  See  \link GDiOS.GetServiceProviders  GetServiceProviders  (GDiOS)\endlink. An instance of this class either represents an
	 * application or a server.
	 *
	 * The information returned for an application could be used to send a service
	 * request to the service provider using Good Inter-Container Communication. See
	 * the   \link GDService GDService class reference\endlink for details of the API.
	 *
	 * The information returned for a server could be used to establish
	 * HTTP or TCP socket communications with an instance of the server.
	 */
	[BaseType (typeof(NSObject))]
	public interface GDServiceProvider
	{
		/// <summary>
		/// </summary>
		[Export ("identifier", ArgumentSemantic.Retain)]
		string Identifier { get; set; }

		/**< Good Dynamics Application ID of the service provider.
     	*/
		 
		/// <summary>
		/// </summary>
		[Export ("version", ArgumentSemantic.Retain)]
		string Version { get; set; }

		/**< Good Dynamics Application Version of the service provider.
     	*/

		/// <summary>
		/// </summary>
		[Export ("name", ArgumentSemantic.Retain)]
		string Name { get; set; }

		/**< Display name of the service provider.
     	*/

		/// <summary>
		/// </summary>
		[Export ("address", ArgumentSemantic.Retain)]
		string Address { get; set; }

		/**< Native application identifier of the service provider, if it is an
	     * application.\ This is the value that would be passed as the
	     * <TT>application</TT> parameter in a call to
	     *  \link GDServiceClient::sendTo:withService:withVersion:withMethod:withParams:withAttachments:bringServiceToFront:requestID:error: sendTo (GDServiceClient)\endlink.
	     */

		/// <summary>
		/// </summary>
		[Export ("icon", ArgumentSemantic.Retain)]
		UIImage Icon { get; set; }

		/**< Application icon of the service provider, if it is an application and 
	     * an icon has been uploaded by the developer, and the icon data has been
	     * retrieved.\ Otherwise, <TT>nil</TT>.\ See also the <TT>iconPending</TT>
	     * property, below.
	     */

		/// <summary>
		/// </summary>
		[Export ("iconPending", ArgumentSemantic.Retain)]
		bool IconPending { get; set; }

		/**< Flag for whether there is an application icon that has not yet been
	     * retrieved.\ Check this property if the <TT>icon</TT> property is
	     * <TT>nil</TT>.\ If this property is <TT>YES</TT> then there is an icon for the
	     * service provider that has not yet been retrieved by the GD Runtime.\ A
	     * \link GDAppEvent GDAppEvent\endlink with type <TT>GDAppEventServicesUpdate</TT>
	     * will be dispatched when the icon has been retrieved.\ If the
	     * <TT>icon</TT> property is <TT>nil</TT>, and this property is <TT>NO</TT>, it
	     * means that there is no application icon.
	     */

		/// <summary>
		/// </summary>
		[Export ("serverCluster", ArgumentSemantic.Retain)]
		NSArray ServerCluster { get; set; }

		/**< Collection of <TT>GDAppServer</TT> objects, each representing an
	     * instance of a server that provides the service.\ If there is more than
	     * one then the application should use a server selection algorithm, such as
	     * that outlined under the Application Server Selection heading in the
	     * \link GDiOS::getApplicationConfig getApplicationConfig (GDiOS)\endlink documentation.
	     */

		/// <summary>
		/// </summary>
		[Export ("services", ArgumentSemantic.Retain)]
		NSArray Services { get; set; }
		/**< Collection of \link GDServiceDetail GDServiceDetail\endlink objects, each representing a
	     * provided shared service.
	     */
	}

	/// <summary>
	/// </summary>
	/** Details of a provided service.
	 * This class is used to return information about a provided service. The
	 * <TT>services</TT> property of a \link GDServiceProviderType GDServiceProviderType\endlink object is a
	 * collection of instances of this class.
	 */
	[BaseType (typeof(NSObject))]
	public interface GDServiceDetail
	{
		/// <summary>
		/// </summary>
		[Export ("identifier", ArgumentSemantic.Retain)]
		string Identifier { get; set; }

		/**< Good Dynamics Service Identifier.
     	*/

		/// <summary>
		/// </summary>
		[Export ("version", ArgumentSemantic.Retain)]
		string Version { get; set; }

		/**< Good Dynamics Service Version.
     	*/

		/// <summary>
		/// </summary>
		[Export ("type", ArgumentSemantic.Retain)]
		GDServiceProviderType Type { get; set; }
		/**< Indicator of the type of the provided service, either application-based
	     * or server-based.
	     */
	}

	/// <summary>
	/// </summary>	
	public delegate void SendFileSuccessBlock (NSError error);
	/**< Prototype for a SendFileToApplication or SendFileToGFE success block.
	 * A block that conforms to this prototype can be used as the
	 * <TT>withSuccessBlock</TT> parameter to a Secure Documents API send-file
	 * function.
	 *
	 * The code block will be passed a reference to an <TT>NSError</TT> object, or
	 * <TT>null</TT> if no error occurred.
	 *
	 * \see \link GDSecureDocs.SendFileToGFE SendFileToGFE\endlink
	 * \see \link GDSecureDocs.SendFile SendFile\endlink
	 */

	/// <summary>
	/// </summary>
	/** Application server configuration.
	 * This class is used to return the details of application server configuration.
	 * A collection of instances of this class will be in the
	 * <TT>GDAppConfigKeyServers</TT> value returned by the
	 * \link GDiOS::getApplicationConfig getApplicationConfig (GDiOS)\endlink function, or in the
	 * <TT>serverCluster</TT> property of a <TT>GDServiceProvider</TT> object.
	 */
	[BaseType (typeof(NSObject))]
	public interface GDAppServer
	{
		/// <summary>
		/// </summary>
		[Export ("initWithServer:andPort:andPriority:")]
		IntPtr Constructor (string server, NSNumber port, NSNumber priority);

		/// <summary>
		/// </summary>
		[Export ("server", ArgumentSemantic.Retain)]
		string Server { get; }

		/**< Server address. */

		/// <summary>
		/// </summary>
		[Export ("port", ArgumentSemantic.Retain)]
		NSNumber Port { get; }

		/**< Server port number. */

		/// <summary>
		/// </summary>
		[Export ("priority", ArgumentSemantic.Retain)]
		NSNumber Priority { get; }
		/**< Server priority.\ Lower numbers represent higher server priority, with 1
		 * representing the highest.
		 */
	}

	/// <summary>
	/// </summary>
	/** NSInputStream subclass for reading files that are in the secure store.
	 * This class is a subclass of the Foundation <TT>NSInputStream</TT> class
	 * for use when reading files in the secure store (see \ref GDFileSystem).
	 * The subclass supports the <TT>read</TT> and <TT>hasBytesAvailable</TT>
	 * member functions of <TT>NSInputStream</TT>. The subclass does not support
	 * <TT>getBuffer</TT>, which will always return <TT>NO</TT>. And it does not
	 * support  <TT>scheduleInRunLoop</TT> or <TT>removeFromRunLoop</TT> which
	 * are not required as the file data can be read immediately.
	 *
	 * This documentation includes only additional operations provided by
	 * GDCReadStream that are not part of <TT>NSInputStream</TT>.
	 *
	 * \par Notes on use of the read function
	 * This class's <TT>read</TT> function will work best when the supplied buffer
	 * is a multiple of 16 bytes in length.
	 * The <TT>maxLength</TT> parameter should reflect the size of the buffer, and
	 * not the amount of data remaining to be read from the file.
	 * To read a particular number of bytes, <EM>B</EM>, supply a buffer whose size
	 * is <EM>B </EM>rounded up to the next multiple of 16.\n
	 * The return value of this class's <TT>read</TT> function must always be
	 * checked by the application. It must <EM>not </EM>be assumed that a
	 * file has been completely read into a buffer, even if the buffer is large
	 * enough to accomodate the whole file.
	 *
	 * \see <A
	 *     HREF="http://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSInputStream_Class"
	 *     target="_blank"
	 * >NSInputStream class reference in the iOS Developer Library on apple.com</A>
	 * \see \ref GDCWriteStream
	 */
	[BaseType (typeof(NSInputStream))]
	public interface GDCReadStream
	{
		/// <summary>
		/// </summary>
		[Export ("initWithFile:")]
		IntPtr Constructor (string filePath);

		/// <summary>
		/// </summary>
		[Export ("seekToFileOffset:")]
		bool SeekToFileOffset (ulong offset);

		/// <summary>
		/// </summary>
		[Export ("streamError"),]
		NSError StreamError { get; }
	}

	/// <summary>
	/// </summary>
	[BaseType (typeof(NSOutputStream))]
	public interface GDCWriteStream
	{
		/// <summary>
		/// </summary>
		[Export ("initWithFile:append:")]
		IntPtr Constructor (string filePath, bool shouldAppend);

		/**< Constructor that opens a file in the secure store, for reading.
		 * Call this function to open a file in the secure store for reading.
		 * Files in the secure store are encrypted on the device; this
		 * function provides access to decrypted data.
		 *
		 * Note. This constructor is used by the
		 * \link GDFileSystem::getReadStream:error: getReadStream\endlink function in
		 * the \ref GDFileSystem class.
		 *
		 * \param filePath <TT>string</TT> of the path, within the secure store, that
		 * represents the file to be opened.
		 *
		 * \returns <TT>null</TT> if the file could not be opened.
		 */

		/// <summary>
		/// </summary>
		[Export ("seekToFileOffset:")]
		bool SeekToFileOffset (UInt64 offset);

		/**< Seek in an open file in the secure file system.
		 * Call this function to move the file pointer to a specific offset
		 * from the start of the stream.
		 *
		 * \param offset Required offset, expressed as a number of bytes
		 * from the start of the file. Zero means the start of the file.
		 *
		 * \returns <TT>YES</TT> if the file pointer was moved to the required
		 * offset.
		 * \returns <TT>NO</TT> Otherwise.
		 */

		/// <summary>
		/// </summary>
		[Export ("streamError")]
		NSError StreamError { get; }
		/**< Get the last error.
		 * Call this function to get the last error associated with the open stream.
		 *
		 * \returns Reference to an <TT>NSError</TT> object that describes the error.
		 * \see \ref gdfilesystemerrordomain
		 */
	}

	/// <summary>
	/// </summary>
	/** NSPersistentStoreCoordinator subclass that supports an encrypted binary
	 * store type in Core Data.
	 * Good Dynamics applications can store Core Data objects in the Secure Store.
	 *
	 * Using this class instead of the default <TT>NSPersistentStoreCoordinator</TT>
	 * allows the use of the following additional Core Data store types:<DL
	 * ><DT><TT>GDEncryptedBinaryStoreType</TT></DT><DD
	 * >Encrypted binary store that is stored in the Good Dynamics Secure Store.\n
	 * Use this in place of <TT>NSBinaryStoreType</TT>.</DD
	 * ><DT><TT>GDEncryptedIncrementalStoreType</TT></DT><DD
	 * >Encrypted incremental store that is stored in the Good Dynamics Secure
	 * Store.\n
	 * Use this in place of <TT>NSSQLiteStoreType</TT>.\n
	 * This store type is based on <TT>NSIncrementalStoreType</TT> and
	 * is therefore only available in iOS 5.0 or later.</DD
	 * ></DL>
	 *
	 *  \htmlonly <div class="bulletlists"> \endhtmlonly
	 * Note the following details:
	 * - When these store types are in use, the <TT>URL</TT> parameter will be an
	 * absolute path within the Secure File System.
	 * - Use of this class with store types other than the above results in
	 * identical behavior to using the default class.
	 * The above additional store types cannot be used with the default class.
	 * - Data can be migrated from an <TT>NSSQLiteStoreType</TT> store to a
	 * <TT>GDEncryptedIncrementalStoreType</TT> store.
	 * Use the Core Data migration API to do this.
	 * For an example, see the CoreData sample application supplied with the Good
	 * Dynamics SDK.
	 * (It is not possible to import an <TT>NSSQLiteStoreType</TT> store file
	 * directly into the Secure File System, and then use it as a
	 * <TT>GDEncryptedIncrementalStoreType</TT> store.)
	 * - Core Data stores of the above types cannot be accessed until Good Dynamics
	 * authorization processing has completed.
	 * This means that construction of the Managed Object Context, and the
	 * population of views, must be deferred until after Good Dynamics authorization.
	 * (For an example of deferred construction and population, see the CoreData
	 * sample application supplied with the Good Dynamics SDK.)
	 *
	 * \see <A
	 *     HREF="http://developer.apple.com/library/ios/#referencelibrary/GettingStarted/GettingStartedWithCoreData/_index.html%23//apple_ref/doc/uid/TP40005316"
	 *     target="_blank"
	 * >Core Data Starting Point</A> in the iOS Developer Library on apple.com
	 * \see  \link GDFileSystem\endlink
	 * \see  \link sqlite Secure SQL Database API\endlink
	 * \see \link GDiOS\endlink, for Good Dynamics authorization
	 *
	 *  <H2>Code Snippets</H2> The following code snippets illustrate some common tasks.
	 * <H3>Utilize GD Persistent Store Coordinator</H3>
	 * \code
	 * private NSPersistentStoreCoordinator _persistentStoreCoordinator;
	 * public NSPersistentStoreCoordinator GetPersistentStoreCoordinator()
	 * {
	 * 		if (_persistentStoreCoordinator != null) 
	 *		{
	 *			return _persistentStoreCoordinator;
	 *		}
	 *
	 *		NSUrl storeURL = new NSUrl (@"/example.bin");
	 *		NSError error = null;
	 *		_persistentStoreCoordinator = new GDPersistentStoreCoordinator (_managedObjectModel);
	 *		if(!_persistentStoreCoordinator.AddPersistentStoreWithType(GDEncryptedBinaryStoreType, null, storeURL, null, out error);
	 *		{
	 *			Abort();
	 *		}
	 *
	 *		return _persistentStoreCoordinator;
	 *		}
	 *
	 * \endcode
	 *
     */
	[BaseType (typeof(NSPersistentStoreCoordinator))]
	public interface GDPersistentStoreCoordinator
	{
		/// <summary>
		/// </summary>
		[Export ("initWithManagedObjectModel:")]
		IntPtr Constructor (NSManagedObjectModel managedObjectModel);

		/// <summary>
		/// </summary>
		[Field ("GDEncryptedBinaryStoreType", "__Internal")]
		NSString GDEncryptedBinaryStoreType { get; }

		/**< Specify the encrypted binary store type.
         */
		
		/// <summary>
		/// </summary>
		[Field ("GDEncryptedBinaryStoreErrorDomain", "__Internal")]
		NSString GDEncryptedBinaryStoreErrorDomain { get; }

		/**< Specify the encrypted binary store type error domain.
 		 */
		
		/// <summary>
		/// </summary>
		[Field ("GDEncryptedIncrementalStoreType", "__Internal")]
		NSString GDEncryptedIncrementalStoreType { get; }

		/**< Specify the encrypted incremental store type.
 		 */

		/// <summary>
		/// </summary>
		[Field ("GDEncryptedIncrementalStoreErrorDomain", "__Internal")]
		NSString GDEncryptedIncrementalStoreErrorDomain { get; }
		/**< Specify the encrypted incremental store type error domain.
		 */
	}

	/// <summary>
	/// </summary>
	/** Secure File System.
	 * The secure file system is part of the Good Dynamics Secure Storage
	 * feature.
	 *
	 * For applications, the secure file system behaves like the default file
	 * system, with the following exceptions.
	 * - All data within the secure file system is stored on the device
	 * in an encrypted form.
	 * - Directory and file names are also encrypted.
	 * - There is no current working directory in the secure file system. Paths should
	 * always be specified as absolute paths, beginning with a <TT>/</TT> character.
	 * .
	 * The encryption method used may require that the user enters a
	 * security password before the application can access the secure file system.
	 * This depends on enterprise security policy.
	 *
	 * The secure file system cannot be accessed until Good Dynamics authorization
	 * processing is complete, see under  \link GDiOS::authorize: authorize (GDiOS)\endlink.
	 * 
	 * The functions in this API utilize <TT>NSError</TT> in a conventional way. Function calls accept as a parameter the location of a pointer to <TT>NSError</TT>, i.e. a pointer to a pointer, with type <TT>NSError**</TT>. The location may be <TT>nil</TT>. If the location is not <TT>nil</TT>, and an error occurs, the Good Dynamics Runtime overwrites the pointer at the specified location with the address of an object that describes the error that occurred.
	 * 
	 * \see  \link sqlite Secure SQL Database API\endlink
	 * \see \ref GDPersistentStoreCoordinator
	 * \see \ref capilist
	 * \see Security Policies
	 * \see \ref gdfilesystemerrordomain and
	 * \see <A
	 *     HREF="http://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ErrorHandlingCocoa/ErrorHandling/ErrorHandling.html"
	 *     target="_blank"
	 * >Error Handling Programming Guide</A> in the iOS Developer Library
	 * on apple.com
	 * 
	 *  <H2>Code Snippets</H2> The following code snippets illustrate some common tasks.
	 * <H3>Create Directory and File</H3>
	 * \code
	 * NSError error = null;
	 * bool okSoFar = GDFileSystem.CreateDirectoryAtPath (@"/Hello/my", true, null, out error);
	 * 	 if (okSoFar) {
	 * 		Console.WriteLine (@"Directory created OK");
	 *	 } else {
	 * 		Console.WriteLine (String.Format(@"Directory not created {0}", error.LocalizedDescription));
	 * 	 }
	 * 
	 * 	 NSString helloString = @"Hello my world!";
	 * 	 NSData helloStrAsData = helloString.Encode (NSStringEncoding.ASCIIStringEncoding, true);
	 * 	 okSoFar = GDFileSystem.WriteToFile (helloStrAsData, "@/Hellow/my/world.txt", out error);
	 * 	 if (okSoFar) {
	 *	 	Console.WriteLine (@"Wrote OK");
	 *	 } else {
	 *	 	Console.WriteLine (String.Format ("Not written {0}", error.LocalizedDescription));
	 * }
	 * \endcode
	 * The above snippet shows the following, in sequence.
	 * 
	 * Creation of a directory and sub-directory in a single API call, to the
	 * <TT>createDirectoryAtPath:</TT> function. The directory is named
	 * <TT>Hello/</TT> and is in the root of the secure file system. The
	 * sub-directory is named <TT>my/</TT> and is beneath the <TT>Hello/</TT>
	 * directory.
	 * 
	 * Creation of an <TT>NSData</TT> object from an <TT>NSString</TT> containing
	 * <TT>"Hello my world!"</TT>.
	 * 
	 * Creation of a file, <TT>world.txt</TT> in the previously created
	 * sub-directory, by writing the contents of the <TT>NSData</TT> object in a
	 * single API call, to the <TT>writeToFile:</TT> function.
	 *
	 * <H3>Get statistics for secure file</H3>
	 * \code
	 * GDFileStat myStat;
	 * NSError statError = null;
	 *
	 * bool statOK = GDFileSystem.GetFileStat (@"/Hello/my/world.txt", ref myStat, out statError);
	 * if (statOK) {
	 * 		NSDate lastModified = NSDate.FromTimeIntervalSince1970 (myStat.lastModifiedTime);
	 * 		Console.WriteLine (String.Format ("Stat OK. Length: {0}. Last modified: {1}", myStat.fileLen, lastModified.Description));
	 * }\endcode
	 * The above snippet shows getting and then printing the file statistics for the
	 * file created in the previous snippet. The statistic for last-modified time is
	 * loaded into an <TT>NSDate</TT> object with the
	 * <TT>dateWithTimeIntervalSince1970:</TT> function.
	 * 
	 * <H3>Read secure file</H3>
	 * \code
	 * public void ReadSecureFile(string filename)
	 * {
	 * 		NSError streamError = null;
	 *		GDCReadStream iStream = GDFileSystem.GetReadStream (filename, out streamError);
	 *		if (iStream != null) {
	 *			nint nTotalRead = 0;
	 *			while (iStream.HasBytesAvailable) {
	 *				nuint buffer_size = 16 * 1024;
	 *				nint nRead;
	 *				byte[] buffer = new byte[buffer_size] ();
	 *				nRead = iStream.Read (buffer, buffer_size);
	 *				IntPtr dataPtr = IntPtr.Zero;
	 *				NSData myData = NSData.FromBytesNoCopy (System.Runtime.InteropServices.Marshal.Copy (buffer, 0, dataPtr, buffer.Length), buffer_size);
	 *				Console.WriteLine (String.Format ("Data read of length {0}", nRead));
	 *				nTotalRead += nRead;
 	 *			}
	 *		Console.WriteLine(String.Format("Total Data Read of length {0}", nTotalRead);
	 *		}
	 * }
	 * \endcode
	 * <H3>Write secure file</H3>
	 * \code
	 * public void WriteSecureFile(string filename, NSData data)
	 * {
	 * 		bool writeStatus = true;
	 *		NSError streamError = null;
	 *		GDCWriteStream oStream = GDFileSystem.GetWriteStream (filename, false, out streamError);
	 *		if (oStream != null) {
	 * 			oStream.Open ();
	 *			if (oStream.HasSpaceAvailable) {
	 *				Console.WriteLine ("Space Available, Stream Opened for writing");
	 *			} else {
	 *				Console.WriteLine ("Stream opened for writing but no space available.");
	 *				oStream.Close ();
	 *				return false;
	 *			}
	 *		}
	 *		else{
	 *			Console.WriteLine(String.Format("Write stream failed to open: {0}", streamError.LocalizedDescription));
	 *			return false;
 	 *		}
	 *
	 *		// Allocate a byte buffer and copy the data into it.
	 *		nuint datalen = data.Length;
	 *		byte[] oBuffer = new Byte[datalen];
	 *		IntPtr oBufferPtr = data.Bytes;
	 *		oBuffer = System.Runtime.InteropServices.Marshal.Copy (oBufferPtr, oBuffer, 0, datalen);
	 *		nuint chunkSize = 10000;
	 *		nuint soFar = 0;
	 *		while (soFar < datalen) {
	 *			nuint thisChunk = chunkSize;
	 *			if (datalen - soFar < chunkSize) {
	 *				thisChunk = datalen - soFar;
	 *			}
	 *
	 *			nuint writeRet = oStream.Write (oBuffer, soFar, thisChunk);
	 *			if (writeRet > 0) {
	 *				soFar += writeRet;
	 *				Console.WriteLine (String.Format ("Stream Write: {0}, So far {1} of {2}", writeRet, soFar, datalen));
	 *			} else {
	 *				Console.WriteLine (String.Format ("Stream Write Failed: {0}. Stopping...", oStream.StreamError.LocalizedDescription));
	 *				writeStatus = false;
 	 *				break;
	 *			}
	 *		}
	 *
	 *		Console.WriteLine ("Closing Stream");
	 *		oStream.Close ();
	 *		Console.WriteLine ("Stream Closed");
	 *
	 *		return writeStatus;
	 * }
	* \endcode
	* The above snippet shows writing a secure file in a "chunked" manner, after
	* checking that there is space available on the device to store the file.
	*
	* The data to be written is first copied into a byte buffer, allocated with the
	* standard <TT>malloc</TT> function.
	*
	* This snippet is provided to illustrate some of the lower-level functions. In
	* practice, writing a secure file from an <TT>NSData</TT> object would be done
	* by using the <TT>writeToFile</TT> function. This is shown in the Create
	* Directory and File snippet, above.
	*/
	[BaseType (typeof(NSObject))]
	public interface GDFileSystem
	{

		/// <summary>
		/// </summary>
		[Static, Export ("moveFileToSecureContainer:error:")]
		bool MoveFileToSecureContainer (string absoluteFilenameWithPath, out NSError error);

		/// <summary>
		/// </summary>
		[Static, Export ("getFileStat:to:error:")]
		bool GetFileStat (string filePath, ref GDFileStat filestat, out NSError error);

		/**< Get statistics for a file or directory in the secure store.
		 * Call this function to get information about a file or
		 * directory in the secure store.
		 * The information returned is: length of the file, last modified time, and a
		 * flag for whether the path refers to a file or to a directory.
		 *
		 * The function returns the information by overwriting a <TT>GDFileStat</TT>
		 * structure, supplied by reference by the application.
		 * If the path does not exist, the structure is not overwritten.
		 *
		 * \param filePath <TT>string</TT> of the path, within the secure store, that
		 * represents the file or directory whose stats are required.
		 * \param filestat Reference to the <TT>GDFileStat</TT> object to be
		 * overwritten.
		 * \param error For returning an <TT>NSError</TT> object if an error occurs. If <TT>null</TT>, no object will be returned.
		 *
		 * \return <TT>true</TT> if the path exists, and the filestat object was
		 * overwritten.
		 * \return <TT>false</TT> otherwise.
		 *
		 * \see \link GDFileSystem.FileExistsAtPath FileExistsAtPath\endlink
		 */

		/// <summary>
		/// </summary>
		[Static, Export ("removeItemAtPath:error:")]
		bool RemoveItemAtPath (string filePath, out NSError error);

		/**< Delete a file or directory from the secure store.
		 * Call this function to delete a file or directory from the secure store.
		 * If the item is a directory then all its contents, files and sub-directories,
		 * will also be deleted.
		 *
		 * \param filePath <TT>string</TT> of the path, within the secure store,
		 * of the file or directory to be deleted.
		 * \param error For returning an <TT>NSError</TT> object if an error occurs. If <TT>null</TT>, no object will be returned.
		 *
		 * \return <TT>true</TT> if the file or directory existed, and was deleted.
		 * \return <TT>false</TT> otherwise.
		 */

		/// <summary>
		/// </summary>
		[Static, Export ("getReadStream:error:")]
		GDCReadStream GetReadStream (string filePath, out NSError error);

		/**< Open a file that is in the secure store, for reading.
		 * Call this function to open a file in the secure store for reading.
		 * Files in the secure store are encrypted on the device; this
		 * function provides access to decrypted data.
		 *
		 * \param filePath <TT>string</TT> of the path, within the secure store, that
		 * represents the file to be opened.
		 * \param error For returning an <TT>NSError</TT> object if an error occurs. If <TT>null</TT>, no object will be returned.
		 *
		 * \return <TT>GDCReadStream</TT> object from which the file's data can be read,
		 * or a null pointer if the file could not be opened.
		 *
		 * \see \ref ReadFromFile
		 */

		/// <summary>
		/// </summary>
		[Static, Export ("getWriteStream:appendmode:error:")]
		GDCWriteStream GetWriteStream (string filePath, bool appendmode, out NSError error);

		/**< Open a file in the secure store, for writing.
		 * Call this function to create a new file in the secure store,
		 * or to open an existing file for writing.
		 * Files in the secure store are encrypted on the device;
		 * data written to the stream returned by this function will be encrypted,
		 * transparently to the application.
		 *
		 * If a file already exists at the specified path, the file can either be
		 * appended to, or overwritten.
		 *
		 * \param filePath <TT>string</TT> of the path, within the secure store, that
		 * represents the file to be opened.
		 * \param flag Selects the action to take if a file already exists at the path.
		 * <TT>true</TT> to append to the file, or <TT>false</TT> to overwrite.
		 * \param error For returning an <TT>NSError</TT> object if an error occurs. If <TT>null</TT>, no object will be returned.
		 *
		 * \return <TT>GDCWriteStream</TT> object to which data can be written,
		 * or a null pointer if the file could not be opened.
		 *
		 * \see \ref WriteToFile
		 */

		/// <summary>
		/// </summary>
		[Static, Export ("readFromFile:error:")]
		NSData ReadFromFile (string name, out NSError error);

		/**< Read a file that is in the secure store.
		 * Call this function to read a file in the secure store.
		 * Files in the secure store are encrypted on the device; this
		 * function returns decrypted data.
		 *
		 * This function reads the contents of the file into an <TT>NSData</TT> object
		 * with a single API call.
		 * Compare \ref GetReadStream
		 *
		 * \param name <TT>string</TT> of the path, within the secure store, that
		 * represents the file to be read.
		 * \param error For returning an <TT>NSError</TT> object if an error occurs. If <TT>null</TT>, no object will be returned.
		 *
		 * \return Reference to an <TT>NSData</TT> object that contains the file's
		 * contents.
		 */

		/// <summary>
		/// </summary>
		[Static, Export ("writeToFile:name:error:")]
		bool WriteToFile (NSData data, string name, out NSError error);

		/**< Write a file in the secure store.
		 * Call this function to write a new file in the secure store,
		 * or to overwrite an existing file.
		 * Files in the secure store are encrypted on the device;
		 * data written to the file will be encrypted,
		 * transparently to the application.
		 *
		 * This function writes the contents of the <TT>NSData</TT> object to a file
		 * with a single API call. Compare
		 * \ref GetWriteStream
		 *
		 * \param data <TT>NSData</TT> data to be written
		 * \param name <TT>string</TT> of the path, within the secure store, that
		 * represents the file to be written.
		 * \param error For returning an <TT>NSError</TT> object if an error occurs. If <TT>null</TT>, no object will be returned.
		 *
		 * \return <TT>true</TT> if the data was all written to the file.
		 * \return <TT>false</TT> otherwise.
		 *
		 * This function can create a file but cannot create any directory elements of
		 * the path.
		 * This function will return <TT>false</TT> if the directory part of the path does
		 * not already exist in the secure store.
		 */

		/// <summary>
		/// </summary>
		[Static, Export ("writeToFile:name:fromOffset:error:")]
		bool WriteToFile (NSData data, string name, int offset, out NSError error);

		/**< Write into an existing file in the secure store, at an offset into the
		 * file.
		 * Call this function to write into an existing file in the secure store
		 * at a specified offset inside the file.
		 * This function writes the contents of an <TT>NSData</TT> object into the file.
		 * Data currently in the file is overwritten.
		 * Writing the new data may make the file longer.
		 *
		 * See \ref WriteToFile for general details of
		 * writing to files in the secure store.
		 *
		 * \param data <TT>NSData</TT> containing the data to be written.
		 * \param name <TT>string</TT> of the path, within the secure store, that
		 * represents the file to be written.
		 * \param offset <TT>int</TT> offset at which to start writing. This is
		 * relative to the start of the file, as if the contents were not encrypted.
		 * \param error For returning an <TT>NSError</TT> object if an error occurs. If <TT>null</TT>, no object will be returned.
		 *
		 * \return <TT>true</TT> if the data was all written to the file.
		 * \return <TT>false</TT> otherwise.
		 *
		 * This function will return <TT>false</TT> if the file does not exist, if the
		 * offset specified is beyond the file size, or if the input data is empty.
		 */

		/// <summary>
		/// </summary>
		[Static, Export ("createDirectoryAtPath:withIntermediateDirectories:attributes:error:")]
		bool CreateDirectoryAtPath (string path, bool createIntermediates, NSDictionary attributes, out NSError error);

		/**< Create a new directory in the secure store.
		 * Call this function to create a new directory within the secure
		 * file system. The function can create the parent directory, and any other
		 * missing intermediate directories in the path.
		 *
		 * \param path <TT>string </TT> of the path to create within the secure store.
		 * \param createIntermediates <TT>true</TT> to have any missing directories on
		 * the path created.\n
		 * <TT>false</TT> not to create any missing directories.
		 * \param attributes File system attributes to be set on the newly created
		 * directory, and any intermediates that were created.
		 * \param error For returning an <TT>NSError</TT> object if an error occurs. If <TT>null</TT>, no object will be returned.
		 *
		 * \return <TT>true</TT> if the directory did not exist, and was created.
		 * \return <TT>false</TT> otherwise. Note that <TT>false</TT> will be returned if
		 * <TT>createIntermediates</TT> is passed and the parent directory
		 * does not already exist.
		 */
		 
		/// <summary>
		/// </summary>
		[Static, Export ("contentsOfDirectoryAtPath:error:")]
		NSObject [] ContentsOfDirectoryAtPath (string path, out NSError error);

		/**< List contents of a secure file system directory.
		 * This function returns a list of the file and directory names that are in
		 * a specified directory of the secure file system.
		 *
		 * If an error occurs, a reference to an <TT>NSError</TT> object will be
		 * returned. The object will contain details of the error.
		 * (<TT>NSError</TT> is the conventional iOS object for returning
		 * error details.)
		 *
		 * \param path <TT>string</TT> of the path, within the secure store, that
		 * represents the directory to be listed.
		 * \param error For returning an <TT>NSError</TT> object if an error occurs. If <TT>null</TT>, no object will be returned.
		 *
		 * \return <TT>NSArray</TT> of <TT>string</TT> objects that contain the
		 * file and directory names, or <TT>null</TT> if the path does not exist.
		 */

		/// <summary>
		/// </summary>
		[Static, Export ("fileExistsAtPath:isDirectory:")]
		bool FileExistsAtPath (string path, bool isDirectory);

		/**< Check a path exists in the secure store.
		 * Call this function to check if a path exists in the secure file system.
		 * The path could be a plain file or a directory.
		 *
		 * \param path <TT>string</TT> of the path, within the secure store,
		 * that is to be checked.
		 * \param isDirectory Reference to a <TT>bool</TT> that will be set to
		 * <TT>true</TT> if the path refers to a directory, or <TT>false</TT> otherwise.
		 *
		 * \return <TT>true</TT> if the path exists within the secure file system.
		 * \return <TT>false</TT> otherwise.
		 */

		/// <summary>
		/// </summary>
		[Static, Export ("moveItemAtPath:toPath:error:")]
		bool MoveItemAtPath (string srcPath, string dstPath, out NSError error);

		/**< Move or rename a file or directory within the secure file system.
		 * Call this function to move or rename a file or directory within the
		 * secure file system.
		 *
		 * \param srcPath <TT>string</TT> of the path, within the secure store, that
		 * represents the source item that is to be moved or renamed.
		 * \param dstPath <TT>string</TT> of the path, within the secure store, that
		 * represents the item's destination.
		 * \param error For returning an <TT>NSError</TT> object if an error occurs. If <TT>null</TT>, no object will be returned.
		 *
		 * \return <TT>true</TT> if the file or directory existed at the source
		 * location, and was moved to the destination location.
		 * \return <TT>false</TT> otherwise.
		 */

		/// <summary>
		/// </summary>
		[Static, Export ("truncateFileAtPath:atOffset:error:")]
		bool TruncateFileAtPath (string filePath, ulong offset, out NSError error);

		/**< Truncate a file in the secure store.
		 * Call this function to truncate a file in the secure store.
		 * The file will be truncated to a length specified in bytes.
		 *
		 * If the file is longer than the offset specified, the file is truncated and
		 * the extra data lost.
		 * If the file is shorter than the offset then there is no effect; the file
		 * will not be extended.
		 *
		 * \param filePath <TT>string</TT> of the path, within the secure store, of
		 * the file to truncate.
		 * \param offset <TT>ulong</TT> in bytes of the offset at which to
		 * truncate the file.
		 * \param error For returning an <TT>NSError</TT> object if an error occurs. If <TT>null</TT>, no object will be returned.
		 *
		 * \return <TT>true</TT> if the file existed, the offset was less than the
		 * original file size, and the file was truncated successfully.
		 * \return <TT>false</TT> otherwise.
		 */

		/// <summary>
		/// </summary>
		[Static, Export ("getAbsoluteEncryptedPath:")]
		string GetAbsoluteEncryptedPath (string filePath);

		/**< Get the absolute encrypted path of a file within the secure file system.
		 * This function returns the encrypted path for a file or directory within the
		 * secure file system. The principal usage for this function is to provide a
		 * path that is compatible with the SQL ATTACH command.
		 *
		 * \param filePath <TT>string</TT> of the path, within the secure store, that
		 * represents the item for which the encrypted path is required.
		 *
		 * \return <TT>string</TT> containing the encrypted path.
		 */

		/// <summary>
		/// </summary>
		[Static, Export ("exportLogFileToDocumentsFolder:")]
		bool ExportLogFileToDocumentsFolder (out NSError error);

		/**< Dump Good Dynamics logs out to an accessible folder.
		 * Call this function to create a dump of Good Dynamics activity logs. The
		 * logs will be dumped to a file that is outside the secure store, in the
		 * Documents folder.
		 * The file will not be encrypted.
		 * \param error For returning an <TT>NSError</TT> object if an error occurs. If <TT>null</TT>, no object will be returned.
		 *
		 * The log file can be copied from the device in the normal way, and sent to
		 * Good Technology to assist in support analysis.
		 *
		 * \see  \link GDFileSystem.UploadLogs UploadLogs\endlink
		 */

		/// <summary>
		/// </summary>
		[Static, Export ("uploadLogs:")]
		bool UploadLogs (out NSError error);
		/**< Upload Good Dynamics logs to Good Technology.
		 * Call this function to upload Good Dynamics activity logs for support
		 * purposes.
		 * The logs will be uploaded to a server in the Good Technology Network
		 * Operation Center (NOC).
		 * 
		 * Upload takes place in background and is retried as necessary.
		 * This function returns immediately.
		 * \param error For returning an <TT>NSError</TT> object if an error occurs. If <TT>null</TT>, no object will be returned.
		 *
		 * Good Technology support staff have access to the server to which log files
		 * are uploaded, and can use the data for support analysis.
		 * This function can be used to upload logs even if authorization has failed.
		 * The end user's enterprise email address will be needed by support staff,
		 * to identify uploaded files. If authorization has failed or been cancelled
		 * without an email address being successfully entered no logs will be uploaded.
		 *
		 * \see  \link GDFileSystem.ExportLogToDocumentsFolder ExportLogFileToDocumentsFolder\endlink
		 */
	}

	/// <summary>
	/// </summary>
	/** Event dispatched from the Good Dynamics Runtime.
	 * This class is used to deliver events to the \link GDiOS\endlink event handler
	 * in the application. See \ref GDiOSDelegate.
	 */
	[BaseType (typeof(NSObject))]
	public interface GDAppEvent
	{
		/// <summary>
		/// </summary>
		[Export ("message", ArgumentSemantic.Copy)]
		string Message { get; set; }

		/**< Textual description of the event.
	     * This property contains a textual description of the event.
	     * The text is suitable for display to the end user, at least for reporting
	     * diagnostic information for support purposes.
	     */

		/// <summary>
		/// </summary>
		[Export ("code")]
		GDAppResultCode Code { get; set; }

		/**< Numeric result code.
	     * This property contains a numeric result code.
	     * For success events, the <TT>GDErrorNone</TT> code is used.
	     * Other values in the \ref GDAppResultCode enumeration are used for errors.
	     */

		/// <summary>
		/// </summary>
		[Export ("type")]
		GDAppEventType Type { get; set; }
		/**< Numeric event type.
	     * This property contains a numeric type code.
	     * To determine the type of event being notified, compare this property's
	     * value to the constants in the \ref GDAppEventType enumeration.
	     */
	}

	/// <summary>
	/// </summary>
	/** Good Dynamics Runtime object interface, including authorization.
 	* This class represents the application's connection to the Good
 	* Dynamics Runtime on the device, and hence to the wider Good Dynamics platform
 	* infrastructure.
 	*
 	* The API includes a number of functions that the application must call at
 	* particular points in the application execution cycle. The application must
 	* also implement a handler for events dispatched in this API. Calling the
 	* functions, and handling the events correctly, ensures compliance with
 	* enterprise security policies. This API also includes a number of
 	* miscellaneous functions for various purposes, such as setting a custom
 	* logo for display in the user interface.
 	*
 	* The application must initialize the Good Dynamics interface object, using
 	* this API, prior to using any other Good Dynamics API. Initialization will
 	* only succeed if the end user has been provisioned in the enterprise's Good
 	* Control server, and is entitled to use the application.
 	* 
 	* The user's entitlement to the application may later be revoked or
 	* temporarily withdrawn. For example, temporary withdrawal may take place if
 	* the user is inactive for a period of time. In either case, the application
 	* will be notified with an event or callback from this API.
 	*
 	* Successful initialization of the Good Dynamics interface object enables
 	* the Good Dynamics proxy infrastructure within the URL Loading System.
 	*
 	* \see \ref GC
 	* \see <A HREF="https://community.good.com/docs/DOC-1061" target="_blank" >Good Dynamics Administrator and Developer Overview</A > for an introduction to Good Dynamics.
 	* \see \ref threads
 	* \see \ref background_execution
 	* \see \ref GDURLLoadingSystem for proxy enablement within the URL Loading
 	*           System
 	*
 	* <H3>Good Dynamics Platform Connection</H3>
 	* Establishing a connection to the Good Dynamics platform requires
 	* authorization of the end user, and of the application. Both authorizations
 	* are initiated by a single call to the <TT>authorize</TT> function.
 	*
 	* The <TT>authorize</TT> function call is typically made when the
 	* application starts, in the
 	* <TT>application:didFinishLaunchingWithOptions:</TT> handler. It is possible
 	* to initiate authorization processing earlier in the execution cycle, see
 	* under Early Authorization in the API Restrictions section, below, for
 	* details.
 	*
 	* Authorization generally includes establishing a data connection to the GD
 	* proxy infrastructure, and hence to the enterprise that provisioned the end
 	* user. In addition, authorization will also include any necessary registration
 	* of the device, at the GD Network Operation Center (infrastructure
 	* activation), and at the enterprise (enterprise activation). See under
 	* Activation, below, for more details.
 	*
 	* Authorization may include user interaction, see the documentation of the
 	* authorize function, below, for details. All user interaction that is part
 	* of authorization takes place in a user interface that is part of the GD
 	* Runtime library, not part of the application.
 	*
 	* The authorization API is state-based and asynchronous. The initiation
 	* function generally returns immediately. Success or failure of
 	* authorization is then notified to the application code later, as a
 	* transition of the <em>authorization state</em>. The application should
 	* generally wait to be notified of transition to the "authorized" state before
 	* attempting to utilize any other GD APIs.
 	*
 	* Further changes to the authorization state can take place, and are notified
 	* to the application in the same way. See under Authorization State, below.
 	*
 	* \see \ref enterprisesimulation for instructions on building an application to
 	* run in a special limited mode in which authorization with the enterprise is
 	* only simulated.
 	* \see <A
 	*     href="https://community.good.com/docs/DOC-1121" target="_blank"
 	* >Network Operation Center server addresses</A> on the Good Developer Network for IP address
 	* and port number details of the GD Network Operation Center services.
 	*
 	* <H3>Authorization State</H3>
 	* The GD Runtime maintains the authorization state of the application. The GD
 	* APIs that can be utilized by the application depend on its current
 	* authorization state.
 	*
 	* The initial state of the application when it starts is <em>not
 	* authorized</em>. In this state the application can utilize the authorization
	* processing initiation API but cannot utilize any principal GD APIs, such as
 	* secure store access and secure communication.
 	*
 	* After authorization has been initiated and has succeeded, the application
 	* enters the <em>authorized </em>state. The principal GD APIs can then be
 	* utilized.
 	*
 	* Authorization of the end user may be temporarily withdrawn, in which case the
 	* application enters the <em>locked </em>state. This would happen when, for
 	* example, the user does not interact with the application for an extended
 	* period and the enterprise inactivity time out expires. Note that the
 	* authorization of the application itself has not been withdrawn in this state,
 	* only the authorization of the end user to access the application's data.\n
 	* In the locked state, the GD Runtime superimposes an unlock screen on the
 	* application user interface to prevent the user from interacting with the
 	* application or viewing its data. Note that the GD Runtime does not block the
 	* whole device user interface, which means that native notification features
 	* and other ancillary mechanisms
 	* could still be utilized by the application. The application must not cause
 	* sensitive enterprise data to be displayed through these features and
 	* mechanisms when in the locked state.\n
 	* The application can continue to utilize the principal GD APIs, in the
 	* background.
 	*
 	* After a temporary withdrawal ends, the application returns to the authorized
 	* state. This would happen when, for example, the user enters their security
 	* password in the unlock screen.
 	*
 	* Authorization may also be permanently withdrawn, in which case the
 	* application enters the <em>wiped </em>state. This would happen when, for
 	* example, the end user's entitlement to the application is removed by the
 	* enterprise administrator. In the wiped state, the application cannot utilize
 	* the principal GD APIs.
 	* 
 	* Transitions of the authorization state are notified by dispatching a
 	* <TT>GDAppEvent</TT> object to the <TT>GDiOSDelegate</TT> instance in the
 	* application. The event will have a number of attributes, including a type
 	* value that indicates whether the user is now authorized.
 	* 
 	* The authorization states and their corresponding event type values are listed
 	* in the following table.
 	* <TABLE>
 	*     <TR
 	*         ><TH>State</TH
 	*         ><TH>Description</TH
 	*         ><TH
 	*         ><TT>GDApp</TT><TT>Event</TT><BR>type value</TH
 	* 
 	*     ></TR><TR><TD
 	*         >Not authorized</TD
 	*     ><TD
 	*         >Initial state.\n
 	*         The application can initiate authorization, but cannot utilize the
 	*         principal GD APIs.</TD
 	*     ><TD
 	*         ></TD
 	*
 	*     ></TR><TR><TD
 	*         >Authorized</TD
 	*     ><TD
 	*         >Either the user has just been authorized to access the application,
 	*         following authorization processing, or a condition that caused
 	*         authorization to be withdrawn has been cleared.\n
 	*         The application can utilize the principal GD APIs.</TD
 	*     ><TD
 	*         ><TT>GDAppEventAuthorized</TT></TD
 	*
 	*     ></TR><TR><TD
 	*         >Locked</TD
 	*     ><TD
 	*         >Authorization of the user has been temporarily withdrawn, for
 	*         example due to inactivity.\n
 	*         User interaction is blocked. The application can still utilize the
 	*         principal GD APIs.</TD
 	*     ><TD
 	*         ><TT>GDAppEventNotAuthorized</TT></TD
 	*
 	*     ></TR><TR><TD
 	*         >Wiped</TD
 	*     ><TD
 	*         >Authorization of the user has been permanently withdrawn, for
 	*         example due to violation of an enterprise policy for which the
 	*         enforcement action is to wipe the secure container.\n
 	*         The application cannot use any GD APIs.</TD
 	*     ><TD
 	*         ><TT>GDAppEventNotAuthorized</TT>\n
 	*         This is the same event type as the Locked state transition event.</TD
 	*
 	*     ></TR
 	* ></TABLE
 	* >The transitions in the above table are also shown in the
 	* \ref st04gdauthorisation.
 	*
 	* The GD Runtime user interface includes all the necessary screens and messages
 	* to inform the user of the authorization state. The application code needs
 	* only to ensure:
 	* - That it does not bypass the GD Runtime user interface.
 	* - That it does not attempt to access the principal GD APIs prior to
 	*   authorization.
 	* - That it does not attempt to access the principal GD APIs after the
 	*   authorization state has changed to wiped.
 	* .
 	*
 	* 
 	* <H3>API Restrictions</H3>
 	* The application cannot use any of the principal Good Dynamics APIs before
 	* authorization has succeeded. If the application attempts to do so, the Good
 	* Dynamics Runtime generates an assertion,
 	* which results in the application being terminated.
 	* The Good Dynamics Runtime uses the Foundation <TT>NSAssert</TT> macro to
 	* generate these assertions.
 	*
 	* The Good Dynamics Runtime does not
 	* generate assertions
 	* for transient conditions, but only for apparent programming errors in the
 	* application. Consequently, these assertions are only
 	* expected when the application is in development, and not when the application
 	* is in production. The failure message of the
 	* assertion will describe the programming error.
 	*
 	* The recommended approach is that the application should be allowed to
 	* terminate, so that the failure message can be read
 	* on the console.
 	* The failure message will describe the programming error, which can then be
 	* corrected.
 	* For example, a message like the following could be seen in the logs:\n
 	* <TT>My application [7506:40b] *** Terminating app due to uncaught exception
 	* 'NSInternalInconsistencyException', reason:
 	* 'Not authorized. Call GDiOS.Authorize first.'</TT>
 	*	
 	* <H4>Early Authorization</H4>
 	* An application can initiate authorization at a number of stages in its
 	* execution cycle. The typical stage for authorization initiation is the
 	* <TT>Application.DidFinishLaunchingWithOptions</TT> handler. Initiation in
 	* this stage requires only that the application calls the <TT>Authorize</TT>
 	* function.
 	*
 	* An application could instead initiate authorization at an earlier stage of
 	* the execution cycle. In that case, an additional initialization function
 	* must also be called. Calling an initialization function enables early
	* authorization.
 	*
 	* There are two initialization functions:
 	* - \link GDiOS.InitializeWithClassConformingToUIApplicationDelegate InitializeWithClassConformingToUIApplicationDelegate\endlink
 	* - \link GDiOS.InitializeWithClassNameConformingToUIApplicationDelegate InitializeWithClassNameConformingToUIApplicationDelegate\endlink
 	* .
 	* Call either one of these to enable early authorization. The call should be
 	* made prior to the <TT>UIApplicationMain</TT> call, which is in the
 	* application <TT>main()</TT> subroutine in the <TT>main.cs</TT> file, by
 	* default.
 	*
 	* If an initialization function is not called and early authorization is
 	* attempted, the Good Dynamics Runtime will generate an assertion. A message
 	* like the following could be seen in the logs:\n
 	* <TT>My application [7506:40b] *** Terminating app due to uncaught exception
	* 'NSInternalInconsistencyException', reason:
 	* 'Not initialized. Either move the [GDi</TT><TT>OS authorize] call to your
 	* application:didFinishLaunchingWithOptions: code, or call an initialization
 	* function such as [GDi</TT><TT>OS
 	* initializeWithClassConformingToUIApplicationDelegate:] prior to
	* UIApplicationMain.'</TT>
	* 
 	* In some earlier versions of the GD SDK for iOS it was always necessary to
 	* call an initialization function, even when not using early authorization.
	*
 	* <H3>Activation</H3>
 	* In Good Dynamics, activation refers to a number of registration procedures
 	* that must be completed in order to access all platform capabilities. Once a
 	* particular activation has been completed, registration credentials are stored
 	* on the device. This means that each activation need only be processed once.
 	*
 	* Activations are generally transparent to the application. The application
 	* will call a Good Dynamics authorization method, and the runtime will process
 	* whichever activations are required.
 	*
 	* There are two activations in Good Dynamics.<DL
 	* ><DT
 	*     >Infrastructure activation</DT><DD
 	*         >Recognition of the mobile device as a terminal by the
 	*         Good Technology central server.</DD
 	* ><DT
 	*     >Enterprise activation</DT><DD
 	*         >Association of the terminal with a provisioned end user at the
 	*         enterprise. This requires the user to enter an activation key. The
 	*         key can be sent to the user by email when they are provisioned, or
 	*         made available through the Good Control self-service interface.</DD
 	* ></DL>
 	* \see \ref GC for details on how to provision a user for development purposes.
 	* \see \ref enterprisesimulation for instructions on building an application to
 	* run in a special limited mode in which there is no enterprise activation.
 	*
 	* <H3>Application identification</H3>
 	* Unique Good Dynamics application identifier (GD App ID) values are used to
 	* identify GD mobile applications. GD App ID values are used in the mobile
 	* application, and in the management user interface at the enterprise, the Good
 	* Control console. The GD App ID is generally accompanied by a separate GD
 	* Application Version.
 	*
 	* In the mobile application, the GD App ID and version values are set by the
 	* authorization call, as documented in the <TT>Authorize</TT> function
 	* reference, below. In the Good Control console, the GD App ID and version
 	* values are entered as part of application registration, see the \ref GC.
 	*
 	* <H4>Good Dynamics Application Identifier</H4>
 	* GD App IDs are textual and follow a typical naming convention. The reversed
 	* Internet domain of the application developer forms the initial part of the GD
 	* App ID. For example, applications developed by Good Technology have IDs that
 	* begin "com.good." since Good Technology owns the good.com domain.
 	*
 	* The rest of the ID is made up of the application's name, possibly preceded by
 	* a number of categories and sub-categories. Categories and sub-categories are
 	* separated by full stops. For example, the ID of an example Good Dynamics
 	* remote database application, made by Good Technology, could be:
 	* "com.good.gd.examples.remotedb".
 	*
 	* Formally, the syntax of a GD App ID is a string that:
 	* - Contains only the following ASCII characters: hyphen (dash), full stop
 	*   (period), numeric digit, lower-case letter.
 	* - Conforms to the &lt;subdomain&gt; format initially defined in section 2.3.1
 	*   of <A
 	*      HREF="http://www.ietf.org/rfc/rfc1035.txt"
 	*      target="_blank"
 	*   >RFC1035</A> and subsequently modified in section 2.1 of <A
 	*      HREF="http://www.ietf.org/rfc/rfc1123.txt"
 	*      target="_blank"
 	*   >RFC1123</A>.
 	* .
 	*
 	* <H4>Good Dynamics Application Version</H4>
 	* A GD Application Version value is a string made up of a sequence of numbers
 	* separated by full stops (periods). The following represents best practice.
 	* - The first release of the application should have "1.0.0.0" as its GD
 	*   Application Version.
 	* - The version string should change in subsequent releases in which one of the
 	*   following software changes is made:
 	*   - The application starts to provide a new shared service or shared service
 	*     version.
 	*   - The application stops providing a shared service or shared service
 	*     version.
 	*   .
 	*   Otherwise, version should not change in the release.
 	* .
 	*
 	* See the   \link GDService GDService class reference\endlink for details of shared services.
 	*
 	* The syntax rules of the GD Application Version value are as follows.
	* - A version string consists of one to four version numbers separated by full
 	*   stop (period) characters.
 	* - A version number consists of one of the following:
 	*   - A single zero.
 	*   - A sequence of up to three digits with no leading zero.
 	*   .
 	* .
 	* The syntax can be formally expressed as the following regular expression:
 	* <TT>(0|[1-9][0-9]{0,2})(.(0|[1-9][0-9]{0,2})){0,3}</TT>
 	* 
 	* Do not use a different GD Application Version for an early access or beta
 	* software release. Instead, add a suffix to the GD App ID and native
 	* application identifier used for general access. For example, the GD App ID
 	* "com.example.gdapp.beta" could be used to identify a "com.example.gdapp" beta
 	* release.\n
 	* Using a different native identifier makes it possible for general access and
 	* early access software to be installed on the same mobile device, and
 	* facilitates use of different signing certificates.
 	*
 	* <H3>Application user interface restrictions</H3>
 	* The Good Dynamics Runtime monitors the application user interface in order to
 	* enforce a number of enterprise security policies. For example, there may be a
 	* policy that the user must always enter their security password when the
 	* application makes the transition from background to foreground. There may
 	* also be a policy that the user interface must be locked after a period of
 	* inactivity.
 	*
 	* The application user interface must observe a number of restrictions in order
 	* to enable monitoring by the Good Dynamics Runtime.
 	*
 	* The application must use the \link GDiOS::getWindow getWindow (GDiOS)\endlink function instead
 	* of creating a new <TT>UIWindow</TT> object.
 	*
 	* The application must close any open modal dialogs when entering background.
 	* This includes, for example, any <TT>UIAlertView</TT> messages that are open.
 	* This can be done in the <TT>DidEnterBackground</TT> handler, by
 	* calling the <TT>Dismiss</TT> method of the view
 	* controller.
 	*
 	* \see <A
 	*     HREF="http://iosapi.xamarin.com/?link=T%3aUIKit.UIAlertView"
 	*     target="_blank"
 	* >UIAlertView class reference in the Xamarin.iOS Documentation on xamarin.com</A>
 	*
 	*  \htmlonly <div class="bulletlists"> \endhtmlonly
 	*
 	* <H3>Build-Time Configuration</H3>
 	* The following build-time configuration is mandatory for all Good Dynamics
 	* applications.
 	* 
 	* The application must register a specific URL type on the device. This enables
 	* Good Inter-Container Communication (ICC), which is required for enforcement
 	* of any authentication delegation policy set by the enterprise.
 	* 
 	* The URL type must be the same as the application's native bundle identifier.
 	* Within the URL type declaration, four URL schemes must be declared. Two
 	* schemes must be declared that are the same as the URL type, with <TT>.sc</TT>
 	* and <TT>.sc2</TT> appended. An additional scheme must be declared that is the
 	* same as the URL type with <TT>.sc2.</TT> and then the GD Application Version
 	* appended. In addition, <TT>com.good.gd.discovery</TT> must be declared as a
 	* scheme. The URL type and schemes would be declared in the application's
 	* Info.plist file, as usual.
 	*
 	* For example, if the native bundle identifier of the application was
 	* <TT>com.example.gd.myapp</TT> then the URL type declared would also be
 	* <TT>com.example.gd.myapp</TT> and the URL schemes would be:
 	* - <TT>com.example.gd.myapp.sc</TT>
 	* - <TT>com.example.gd.myapp.sc2</TT>
 	* - <TT>com.example.gd.myapp.sc2.1.0.0.0</TT>
 	* - <TT>com.good.gd.discovery</TT>
 	* .
 	* The Info.plist file of any of the sample applications supplied with the Good
 	* Dynamics SDK can be used as a guide.
 	*
 	* Alternatively, add the following XML to the application's Info.plist file,
 	* using a text editor. Change all four instances of <TT>com.iOS.App.ID</TT> to
 	* the native bundle identifier of the application.
 	* \code
 	* <key>CFBundleURLTypes</key>
 	* <array>
 	*     <dict>
 	*         <key>CFBundleTypeRole</key>
 	*         <string>None</string>
 	*         <key>CFBundleURLName</key>
 	*         <string>com.iOS.App.ID</string>
 	*         <key>CFBundleURLSchemes</key>
 	*         <array>
 	*             <string>com.iOS.App.ID.sc</string>
 	*             <string>com.iOS.App.ID.sc2</string>
 	*             <string>com.iOS.App.ID.sc2.1.0.0.0</string>
 	*             <string>com.good.gd.discovery</string>
 	*         </array>
 	*     </dict>
 	* </array>
 	* \endcode
 	* Note that the first three <TT>CFBundleURLSchemes</TT> array items have a .sc
 	* suffix, a .sc2 suffix and a .sc2.1.0.0.0 suffix applied to the native bundle
 	* identifier. The <TT>CFBundleTypeRole</TT> element is not used by Good
 	* Dynamics and could take another value, as required by the application.
 	* 
 	* In case there are multiple Info.plist files, check that the correct one has
 	* been edited by opening the Info tab of the application target being built.
 	* The declarations just made should appear there.
 	*
 	* The Good Dynamics Runtime checks the configuration during authorization
 	* processing. The end user will not be authorized if the configuration is
 	* incorrect.
 	* 
 	* The above configuration also enables Good Dynamics Application-Based
 	* Services, see the   \link GDService GDService class reference\endlink.
 	*
 	* <H4>Good Dynamics Custom Linker</H4>
 	* Use of the Good Dynamics custom linker is mandatory for all Good Dynamics for
 	* iOS applications, and is part of compliance with Federal Information
 	* Processing Standards (FIPS). The linker enables the Good Dynamics Runtime to
 	* check its own binary integrity when it runs.
 	*
 	* Configure the linker using one of the following sets of instructions,
 	* depending on whether the application includes any Swift source files.
 	*
 	* To enable a Xamarin.iOS application to use the Good Dynamics Custom Linker,
 	* navigate to the project settings by double clicking on the project file from
 	* within Xamarin Studio. Once there, navigate to the iOS Build tab. In the
 	* "additional mtouch arguments" field, add the following statement:
 	* 
 	* -cxx --registrar:static --linkskip=Xamarin.iOS --linkskip=System.Core --linkskip=System 
 	* --linkskip=mscorelib --gcc_flags="-stdlib=libstdc++ 
 	* -B /'Good Technology'/Good.platform/FIPS_module/{SystemArch}/bin"
 	* 
 	* Where {SystemArch} is your current build configuration:
 	* 	-i386.sdk
 	* 	-Armv7.sdk
 	* 	-Armv7s.sdk
 	* 	-Arm64.sdk
 	* 	-x86_64.sdk
 	* 
 	* These will need to be manually set for each build configuration target.
 	*
 	* The Good Dynamics Runtime fails with an error message like the following if
 	* the custom linker is not configured:\n
 	* <TT>"Crypto::initialise: FIPS_mode_set failed: fingerprint does not
 	* match"</TT>
 	* 
 	* <H2>Code Snippets</H2> The following code snippets illustrate some common tasks.
 	* <H3>Early runtime object initialization</H3>
 	* The following snippet shows early initialization of the GD Runtime object.
 	* \code
 	* GDiOS.InitializeWithClassConformingToUIApplicationDelegate(BrowserAppDelegate.Class);
 	* int retVal = UIApplication.Main (args, null, ApplicationDelegateName);
 	* \endcode
 	* The above code would be placed in the <TT>main()</TT> of the Browser
 	* application.
 	* 
 	* <H3>Authorization</H3>
 	* The following snippet shows initiation of Good Dynamics authorization.
 	* \code
	* GDiOS.SharedInstance().Delegate = this;
    * GDLibrary.Authorize();
 	* \endcode
 	* After executing the above code, the application would wait for its delegate
 	* callback to be invoked. The invocation would have an event type of
	* <TT>GDAppEventAuthorized</TT> if the user was authorized. After that, the
	* application could make full use of all Good Dynamics capabilities.
	*
	* The above code relies on the identification parameters being in the
	* Info.plist file, as shown in the following snippet.
	* \code
	* <key>GDApplicationID</key>
	* <string>com.example.browser</string>
	* <key>GDApplicationVersion</key>
	* <string>1.0.0.0</string>
	* \endcode
	* The above is an extract from the XML of the application's Info.plist file.
	* The extract sets "com.example.browser" as the GD application ID, and
	* "1.0.0.0" as the GD application version.
	*
	* <H3>User interface pre-initialization</H3>
	* The following snippet shows some necessary steps that precede initialization
	* of the application's user interface. The recommended place in the code for
	* these steps is as shown in the snippet.
	* \code
	*
	* @synthesize window;
	*
	* public override bool FinishedLaunching (UIApplication application, NSDictionary launchOptions)
	* {
	*	GDiOS.SharedInstance().Delegate = this;
	*	GDiOS.SharedInstance().Authorize();
	*	Window = GDiOS.SharedInstance().GetWindow();
	*	Window.MakeKeyAndVisible ();
	*	return true;
	* }
	* \endcode
	*
	* The above snippet shows the following sequence of actions.
	* -# A reference to the GDiOS singleton object is obtained.
	* -# The application sets its window to be the <TT>UIWindow</TT> of the Good
	*    Dynamics Runtime.
	* -# The current class is set as the delegated event handler.
	* -# The <TT>started</TT> flag is set, to control initialization of the
	*    application's user interface, which is covered in the following snippet.
	*    The flag's declaration (not shown) would be <TT>BOOL</TT>.
	* -# The application initiates Good Dynamics authorization.
	* .
	* Authorization processing is asynchronous. On completion, an event will be
	* dispatched to the application's handler. The application completes user
	* interface initialization within its event handler, as shown in the following
	* code snippet.
	*
	* <H3>User interface initialization</H3>
	* The following snippet shows the recommended place in the code to initialize
	* the application's user interface.
	* \code
	*
	* public override void HandleEvent (GDAppEvent anEvent)
    * {
	*	switch (anEvent.Type)
	*	{
	*		case GDAppEventType.Authorized:
	*			OnAuthorized (anEvent);
	*			break;
	*		case GDAppEventType.NotAuthorized:
	*			OnNotAuthorized (anEvent);
	*			break;
	*		case GDAppEventType.RemoteSettingsUpdate:
	*			OnRemoteSettingsUpdated ();
	*			break;
	*		}
	*	}
	* \endcode
	* The above code shows a simple GD Event Handler.
	*
	* The handler calls the application's own <TT>initializeUI</TT> function
	* when a <TT>GDAppEventAuthorized</TT> event is received for the first time.
	* The application's <TT>started</TT> flag is used to control first-time
	* execution. Initialization of this flag is shown in the previous snippet.\n
	* The <TT>initializeUI</TT> function would complete user interface
	* initialization, utilizing a reference to the Good Dynamics runtime's
	* <TT>UIWindow</TT>.
	* The previous snippet shows how the reference can be obtained.
	*
	* The handler calls the application's own <TT>onNotAuthorized</TT> function
	* whenever a <TT>GDAppEventNotAuthorized</TT> event is received.
	*/
	[BaseType (typeof(NSObject), Delegates = new string[] { "WeakDelegate" }, Events = new Type[] { typeof(GDiOSDelegate) })]
	public interface GDiOS
	{

		/// <summary>
		/// </summary>
		[Export ("delegate", ArgumentSemantic.Assign)]
		NSObject WeakDelegate { get; set; }

		/// <summary>
		/// </summary>
		[Wrap ("WeakDelegate")]
		[NullAllowed]
		GDiOSDelegate Delegate { get; set; }

		/**< Delegated event-handling.
		 * When authorization processing completes, or a Good Dynamics Runtime object
		 * event occurs, an event is generated by the runtime, and passed to a callback
		 * function in the application code.
		 *
		 * Set this property to an instance of a class in the application that contains
		 * the code for the required callback function, i.e. a class that implements
		 * the GDiOSDelegate protocol.
		 */

		/// <summary>
		/// </summary>
		[Static, Export ("initializeWithClassNameConformingToUIApplicationDelegate:")]
		void InitializeWithClassNameConformingToUIApplicationDelegate (string applicationDelegate);

		/**< Enable early authorization by specifying a class name.
		 * Call this function to enable early authorization.
		 *
		 * Early authorization means authorization prior to the
		 * <TT>DidFinishLaunching</TT> invocation. Only call
		 * this function if using early authorization. See under Early Authorization
		 * in the API Restrictions section, above, for details.
		 *
		 * In some earlier versions of the GD SDK for iOS it was always necessary to
		 * call an initialization function like this one, even when not using early
		 * authorization.
		 * 
		 * This function does not initiate any data communication or user
		 * interaction. Compare \ref authorize "Authorize".
		 *
		 * If used, this function must be called before any other Good Dynamics API
		 * functions, except <TT>IsInitialized</TT>.
		 *
		 * \param applicationDelegate <TT>string</TT> containing the name of the
		 * application class that conforms to <TT>UIApplicationDelegate</TT>.
		 *
		 * \see <A
		 *     HREF="http://iosapi.xamarin.com/?link=T%3aUIKit.UIApplicationDelegate"
		 *     target="_blank"
		 * >UIApplicationDelegate reference</A> in the Xamarin.iOS Developer Documentation on
		 * xamarin.com
		 */
		
		/// <summary> 
		/// </summary>
		[Export ("launchOptions", ArgumentSemantic.Retain)]
		NSDictionary LaunchOptions { get; set; }

		/**< Application launch options.
		 * Access this property to obtain the options with which the Good Dynamics
		 * application was launched. The property is a reference to an object with the
		 * same semantics as the <TT>options</TT> parameter to the
		 * <TT>FinishedLaunching</TT> function in the
		 * <TT>UIApplicationDelegate</TT> protocol.
		 * 
		 * \see <A
		 *     HREF="http://iosapi.xamarin.com/?link=M%3aUIKit.UIApplicationDelegate.FinishedLaunching"
		 *     target="_blank"
		 * >UIApplicationDelegate.FinishedLaunching method documentation</A> in the
		 * <TT>UIApplicationDelegate</TT> interface reference in the Xamarin.iOS Developer
		 * Documentation on xamarin.com for details.
		 */

		/// <summary>
		/// </summary>
		[Static, Export ("initializeWithClassConformingToUIApplicationDelegate:")]
		void InitializeWithClassConformingToUIApplicationDelegate (Class applicationDelegate);

		/**< Enable early authorization by specifying a class.
		 * Call this function to enable early authorization. See \ref
		 * InitializeWithClassNameConformingToUIApplicationDelegate
		 * "InitializeWithClassNameConformingToUIApplicationDelegate" for details.
		 *
		 * \param applicationDelegate The application <TT>Class</TT> that conforms to
		 * <TT>UIApplicationDelegate</TT>.
		 */
		
		/// <summary>
		/// </summary>
		[Static, Export ("isUsingDataPlan")]
		bool IsUsingDataPlan ();

		/**< Check whether the application is using a data plan for split billing.
		 * Call this function to check the current data plan state of the
		 * running application.
		 * 
		 * \return <TT>true</TT> if the application has been registered and entitled to a
		 *                  data plan for split billing.
		 * \return <TT>false</TT> otherwise.
		 *
		 * See the <A
		 *   href="http://www.good.com"
		 *   target="_blank"
		 * >Good Technology corporate website</A> for information about the Good Data
		 * Plan split billing product, when available.
		 */
		
		/// <summary>
		/// </summary>
		[Static, Export ("isInitialized")]
		bool IsInitialized ();
		/*< Get the Good Dynamics interface object's initialization status.
		 * This function returns the current initialization status of the Good
		 * Dynamics interface object.
		 *
		 * \return <TT>true</TT> if the Good Dynamics interface object has been
		 * initialized, and has not been finalized.
		 * \return <TT>false</TT> otherwise.
		 *
		 * Note: This function can be called before an 
		 * \link GDiOS.InitializeWithClassNameConformingToUIApplicationDelegate
		 * Initialize function\endlink.
		 */
		
		/// <summary>
		/// </summary>
		[Static, Export ("sharedInstance")]
		GDiOS SharedInstance ();

		/**< Get a reference to the Good Dynamics interface object.
		 * This function returns a reference to the Good Dynamics
		 * interface object.
		 * This function can be called in the
		 * <TT>DidFinishingLaunching</TT> handler of the
		 * application. This function can also be called at some earlier stages
		 * of the execution cycle, in which case an
		 * \link GDiOS.InitializeWithClassNameConformingToUIApplicationDelegate Initialize function\endlink
		 * must also have been called, prior to <TT>UIApplicationMain</TT>.
		 *
		 * The Good Dynamics interface object is a "singleton class".
		 *
		 * \return Reference that can be used to call, for example, \link GDiOS.Authorize Authorize (GDiOS)\endlink.
		 */
		
		/// <summary>
		/// </summary>
		[Export ("getWindow")]
		UIWindow GetWindow ();

		/**< Get the <TT>UIWindow</TT> for the application.
		 * This function returns a reference to the <TT>UIWindow</TT> that contains
		 * the core logic of the Good Dynamics Runtime. Always use this function
		 * instead of creating a new <TT>UIWindow</TT> in the application.
		 *
		 * The Good Dynamics Runtime creates its own <TT>UIWindow</TT> in order to show
		 * its user interface elements, and to track for user inactivity. The runtime
		 * does not add any persistent subviews, so the application is free to add and
		 * remove its own subviews on the runtime's <TT>UIWindow</TT>. For example,
		 * after authorization, the application could call
		 * <TT>UIWindow.RootViewController</TT> to add its own <TT>UIViewController</TT> or
		 * <TT>UINavigationController</TT>.
		 *
		 * The runtime calls <TT>MakeKeyAndVisible</TT> on its <TT>UIWindow</TT> during
		 * authorization processing, so the application need not do this. The
		 * application must not make a different <TT>UIWindow</TT> the key window. The
		 * application also must not release the runtime's <TT>UIWindow</TT> object.
		 *
		 * \return Reference to the Good Dynamics Runtime's <TT>UIWindow</TT>, which
		 * must be used as the application's key window.
		 *
		 * \see <A
		 *     HREF="http://iosapi.xamarin.com/?link=T%3aUIKit.UIWindow"
		 *     target="_blank"
		 * >UIWindow class reference</A> in the Xamarin.iOS Developer Documentation on xamarin.com
		 */
		
		/// <summary>
		/// </summary>
		[Export ("getVersion")]
		string GetVersion ();

		/**< Get the Good Dynamics Runtime library version.
		 * \return <TT>string</TT> containing the Good Dynamics Runtime library
		 * version in <EM>major</EM><TT>.</TT><EM>minor</EM><TT>.</TT><EM>build</EM>
		 * format.
		 */

		/// <summary>
		/// </summary>
		[Export ("authorize:")]
		void Authorize (GDiOSDelegate aDelegate);

		/**< Connect to the Good Dynamics infrastructure.
		 * Call this function to initiate GD authorization
		 * processing.
		 *
		 * 
		 * Authorization involves a number of exchanges with various servers in the
		 * Good Dynamics proxy infrastructure, and may involve user interaction.
		 * The following processing items are the most significant.<DL
		 *
		 * ><DT>Infrastructure activation</DT><DD
		 * >The Good Dynamics Runtime registers the device as a terminal with the Good
		 * Technology Network Operation Center (NOC). The NOC issues registration
		 * credentials, which are encrypted and stored on the device. Infrastructure
		 * activation is not processed if registration credentials are already
		 * present.</DD
		 *
		 * ><DT>Enterprise activation</DT><DD
		 * >Enterprise activation is the completion of the Enterprise Provisioning
		 * process, which begins on the enterprise's Good Control server.
		 * During enterprise provisioning, an activation key will have been made
		 * available to the end user, either by email or in the Good Control
		 * self-service interface. During enterprise activation, the user enters
		 * the activation key, in a Good Dynamics Runtime user interface. The
		 * runtime then sends the key to the NOC. If the key is recognized, the device
		 * is registered as being associated with the provisioning enterprise.
		 * Enterprise registration credentials are then issued, and encrypted and stored
		 * on the device.\n
		 * Enterprise activation is not processed if enterprise registration
		 * credentials are already present.\n
		 * Note that successful enterprise activation has the effect of consuming the
		 * activation key. This will be the case even if a later stage of authorization
		 * processing fails, or if the user is found to be not entitled to this
		 * application.</DD
		 *
		 * ><DT>Entitlement checking</DT><DD
		 * >The enterprise that provisioned the end user can later withdraw the
		 * user's entitlement to the application. Withdrawal is flagged in the
		 * enterprise's Good Control server.
		 * The Good Dynamics Runtime checks the end user's ongoing entitlement to the
		 * application every time authorization is processed. (In addition, withdrawal
		 * may be notified to the runtime by the Good Dynamics NOC.)\n
		 * In the Good Control (GC) console, entitlement is given to particular
		 * versions of particular applications. The version and GD App ID values must
		 * match exactly with a version and GD App ID to which the user has been given
		 * entitlement in the GC console. If there is not an exact match, then user
		 * entitlement is assumed to have been withdrawn.\n
		 * If the user is found not to be entitled, then the Good Dynamics container
		 * will be wiped of all application data and authentication credentials.</DD
		 *
		 * ><DT>Policy update</DT><DD
		 * >Policies govern many aspects of the Good Dynamics user experience. For
		 * example, the minimum characteristics of the end user's security password with
		 * respect to length and types of character are governed by a
		 * Good Dynamics policy. So is the need for the end user to set a security
		 * password.
		 * The Good Dynamics Runtime checks for and retrieves updated policies
		 * every time authorization is processed.</DD
		 *
		 * ><DT>Policy checking</DT><DD
		 * >The Good Dynamics Runtime checks for compliance with the most up-to-date
		 * policies every time authorization is processed.</DD
		 *
		 * ><DT>Configuration retrieval</DT><DD
		 * >The Good Dynamics Runtime retrieves a set of application configuration
		 * settings from the enterprise Good Control server during authorization
		 * processing. These will have been entered in the Good Control console.
		 * See under \link GDiOS.GetApplicationConfig GetApplicationConfig (GDiOS)\endlink for a list of settings.</DD
		 *
		 * ><DT>Unlock secure store</DT><DD
		 * >The Good Dynamics secure store is unlocked during authorization. If the
		 * store is protected by an end-user password, then the user must enter their
		 * password for authorization processing to complete. Password entry is a Good
		 * Dynamics Runtime user interface.</DD
		 * ></DL>
		 * Note that Good Dynamics Runtime user interfaces, such as Enterprise
		 * activation and Password entry, are opened and closed as needed, without
		 * reference to the application.
		 *
		 * This function can be called in the
		 * <TT>application:didFinishLaunchingWithOptions:</TT> handler of the
		 * application, but see also the notes for Early Authorization under API
		 * Restrictions, above.
		 *
		 * This function must be called before any of the principal Good Dynamics
		 * API functions.
		 *
		 * Data communication during authorization processing does not go via
		 * the proxy specified in the device's native settings, if any.
		 *
		 * \param aDelegate Reference to the delegated event handler, typically
		 * <TT>self</TT>.
		 *
		 * Application identification parameters will be read from the following properties
		 * in the application Info.plist fi<TT></TT>le:<TABLE
		 *     ><TR><TH>Key</TH><TH>Type</TH><TH>Value</TH
		 *     ></TR><TR><TD
		 *         ><TT>GDApplicationID</TT></TD
		 *         ><TD><TT>String</TT></TD
		 *         ><TD>Good Dynamics Application ID (GD App ID)
		 *
		 *         GD App ID is used to control access to the application by end users,
		 *         and to configure its application server connections. The value passed
		 *         must be the same as that entered when the application was registered
		 *         in the enterprise's Good Control console. (Note that the value need
		 *         not be the same as the native application identifier.)
		 *
		 *         For syntax details see under Application Identification, above.</TD
		 *     ></TR><TR><TD
		 *         ><TT>GDApplicationVersion</TT></TD
		 *         ><TD><TT>String</TT></TD
		 *         ><TD>Good Dynamics application version number
		 *
		 *         The version number can be combined with the GD App ID, above, to
		 *         control access to particular versions of the application.</TD
		 *     ></TR
		 * ></TABLE>
		 * (In case there are multiple Info.plist files, check that the correct one has
		 * been edited by opening the Info tab of the application target being built.
		 * The settings should appear there.)
		 * 
		 * Authorization is asynchronous. When authorization processing completes,
		 * the delegate \link GDiOSDelegate.HandleEvent: HandleEvent\endlink callback
		 * is invoked.
		 *
		 * For instructions on how to set up applications and users for development
		 * purposes, see \ref GC and \ref enterprisesimulation.
		 */

		/// <summary>
		/// </summary>
		[Export ("authorize")]
		void Authorize ();

		/**< Connect to the Good Dynamics infrastructure, without specifying a delegate.
		 * Call this function to initiate Good Dynamics authorization processing without
		 * specifying a delegated event handler. This style of call should only be used
		 * after setting the <TT>delegate</TT> property directly.

		 * Calling this function is equivalent to calling the <TT>Authorize(GDiOSDelegate delegate)</TT>
		 * function, above, after having set the <TT>Delegate</TT> property directly.
		 * 
		 * See  \link GDiOS.Authorize Authorize (GDiOS)\endlink for details.
		 */

		/// <summary>
		/// </summary>
		[Export ("programmaticAuthorize:withAccessKey:")]
		void ProgrammaticAuthorize (string userId, string accessKey);

		/**< Initiate programmatic activation.
		 * Call this function to
		 * initiate programmatic activation.
		 * Programmatic activation can only be utilized by applications
		 * that can obtain credentials for enterprise activation on behalf of the end
		 * user. The credentials are passed as parameters to this function.
		 *
		 * Calling this function also initiates authorization processing, as if the
		 *  \link GDiOS.Authorize: Authorize (GDiOS)\endlink function had
		 * been called.
		 *
		 * Only call this function after checking that the application is not
		 * already activated, by
		 * accessing the \link GDiOS.ActivationComplete ActivationComplete (GDiOS)\endlink property.
		 * 
		 * \param userID <TT>string</TT> containing the user ID, an enterprise activation
		 *               credential.
		 * \param accessKey <TT>string</TT> containing the access key, an enterprise
		 *                  activation credential.
		 */

		/// <summary>
		/// </summary>
		[Export ("getApplicationConfig")]
		NSDictionary GetApplicationConfig ();

		/**< Get application configuration and other settings from the enterprise.
		 * This function returns a collection of application configuration
		 * and other settings. The settings will have been made in the enterprise Good
		 * Control (GC) server, and retrieved by the Good Dynamics Runtime.
		 *
		 * Retrieval of configuration settings may happen during authorization
		 * processing, or whenever settings are changed on the GC. When changed settings
		 * have been retrieved by the runtime, a <TT>GDAppEventRemoteSettingsUpdate</TT>
		 * event will be dispatched to the application. See the
		 * \link GDAppEvent GDAppEvent\endlink class reference for details.
		 *
		 * Note that retrieval is <EM>not </EM>triggered by calling this function.
		 *
		 * \return <TT>NSDictionary</TT>
		 * object containing configuration values. Use the <TT>GDAppConfigKey</TT>
		 * constant strings as keys. Any of the following configuration settings may be
		 * present:<TABLE
		 *     ><TR
		 *         ><TH>Key Constant</TH
		 *         ><TH>Setting</TH
		 *         ><TH>Type</TH
		 *
		 *     ></TR><TR><TD
		 *         ><TT>GDAppConfigKeyServers</TT></TD
		 *     ><TD
		 *         >Application server configuration.\n
		 *         A number of servers can be configured for an application. This
		 *         configuration is entered in the GC console, in the application
		 *         management user interface.\n
		 *         See the \link GDAppServer
		 *         GDAppServer class reference\endlink for documentation of the details
		 *         that are returned for each configured server.</TD
		 *     ><TD
		 *         ><TT>NSArray</TT> of
		 *         <TT>GDAppServer</TT></TD
		 *
		 *     ></TR><TR><TD
		 *         ><TT>GDAppConfigKeyHost</TT> (deprecated&nbsp;*)</TD
		 *     ><TD
		 *         >Application server address.\n
		 *         An application server address can be entered in the GC console,
		 *         in the application management user interface.</TD
		 *     ><TD><TT>NSString</TT></TD
		 *
		 *     ></TR><TR><TD
		 *         ><TT>GDAppConfigKeyPort</TT> (deprecated&nbsp;*)</TD
		 *     ><TD
		 *         >Application server port number.\n
		 *         An application port number can also be entered in the GC console,
		 *         in the application management user interface.</TD
		 *     ><TD
		 *         ><TT>NSNumber</TT></TD
		 *
		 *     ></TR><TR><TD
		 *         ><TT>GDAppConfigKeyConfig</TT></TD
		 *     ><TD
		 *         >Application-specific configuration data.\n
		 *         As well as the application server details, above, a free
		 *         text can also be entered in the GC console.
		 *         Whatever was entered is passed through by the runtime and made
		 *         available to the application code here.</TD
		 *     ><TD><TT>NSString</TT></TD
		 *
		 *     ></TR><TR><TD
		 *         ><TT>GDAppConfigKeyCopyPasteOn</TT></TD
		 *     ><TD
		 *         >Data Leakage policy indicator.\n
		 *         1 means that enterprise security
		 *         policies require that the end user must be prevented from taking any
		 *         action that is classified as data loss or data leakage in the Good
		 *         Dynamics Security Compliance Requirements document.\n
		 *         0 means that the above policy is <EM
		 *         >not</EM> in effect, so the user is permitted to take those
		 *         actions.</TD
		 *     ><TD
		 *         ><TT>NSNumber</TT></TD
		 *
		 *     ></TR><TR><TD
		 *         ><TT>GDAppConfigKeyDetailedLogsOn</TT></TD
		 *     ><TD
		 *         >Logging level.\n
		 *         0 means that the logging level is
		 *         low, and only minimal logs should be written.\n
		 *         1 means that the logging level is
		 *         high, and detailed logs should be written. Detailed logs facilitate
		 *         debugging of runtime issues.\n
		 *         The Good Dynamics Runtime will automatically adjust its logging
		 *         according to the configured setting.
		 *         The setting is present in the API so that the application can adjust
		 *         its logging consistently with the runtime.</TD
		 *     ><TD
		 *         ><TT>NSNumber</TT></TD
		 *
		 *     ></TR><TR><TD
		 *         ><TT>GDAppConfigKeyUserId</TT></TD
		 *     ><TD
		 *         >Enterprise user identifier, typically email address.\n
		 *         An enterprise identifier for the end user is one of the credentials
		 *         required for initial activation of a GD application. This could be
		 *         the email address entered in the GD activation user interface when
		 *         the application was run for the first time, for example.\n
		 *         The value obtained for this setting will initially be the enterprise
		 *         email address, or other identifier, used for activation. If the
		 *         enterprise email address of the end user changes after activation
		 *         then the value of this setting will also change, next time it is
		 *         obtained.</TD
		 *     ><TD><TT>NSString</TT></TD
		 *
		 *     ></TR
		 * ></TABLE
		 * >* The <TT>GDAppConfigKeyHost</TT> and <TT>GDAppConfigKeyPort</TT> keys are
		 * deprecated and will be removed in a future release. The recommended way to
		 * access application server configuration is to use the
		 * <TT>GDAppConfigKeyServers</TT> value, which returns a list. For backward
		 * compatibility, the deprecated values will be populated with details for the
		 * first server of the highest priority.
		 *
		 * \par Data Leakage Policy Enforcement
		 * Security policies other than the Data Leakage policy (DLP) mentioned in the
		 * above are enforced by the Good Dynamics Runtime, without reference to the
		 * application. DLP must generally be enforced by the application, with some
		 * exceptions.\n
		 * If DLP is switched on, the Good Dynamics Runtime will:<UL
		 * ><LI
		 *     >Secure general cut-copy-paste operations by the user.</LI
		 * ><LI
		 *     >Secure data written to the general pasteboard by content-rendering
		 *     <TT>UIKit</TT> components.</LI
		 * ></UL
		 * >Secure cut-copy-paste operations allow the user to copy and move data via
		 * the clipboard only:
		 * - Within one Good Dynamics application.
		 * - Between Good Dynamics applications that were activated for the same end
		 *   user from the same enterprise Good Control server.
		 * .
		 * Other aspects of data leakage must be enforced by the application.\n
		 * Note that pasteboards other than the general pasteboard, i.e.
		 * programmatically created <TT>UIPasteboard</TT> instances, are never secured
		 * by the Good Dynamics Runtime.\n
		 * 
		 * \par Application Server Selection
		 * The <TT>GDAppConfigKeyServers</TT> value will contain a list of the servers
		 * that have been configured for the application in the GC console. In the case
		 * that more than one server has been configured, the recommended selection
		 * algorithm is as follows:
		 * -# For each priority value in the list, starting with the highest:
		 * -# Select a server that has that priority, at random.
		 * -# Attempt to connect to the server.
		 * -# If connection succeeds, use that server.
		 * -# If connection fails, try another server at the same priority, at random.
		 * -# If there are no more untried servers at that priority, try the servers at
		 *    the next lower priority.
		 * .
		 * 
		 * \see \ref GC
		 * \see <A
		 *     HREF="http://iosapi.xamarin.com/?link=T%3aFoundation.NSDictionary"
		 *     target="_blank"
		 * >NSDictionary class reference</A> in the Xamarin.iOS Developer Documentation on xamarin.com
		 * \see The GD-Secure compliance document.
		 */

		/// <summary>
		/// </summary>
		[Export ("getApplicationPolicy")]
		NSDictionary GetApplicationPolicy ();

		/**< Get application-specific policy settings from the Good Control server, as a
		 * collection.
		 * 
		 * This function returns a collection of application-specific policy
		 * settings.
		 * The settings will have been entered in the Good Control (GC) console, and
		 * retrieved by the Good Dynamics Runtime.
		 *
		 * For more documentation of the feature and how application policies are
		 * defined, see the \ref AppPolicies documentation.
		 * 
		 * Retrieval of policy settings may happen during authorization
		 * processing, or whenever settings are changed on the GC.
		 * When changed settings have been retrieved by the runtime, a
		 * <TT>GDAppEventPolicyUpdate</TT> event will be dispatched to the
		 * application.
		 * See also \link GDAppEvent GDAppEvent\endlink.
		 *
		 * Note that retrieval is <EM>not </EM>triggered by calling this function.
		 * 
		 * \return <TT>NSDictionary</TT>
		 * containing policy settings.
		 * The keys will be the same as the settings identifiers in the policy
		 * definition. The values will be the particular values that apply to the end
		 * user. The value types are mapped from the definition as follows:<TABLE
		 *  ><TR
		 *      ><TH>Definition Type</TH><TH>Dictionary Value Type</TH
		 *
		 *  ></TR><TR><TD>null</TD><TD><TT>nil</TT></TD
		 *
		 *  ></TR><TR><TD
		 *      >boolean</TD><TD><TT>NSNumber</TT></TD
		 *
		 *  ></TR><TR><TD
		 *      >double</TD><TD><TT>NSNumber</TT></TD
		 *
		 *  ></TR><TR><TD
		 *      >int</TD><TD><TT>NSNumber</TT></TD
		 *
		 *  ></TR><TR><TD
		 *      >object</TD><TD><TT
		 *          >NSDictionary</TT></TD
		 *
		 *  ></TR><TR><TD
		 *      >array</TD><TD><TT>NSArray</TT></TD
		 *
		 *  ></TR><TR><TD>string</TD><TD><TT>NSString</TT></TD
		 *
		 * ></TR
		 * ></TABLE>
		 * \see \link GDiOS.GetApplicationPolicyString (GDiOS)\endlink
		 */
		
		/// <summary>
		/// </summary>
		[Export ("getApplicationPolicyString")]
		string GetApplicationPolicyString ();

		/**< Get application-specific policy settings from the Good Control server, as
		* JSON.
		*  
		* This function returns application-specific policy settings in a JSON
		* string.
		* The settings will have been entered in the Good Control (GC) console, and
		* retrieved by the Good Dynamics Runtime.
		* 
		* For more documentation of the feature and how application policies are
		* defined, see the \ref AppPolicies documentation.
		*
		* Retrieval of policy settings may happen during authorization
		* processing, or whenever settings are changed on the GC.
		* When changed settings have been retrieved by the runtime, a
		* <TT>GDAppEventPolicyUpdate</TT> event will be dispatched to the
		* application.
		* See also \link GDAppEvent GDAppEvent\endlink.
		*
		* Note that retrieval is <EM>not </EM>triggered by calling this function.
		* 
		* \return <TT>string</TT> containing policy settings in a JSON string.
		* The string will evaluate to an object with an attribute for each
		* application-specific setting. The names of the attributes will be the same as
		* the settings identifiers in the policy definition.
		* The attribute values will be the particular values that apply to the end user.
		* \see \link GDiOS.GetApplicationPolicy GetApplicationPolicy (GDiOS)\endlink
		*/

		/// <summary>
		/// </summary>
		[Export ("getServiceProviders")]
		NSArray GetServiceProviders ();

		/**< Get providers of shared services.
		 * This function returns a list of all available providers of
		 * shared services. The list contains both application-based and server-based
		 * service providers.
		 *
		 * The returned list is based on the GD Application Identifier (GD App ID)
		 * configuration in the enterprise Good Control (GC) server and in the central
		 * GD Catalog. The list includes an entry for each GD App ID and version pair
		 * that meets all the following conditions:
		 * - The GD App ID and version is registered as the provider of one or more
		 *   shared services. Registrations are stored in the enterprise GC or in the
		 *   GD Catalog.
		 * - The end user of the current application is entitled to the GD App ID and
		 *   version. Entitlements are stored in the enterprise GC only.
		 * - For application-based service providers, the mobile application has been
		 *   installed and activated for the same end user, and on the same mobile
		 *   device, as the current application.
		 * .
		 * 
		 * The GD Catalog is a server within the GD infrastructure. Developers may
		 * register their GD applications as providers of one or more shared services.
		 * Registration of the services provided by a GD application can be carried out
		 * in the enterprise GC console user interface, or on the Good Developer Network website.
		 * Registrations are then stored in the GD Catalog. The creation of individual
		 * shared service definitions is also carried out in the enterprise GC or in the
		 * Good Developer Network website.
		 * 
		 * The GD Runtime retrieves the information used to generate the list of
		 * service providers from the GD Catalog, and from the enterprise GC server.
		 * Retrieval can take place when the application is authorized, or when another
		 * application activates on the same device, or when the configuration is
		 * changed in the enterprise GC. Note that retrieval is <EM>not </EM>triggered
		 * by calling this function.
		 * 
		 * For each GD App ID and version that satisfies the conditions, this
		 * function returns a \link GDServiceProvider GDServiceProvider\endlink object.
		 * 
		 * The returned details for an application-based provider can be used to send a
		 * service request to the service provider using Good Inter-Container
		 * Communication. See the   \link GDService GDService class reference\endlink for details of the API. See
		 * under Service Provider Requirements on that page for information on service
		 * provider registration, which is a prerequisite for an application to be on
		 * the list returned by this function.
		 *
		 * The returned details for a server-based provider can be used to establish
		 * HTTP or TCP socket communications with a server instance.
		 * 
		 * \return <TT>NSArray</TT> of <TT>GDServiceProvider</TT
		 *         > objects containing the list of available service providers. The
		 *         order of objects in the list is not specified.
		 * 
		 * A single service could have multiple providers. A single provider could
		 * provide multiple services, and multiple versions of services.
		 *
		 * When changed details have been retrieved by the runtime, a
		 * <TT>GDAppEventServicesUpdate</TT> event will be dispatched to the
		 * application. See also \link GDAppEvent GDAppEvent\endlink.
		 * 
		 * <H4>Icon images</H4>
		 * The objects returned by this function can include icon images for service
		 * provider applications. Utilization of icon images is optional. If the
		 * application does utilize icon images, then make a setting in the
		 * application's Info.plist file* as follows:
		 * - Key: <TT>GDFetchResources</TT>
		 * - Type: <TT>Boolean</TT>
		 * - Value: <TT>YES</TT>
		 * .
		 * (*In case there are multiple Info.plist files, check that the correct one has
		 * been edited by opening the Info tab of the application target being built.
		 * The setting just made should appear there.)
		 * 
		 * If the setting is missing or the value is <TT>NO</TT>, this indicates that
		 * the application does not utilize icon images.
		 *
		 * The data for icon images would be retrieved by the GD Runtime, from a GD
		 * Catalog service. Good Technology may switch off the icon image service at the
		 * GD Catalog from time to time, for operational reasons. If the icon image
		 * service is switched off then all icon images in the returned objects will be
		 * <TT>null</TT>.
		 */

		/// <summary>
		/// </summary>
		[Export ("showPreferenceUI:")]
		bool ShowPreferenceUI ([NullAllowed]UIViewController baseViewController);

		/**< Open the Good Dynamics preferences user interface.
		 * Call this function to show the Good Dynamics (GD) preferences user
		 * interface (UI).
		 * This is the UI in which the end user sets any options that are applied by
		 * the runtime directly, without reference to the application. This includes,
		 * for example, changing their security password.
		 *
		 * This function enables the GD preferences UI to be included in the
		 * application's own user interface.
		 *
		 * \param baseViewController Reference to the navigation controller within which
		 * the preferences UI is to open as a view controller.\n
		 * Pass a null pointer to open the GD preferences UI as a modal view
		 * controller, for example when no navigation controller is available.
		 *
		 * \return <TT>true</TT> if the GD preferences UI opened OK.
		 * \return <TT>false</TT> if the preferences UI was already open, or if authorization
		 *                   is delegated to another application.
		 */

		/// <summary>
		/// </summary>
		[Export ("getServiceProvidersFor:andVersion:andType:")]
		NSArray GetServiceProviders (string serviceId, string version, GDServiceProviderType type);

		/**< Discover providers of a specific shared service.
		 * This function returns a list of the available providers of a
		 * specified service.
		 *
		 * The returned list is based on the GD Application Identifier (GD App ID)
		 * configuration in the enterprise Good Control (GC) server and in the central
		 * GD Catalog. The list includes an entry for each GD App ID and version pair
		 * that meets all the following conditions:
		 * - The GD App ID and version pair would be returned by the
		 *   \link GDiOS.GetServiceProviders() GetServiceProviders (GDiOS)\endlink function, see above.
		 * - The pair has been registered as a provider of the specified service.
		 * - The pair has been registered as a provider of the service version, if
		 *   specified.
		 * - The pair has been registered as a provider of the specified service type.
		 * .
		 * 
		 * \param serviceId <TT>string</TT> specifying the ID of the required service.
		 *
		 * \param version <TT>string</TT> specifying the required version of the service, or
		 *                <TT>null</TT> to leave unspecified.
		 *
		 * \param serviceProviderType <TT>GDServiceProviderType</TT> value specifying
		 *                            the required type of service.
		 * 
		 * \return <TT>NSArray</TT> of <TT>GDServiceProvider</TT
		 *         > objects containing the list of available service providers. The
		 *         order of objects in the list is not specified.
		 *
		 * See also the note on Icon images in the <TT>GetServiceProviders()</TT>
		 * function documentation, above.
		 */

		/// <summary>
		/// </summary>
		[Field ("MTGDAppConfigKeyServers", "__Internal")]
		NSString GDAppConfigKeyServers { get; }

		/**< Constant key value for application server configuration.\ See under
		 * \ref GDiOS.GetApplicationConfig.
		 */

		/// <summary>
		/// </summary>
		[Field ("MTGDAppConfigKeyConfig", "__Internal")]
		NSString GDAppConfigKeyConfig { get; }

		/**< Constant key value for application-specific configuration data.\ See under
		 * \ref GDiOS.GetApplicationConfig.
		 */

		/// <summary>
		/// </summary>
		[Field ("MTGDAppConfigKeyCopyPasteOn", "__Internal")]
		NSString GDAppConfigKeyCopyPasteOn { get; }

		/**< Constant key value for the Data Leakage security policy indicator.\ See
 		* under \ref GDiOS.GetApplicationConfig.
 		*/

		/// <summary>
		/// </summary>
		[Field ("MTGDAppConfigKeyDetailedLogsOn", "__Internal")]
		NSString GDAppConfigKeyDetailedLogsOn { get; }

		/**< Constant key value for enabling and disabling detailed diagnostic
		 * logging.\ See under \ref GDiOS.GetApplicationConfig.
		 */

		/// <summary>
		/// </summary>
		[Field ("MTGDAppConfigKeyUserId", "__Internal")]
		NSString GDAppConfigKeyUserId { get; }
		/**< Constant key value for the user's enterprise email address.\ See under
		 * \ref GDiOS.GetApplicationConfig.
		 */

	}

	/// <summary>
	/// </summary>
	/** Handler for events dispatched from the Good Dynamics Runtime,
	 * including authorization events.
	 * Errors and state changes that occur when using \link GDiOS\endlink
	 * are handled by creating a class that implements this protocol.
	 */
	[Protocol, BaseType (typeof(UIApplicationDelegate)), Model]
	public interface GDiOSDelegate
	{
		/// <summary>
		/// </summary>
		[Abstract, Export ("handleEvent:")]
		void HandleEvent (GDAppEvent anEvent);
		/**< Callback for all events.
		 * The callback is invoked whenever a Good Dynamics Runtime object event occurs.
		 * Runtime object events include authorization results, see  \link GDiOS.Authorize: Authorize (GDiOS)\endlink for
		 * details.
		 *
		 * \param anEvent GDAppEvent populated with details of the event.
		 */
	}

	/// <summary>
	/// </summary>
	/** Delegate for handling GDSocket state transitions and received data.
	 * Errors and state changes that occur when using GDSocket
	 * are handled by creating a class that implements this protocol.
	 * The callback for handling received data is also part of this protocol.
	 */
	[Protocol, BaseType (typeof(NSObject)), Model]
	public interface GDSocketDelegate
	{

		/// <summary>
		/// </summary>
		[Export ("onOpen:")]
		void OnOpen (GDSocket socket);

		/**< Socket opened callback.
		 * This callback is invoked when the delegating socket opens for communication
		 * with the remote server, see GDSocket::connect.
		 *
		 * Invocation of this callback also notifies the application on the device
		 * that data can be written to the socket, using \ref GDSocket::write.
		 *
		 * \param socket <TT>GDSocket</TT> object that issued the callback.
		 */

		/// <summary>
		/// </summary>
		[Export ("onRead:")]
		void  OnRead (GDSocket socket);

		/**< Socket data received callback.
		 * This callback is invoked when data has been received from the remote server,
		 * and is ready to read.
		 * The function that is invoked should consume the received data.
		 *
		 * The received data will be available in the delegating socket's
		 * \ref GDSocket.ReadStream "ReadStream" buffer, which
		 * can be accessed using the GDDirectByteBuffer interface.
		 *
		 * \param socket <TT>GDSocket</TT> object that issued the callback.
		 */

		/// <summary>
		/// </summary>
		[Export ("onClose:")]
		void  OnClose (GDSocket socket);

		/**< Socket closed callback.
		 * This callback is invoked when the delegating socket is closed. This means
		 * closed by the remote end, or by the device end (see GDSocket::disconnect).
		 *
		 * Invocation of this callback notifies the application on the device
		 * that:
		 * - The delegating socket cannot now be used for writing
		 * - No more data will be received on the delegating socket
		 *
		 * \param socket <TT>GDSocket</TT> object that issued the callback.
		 */

		/// <summary>
		/// </summary>
		[Export ("onErr:inSocket:")]
		void InSocket (int error, GDSocket socket);
		/**< Socket error callback.
		 * This callback is invoked when a socket error occurs on the delegating socket.
		 *
		 * \param error \ref GDSocketErrorType value for the socket error encountered.
		 * \param socket <TT>GDSocket</TT> object that issued the callback.
		 */
	}

	/// <summary>
	/// </summary>
	/** Buffer for accessing GDSocket and GDHttpRequest data.
	 * The GD Direct Byte Buffer API is used to access certain in-memory byte
	 * buffers within the Good Dynamics secure communications features.
	 * GD Socket uses in-memory byte buffers for reading and writing data.
	 * GD HTTP Request uses in-memory byte buffers for reading response data.
	 */
	[BaseType (typeof(NSObject))]
	public interface GDDirectByteBuffer
	{
		
		/// <summary>
		/// </summary>
		[Export ("write:")]
		void Write (IntPtr data);

		/**< Append null-terminated string to GD Direct Byte buffer.
		 * Call this function to append data to the buffer. This would be used
		 * on a GD socket's outbound buffer.
		 *
		 * Calling this function does not cause data to be sent. See GDSocket::write.
		 * The buffer allocates itself more memory as necessary to accomodate
		 * unsent data.
		 *
		 * \param data Null-terminated string, marshalled as an IntPtr, containing the data to be appended.
		 * The terminating null is not written to the buffer.
		 */

		/// <summary>
		/// </summary>
		[Export ("writeData:")]
		void WriteData (NSData data);

		/**< Append NSData data to GD Direct Byte buffer.
		 * Call this function to append data to the buffer. This would be used
		 * on a GD socket's outbound buffer.
		 *
		 * Calling this function does not cause data to be sent. See GDSocket::write.
		 * The buffer allocates itself more memory as necessary to accomodate
		 * unsent data.
		 *
		 * \param data <TT>NSData</TT> object containing the data to be appended.
		 */

		/// <summary>
		/// </summary>
		[Export ("write:withLength:")]
		void Write (IntPtr data, int length);

		/**< Append length bytes of data to GD Direct Byte buffer.
		 * Call this function to append data to the buffer. This would be used
		 * on a GD socket's outbound buffer.
		 *
		 * Calling this function does not cause data to be sent. See GDSocket::write.
		 * The buffer allocates itself more memory as necessary to accomodate
		 * unsent data.
		 *
		 * \param data Buffer containing the data to be appended.
		 * \param length Number of bytes to be written from the buffer.
		 */

		/// <summary>
		/// </summary>
		[Export ("bytesUnread")]
		int BytesUnread { get; }

		/**< Number of bytes available for reading from a GD Direct Byte buffer.
		 * This function returns the number of bytes available to
		 * be read from the buffer.
		 * \return Number of bytes available.
		 */

		/// <summary>
		/// </summary>
		[Export ("read:toMaxLength:")]
		int Read (IntPtr data, int maxLength);

		/**< Consume data from GD Direct Byte buffer into <TT>char</TT> buffer.
		 * Call this function to read and consume a specified amount of raw data
		 * from the buffer.
		 * This would be used on a GD Socket's inbound buffer, or on a GD HTTP
		 * Request's response data.
		 *
		 * This function would usually be called in a delegated event handler, see
		 * either \ref GDHttpRequestDelegate::onStatusChange: and
		 * \ref GDHttpRequest.GetReceiveBuffer, or \ref GDSocketDelegate.OnRead.
		 *
		 * Calling this function causes data to be written to a <TT>char</TT> buffer marshalled as an IntPtr
		 * supplied by the caller. The caller specifies the maximum amount of
		 * data to be written to the buffer, as a number of bytes.
		 * The function returns the number of bytes
		 * actually written. This will be the lesser of the specified maximum,
		 * and the amount of data available in the GD Direct Byte buffer.
		 * The data written to the caller's buffer is, in effect, deleted from
		 * the GD Direct Byte buffer, and will not be returned by future calls to
		 * any reading functions.
		 *
		 * \param data Pointer to a <TT>char</TT> buffer to which data is
		 * to be written.
		 * \param maxLength Maximum number of bytes to be written
		 * to the <TT>char</TT> buffer.
		 * \return Number of bytes actually written to the <TT>char</TT> buffer.
		 */

		/// <summary>
		/// </summary>
		[Export ("unreadDataAsString")]
		string UnreadDataAsString { get; }

		/**< Consume data from GD Direct Byte buffer into new <TT>NSString</TT> object.
		 * Call this function to create an <TT>string</TT> object, populated with
		 * data consumed from the buffer.
		 * This would be used on a GD Socket's inbound buffer, or on a GD HTTP
		 * Request's response data.
		 *
		 * This function would usually be called in a delegated event handler, see
		 * either \ref GDHttpRequestDelegate::onStatusChange: and
		 * \ref GDHttpRequest.GetReceiveBuffer, or \ref GDSocketDelegate.OnRead.
		 *
		 * Calling this function first causes a UTF-8 <TT>string</TT> object to be
		 * allocated, by the Good Dynamics Runtime. All available data from the buffer
		 * is then written into the new object. The data written is, in effect, deleted
		 * from the GD Direct Byte buffer, and will not be returned by future calls to
		 * any reading functions.
		 *
		 * \return New <TT>string</TT> object, populated with data consumed from the
		 * GD Direct Byte buffer.
		 */

		/// <summary>
		/// </summary>
		[Export ("unreadData")]
		NSMutableData UnreadData { get; }
		/**< Consume data from GD Direct Byte buffer into new <TT>NSData</TT> object.
		 * Call this function to create an <TT>NSData</TT> object, populated with
		 * data consumed from the buffer.
		 * This would be used on a GD Socket's inbound buffer, or on a GD HTTP
		 * Request's response data.
		 *
		 * This function would usually be called in a delegated event handler, see
		 * either \ref GDHttpRequestDelegate.OnStatusChange: and
		 * \ref GDHttpRequest.GetReceiveBuffer, or \ref GDSocketDelegate.OnRead.
		 *
		 * Calling this function first causes an <TT>NSData</TT> object to be allocated,
		 * by the Good Dynamics Runtime. All available data from the buffer is then
		 * written into the new object. The data written is, in effect, deleted from
		 * the GD Direct Byte buffer, and will not be returned by future calls to
		 * any reading functions.
		 *
		 * \return New <TT>NSData</TT> object, populated with data consumed from the
		 * GD Direct Byte buffer.
		 */
	}

	/// <summary>
	/// </summary>
	/* \page st02gdsocket GD Socket state transition diagram
	*  \image html "st02 GD Socket.png" "GD Socket state transition diagram" \image rtf "st02 GD Socket.png" "GD Socket state transition diagram"
	* \see GDSocket
	*/

	/** TCP sockets, supporting SSL/TLS and communication across the firewall.
	* 
	* The GD Socket API is for bi-directional data communications
	* between the mobile application on the device and an application server. The
	* application server can be on the Internet, or behind the enterprise firewall.
	* Secure Socket Layer and Transport Layer Security (SSL/TLS) are supported.
	* 
	* GD Socket functions cannot be called until Good Dynamics authorization
	* processing is complete.
	* 
	* 
	* GD Socket data communication does not go via the proxy specified in the
	* device's native settings, if any.
	* \see \link GDiOS\endlink, for Good Dynamics authorization
	* \see \ref threads
	* \see \ref background_execution
	* \see GDHttpRequest
	* \see <A HREF="https://community.good.com/docs/DOC-1061" target="_blank" >Good Dynamics Administrator and Developer Overview</A > for an introduction to Good Dynamics.
	*
	*
	* <H3>Overview</H3>
	* The GD Socket API is asynchronous and state-based.
	* The application attaches its own event-handler callbacks to the
	* GD Socket object. The callback functions are invoked when socket events
	* occur, or when the socket changes state. Which API functions can
	* be called by the application at any time also depend on the socket's state.
	*
	* Callbacks are attached through a delegate class.
	* The states in which each callback may be expected to be invoked are
	* detailed in the delegate class's documentation, see GDSocketDelegate.
	*
	* The availability of API functions, and what actions take place,
	* are detailed below, and summarized in the following table.
	* The table also summarizes which callbacks may expect to be invoked
	* in each state.
	* <TABLE>
	*     <TR><TH>State</TH><TH>Functions / Actions</TH><TH>Expected callbacks</TH
	*
	*     ></TR><TR><TD
	*         >Prepared</TD
	*     ><TD
	*         >Application can call <TT>connect</TT>: state becomes Connecting\n
	*         Application can call <TT>disableHostVerification</TT>:
	*         no state change\n
	*         Application can call <TT>disablePeerVerification</TT>:
	*         no state change</TD
	*     ><TD
	*         >None</TD
	*
	*     ></TR><TR><TD
	*         >Connecting</TD
	*     ><TD
	*         >Open socket connection to server</TD
	*     ><TD
	*         ><TT>onErr</TT>: no state change\n
	*         <TT>onOpen</TT>: new state is Open</TD
	*
	*     ></TR><TR><TD
	*         >Open</TD
	*     ><TD
	*         >Application can call <TT>disconnect</TT>: state becomes
	*         Disconnecting\n
	*         Application can call <TT>write</TT>: No state change</TD
	*     ><TD
	*         ><TT>onRead</TT>: no state change\n
	*         <TT>onErr</TT>: no state change\n
	*         <TT>onClose</TT>: new state is Disconnected</TD
	*
	*     ></TR><TR><TD
	*         >Disconnecting</TD
	*     ><TD
	*         >Close socket connection</TD
	*     ><TD
	*         ><TT>onRead</TT>: no state change\n
	*         <TT>onErr</TT>: no state change\n
	*         <TT>onClose</TT>: new state is Disconnected</TD
	*
	*     ></TR><TR><TD
	*         >Disconnected</TD
	*     ><TD
	*         >Application can call <TT>connect</TT>: state becomes Connecting</TD
	*     ><TD
	*         >None</TD
	*
	*     ></TR
	* ></TABLE
	* >The transitions in the above table are also shown in the
	* \ref st02gdsocket
	*
	* <H3>Sending and Receiving Data</H3>
	* Sending data through a GD Socket is a two-stage operation.
	* The first stage is to add the data to the socket's outbound buffer.
	* The socket's outbound buffer is represented by the
	* <TT>writestream</TT> property, and is
	* accessed using the GD Direct Byte Buffer API.
	* The second stage is to send the contents of the buffer
	* through the socket connection.
	* To send the buffer, call the <TT>write</TT> function.
	*
	* Reading data from a GD Socket is asynchronous.
	* When data is received at the device, the data is stored in the socket's
	* inbound buffer. The application is then notified
	* that data is available to read, by invocation of the
	* delegate <TT>onRead</TT> callback.
	* In the callback, the application consumes the received data from the
	* inbound buffer. The inbound buffer is represented by the
	* <TT>readStream</TT> property, and is
	* accessed using the GD Direct Byte Buffer API.
	*
	* <H3>SSL/TLS Security</H3>
	* The GD Socket API supports use of a Secure Socket Layer connection or
	* Transport Layer Security (SSL/TLS) to send and receive data.
	*
	* Using SSL/TLS requires that the remote end has a suitable certificate, and
	* that the certificate is valid. A number of checks for validity are made by
	* the Good Dynamics Runtime, some of which can be disabled by the application.
	*
	* The usual secure socket connection sequence would be as follows.
	* The application makes a first connection attempt. In the
	* first attempt, full certificate checking is enabled.
	* If a security error is encountered, this request will fail.
	* The application can then disable some checking, and make a second
	* connection attempt, to the same address as the first connection attempt.
	* With less rigorous checking, the second attempt may succeed where the
	* first failed.
	*
	* The relevant parts of the API are:
	* - Use of SSL/TLS is specified by including
	* <TT>andUseSSL:</TT>&nbsp;<TT>YES</TT> in the call to <TT>init</TT>
	* - Security errors are treated the same as connection failures.
	* - The member functions <TT>disableHostVerification</TT> and
	* <TT>disablePeerVerification</TT> are used to reduce the level
	* of security checking.
	* Setting <TT>disablePeerVerification</TT> implicitly
	* sets <TT>disableHostVerification</TT>.
	* .
	* 
	* <H4>Secure Protocol Selection</H4>
	* Establishing an SSL/TLS connection can involve negotiating and retrying, in
	* order to select a secure protocol that is supported by client and server. The
	* Good Dynamics (GD) Runtime handles client-side negotiation and retrying, when
	* the secure communication APIs are in use. By default, the GD Runtime does not
	* offer the TLSv1.1 or TLSv1.2 protocols for SSL/TLS connections with an
	* application server.
	*
	* These protocols can be enabled, as follows.
	* -# Add a new row to the application's Info.plist fi<TT></TT>le*:
	*     - Key: <TT>GDControlTLSVersions</TT>
	*     - Type: <TT>String</TT> (the default)
	*     .
	* -# Set the value to:
	*     - <TT>GDEnableTLS1.1</TT> to enable the TLSv1.1 protocol.
	*     - <TT>GDEnableTLS1.2</TT> to enable both TLSv1.1 and TLSv1.2 protocols.
	*     .
	*     Alternatively, the value can be an array containing one or both of the
	*     above strings as separate items.
	* .
	* (*In case there are multiple Info.plist files, check that the correct one has
	* been edited by opening the Info tab of the application target being built.
	* The setting just made should appear there.)
	* 
	* The setting only affects connections to application servers, not the
	* connection with the GD infrastructure itself. The protocols are disabled by
	* default because there are many installed web servers with which a connection
	* cannot be established after one of these protocols has been offered.
	*
	* <H3>Enterprise server connection notes</H3>
	* The GD secure communications APIs can be used to connect to servers that are
	* behind the enterprise firewall.
	* This applies to socket connections and HTTP requests.
	* Note the following when using this capability:
	*
	* The address of the application server to which connection is being made
	* must be registered in the enterprise's Good Control (GC) console.
	* The address could be registered as the application's server, or as an
	* additional server. See detailed instructions in the \ref GC and in the GC
	* console help files.
	*
	* Note. The application server configuration in the GC can
	* be obtained in the application code by using the
	* \link GDiOS::getApplicationConfig getApplicationConfig (GDiOS)\endlink function.
	*
	* The connection to the application server will be made through the Good
	* Dynamics proxy infrastructure.The status of the mobile application's
	* connection to the proxy infrastructure should therefore be checked before
	* attempting to open the socket, or send the HTTP request. The
	* \ref GDPushConnection::isConnected function can be used to check the status.
	* If there is no connection to the proxy infrastructure, this can be initiated
	* in the normal way. See under GDPushConnection.
	*/
	[BaseType (typeof(NSObject))]
	public interface GDSocket
	{

		/// <summary>
		/// </summary>
		[Export ("init:onPort:andUseSSL:")]
		IntPtr Constructor (IntPtr url, int port, bool ssl);

		/**< Constructor that prepares a new socket.
		 * Call this function when constructing a new GD Socket object. This
		 * function does not initiate data communication, compare \ref connect.
		 *
		 * \param url Null-terminated string containing the address of the server.
		 * Can be either an Internet Protocol address (IP address, for example
		 * <TT>"192.168.1.10"</TT>), or a fully qualified domain name
		 * (for example <TT>"www.example.com"</TT>).
		 *
		 * \param port Number of the server port to which the socket will connect.
		 *
		 * \param ssl <TT>false</TT> to use no security,
		 * <TT>true</TT> to use SSL/TLS security.
		 * \see SSL/TLS Security, above
		 */

		/// <summary>
		/// </summary>
		[Export ("disableHostVerification")]
		bool DisableHostVerification { get; }

		/**< Security option: Disable SSL/TLS host name verification.
		 * This function disables host name verification, when making an
		 * SSL/TLS connection. Host name verification is an SSL/TLS security option.
		 *
		 * \par Host Name Verification
		 * When negotiating an SSL/TLS connection, the server sends a certificate
		 * indicating its identity. The certificate includes a number of host names.
		 * By default, one of the host names in the certificate
		 * must match the host name in the URL being opened, or the connection fails.
		 * When host name verification is disabled, the connection succeeds regardless
		 * of whether there is a matching host name in the certificate.\n
		 * When enabled, the Good Dynamics Runtime checks server identity in a
		 * way that conforms with the relevant RFC.
		 * See under section 3.1 Server Identity, in <A
		 *     href="http://www.rfc-editor.org/rfc/rfc2818.txt"
		 *     target="_blank"
		 * >RFC 2818</A>.
		 *
		 * This function must be called before <TT>connect</TT>.
		 *
		 * Disabling host name verification does not disable authenticity verification,
		 * see \ref disablePeerVerification.
		 *
		 * \return <TT>true</TT> if the security option was successfully disabled.
		 * \return <TT>false</TT> if the security option could not be disabled.
		 *
		 * \see SSL/TLS Security, above
		 */

		/// <summary>
		/// </summary>
		[Export ("disablePeerVerification")]
		bool DisablePeerVerification { get; }

		/**< Security option: Disable SSL/TLS authenticity verification.
		 * This function disables certificate authenticity verification,
		 * when making an SSL/TLS connection.
		 * Authenticity verification is an SSL/TLS security option.
		 *
		 * \par Certificate Authenticity Verification
		 * When negotiating an SSL/TLS connection, the server sends a certificate
		 * indicating its identity.
		 * By default, the certificate must be verified as
		 * trustworthy, or the connection fails.
		 * In this context, trustworthiness derives from a chain of
		 * digital signatures, rooted in a certification authority.
		 * When authenticity verification is disabled, the connection succeeds
		 * regardless of the certificate's trustworthiness.\n
		 * When enabled, the Good Dynamics Runtime checks certificate
		 * trustworthiness using operating system services. See the
		 * <A HREF="http://developer.apple.com/library/ios/documentation/Security/Reference/certifkeytrustservices/" target="_blank"
		 * >Certificate, Key, and Trust Services Reference in the iOS Developer
		 * Library on apple.com</A>
		 *
		 * This function must be called before <TT>connect</TT>.
		 *
		 * Disabling authenticity verification implicitly disables host name verification.
		 *
		 * \return <TT>true</TT> if the security option was successfully disabled.
		 * \return <TT>false</TT> if the security option could not be disabled.
		 *
		 * \see SSL/TLS Security, above
		 */
		
		/// <summary>
		/// </summary>
		[Export ("connect")]
		void Connect ();

		/**< Connect the socket.
		 * Call this function to open the GD Socket connection.
		 *
		 * The connection attempt is asynchronous. If the attempt succeeds, the delegate
		 * \ref GDSocketDelegate::onOpen: "onOpen" callback is invoked.
		 */

		/// <summary>
		/// </summary>
		[Export ("write")]
		void Write ();

		/**< Send data from the writeStream buffer.
		 * Call this function to send data through the socket connection.
		 * The data must previously have been added to the socket's outbound
		 * buffer, represented by the \ref GDSocket.WriteStream "WriteStream"
		 * property.
		 */

		/// <summary>
		/// </summary>
		[Export ("disconnect")]
		void Disconnect ();

		/**< Terminate the socket connection.
		 * Call this function to terminate the GD Socket connection.
		 *
		 * Disconnection is asynchronous. When disconnection completes, the delegate
		 * \ref GDSocketDelegate.OnClose: "OnClose" callback is invoked.
		 */
		
		/// <summary>
		/// </summary>
		[Export ("delegate", ArgumentSemantic.Assign)]
		GDSocketDelegate Delegate { get; set; }

		/**< Delegated event-handling.
		 * The GD Socket object works asynchronously. When its state changes, or data is
		 * received, an event is generated by the Good Dynamics Runtime, and passed to a
		 * callback function in the application.
		 *
		 * Set this property to an instance of a class that contains the code for the
		 * required callback functions, i.e. a class that implements
		 * the GDSocketDelegate interface.
		 */

		/// <summary>
		/// </summary>
		[Export ("writeStream", ArgumentSemantic.Retain)]
		GDDirectByteBuffer WriteStream { get; set; }

		/**< Outbound buffer.
		 * This property represents the outbound buffer of the socket.
		 * Data to be sent through the socket is first written to this buffer,
		 * using the GDDirectByteBuffer API, then sent by calling \ref Write.
		 *
		 * The outbound buffer can be accessed whenever this property is not null.
		 */
		
		/// <summary>
		/// </summary>
		[Export ("readStream", ArgumentSemantic.Retain)]
		GDDirectByteBuffer ReadStream { get; set; }
		/**< Inbound buffer.
		 * This property represents the inbound buffer of the socket.
		 * When data is received through the socket, the following takes place:
		 * - The data is stored in the inbound buffer,
		 * - The delegate \ref GDSocketDelegate.OnRead: "OnRead" callback
		 * is invoked.
		 * .
		 * Received data should then be consumed from the buffer,
		 * using the GDDirectByteBuffer API.
		 *
		 * The inbound buffer can be accessed whenever this property is not null.
		 */

	}

	/// <summary>
	/// </summary>
	/** Delegate for handling GDHttpRequest state transitions.
	 * Errors and state changes that occur when using GDHttpRequest
	 * are handled by creating a class that implements this protocol.
	 */
	[Protocol, BaseType (typeof(NSObject)), Model]
	public interface GDHttpRequestDelegate
	{

		/// <summary>
		/// </summary>
		[Export ("onStatusChange:")]
		void  OnStatusChange (GDHttpRequest httpRequest);
		/**< Callback for all state changes.
		 * This callback is invoked whenever the delegating
		 * GDHttpRequest changes state, or when more response data is received.
		 *
		 * The function that is invoked should initially call
		 * \ref GDHttpRequest.GetState "GetState"
		 * to determine the ready state.
		 *
		 * Depending on the ready state, other member functions
		 * may then be called by the invoked function. See GDHttpRequest for details.
		 *
		 * \param httpRequest <TT>GDHttpRequest</TT> object that issued the
		 * callback.
		 */
	}

	/// <summary>
	/// </summary>
	/** \page st03gdhttprequest GD HTTP Request state transition diagram
	 *  \image html "st03 GD HTTP Request.png" "GD HTTP Request state transition diagram" \image rtf "st03 GD HTTP Request.png" "GD HTTP Request state transition diagram"
	 * \see GDHttpRequest
	 */

	/** Standards-based HTTP request, also supporting HTTPS and communication across
	*  the firewall.
	* The GD HTTP Request API is for sending Hypertext Transfer Protocol (HTTP)
	* requests, such as GET and POST, from the device to an application server.
	* The application server can be on the Internet, or behind the enterprise
	* firewall.
	* The GD HTTP Request API is based on the XML Http Request (XHR) standard.
	* HTTPS security is supported.
	*
	* GD HTTP Request functions cannot be called until Good Dynamics authorization
	* processing is complete.
	*
	* <B>Note that synchronous request calls should not be made from the main application thread.</B>
	*
	* \see GDiOS, for Good Dynamics authorization
	* \see <A HREF="https://community.good.com/docs/DOC-1061" target="_blank" >Good Dynamics Administrator and Developer Overview</A > for an introduction to Good Dynamics.
	* \see \ref threads
	* \see \ref background_execution
	* \see GDSocket
	* \see <A href="http://www.w3.org/TR/XMLHttpRequest/"
	* target="_blank" >XML HTTP Request (XHR) specification on w3.org</A>
	* \see \ref GDURLLoadingSystem for an alternative approach
	*
	* <H3>Overview</H3>
	* The GD HTTP Request API is state-based.
	* The availability of API functions to
	* be called by the application at any given time depend on the request's state.
	*
	* Requests can be processed synchronously or asynchronously, at the option
	* of the application.
	* For asychronous operation, the application attaches its own event-handler
	* callback to the
	* GD HTTP Request object. The callback function is invoked when events
	* occur, or when the request changes state.
	*
	* The callback is attached through a delegate class.
	* Invocation of the callback is
	* detailed in the delegate class's documentation, see GDHttpRequestDelegate.
	*
	* The availability of API functions, and what actions take place,
	* are detailed below and summarized in the following table. (States in
	* all-capitals are standard XHR ready states.)<TABLE
	*     ><TR><TH>Ready State</TH><TH>Functions / Actions</TH
	*     ></TR><TR><TD
	*         >UNSENT</TD
	*     ><TD
	*         >The application can call <TT>open</TT>: state becomes OPENED\n
	*
	*         The application can also call any of the following <EM
	*         >pre-send </EM>functions:\n
	*         <TT>disableHostVerification</TT>,\n
	*         <TT>disablePeerVerification</TT>,\n
	*         <TT>disableFollowLocation</TT>,\n
	*         <TT>disableCookieHandling</TT>,\n
	*         <TT>clearCookies</TT> (deprecated),\n
	*         <TT>enableHttpProxy</TT>,\n
	*         <TT>disableHttpProxy</TT>\n
	*         Calling a pre-send function does not cause a state change.
	*         The action of a pre-send function will take effect when the request
	*         is sent.</TD
	*     ></TR><TR><TD
	*         >OPENED</TD
	*     ><TD
	*         >The application can call <TT>send</TT>, <TT>sendData</TT> or
	*         <TT>sendWithFile</TT>: state becomes Sending\n
	*
	*         The application can also call any of the following, which do not
	*         cause a state change:\n
	*         Any pre-send function that can be called in the UNSENT state,\n
	*         <TT>setRequestHeader</TT>,\n
	*         <TT>setPostValue</TT>,\n
	*         <TT>clearPostValues</TT></TD
	*     ></TR><TR><TD
	*         >SENT</TD
	*     ><TD
	*         >The request has been sent to the server\n
	*
	*         If a response is received, state becomes HEADERS_RECEIVED\n
	*
	*         If an error occurs, state becomes DONE</TD
	*     ></TR><TR><TD
	*         >HEADERS_RECEIVED</TD
	*     ><TD
	*         >All the headers have been received
	*
	*         The application can call the following, which do not cause a state
	*         change:\n
	*         <TT>getResponseHeader</TT>,\n
	*         <TT>getAllResponseHeaders</TT>,\n
	*         <TT>getStatus</TT>,\n
	*         <TT>getStatusText</TT>\n
	*
	*         When the first response data is received, state becomes LOADING</TD
	*     ></TR><TR><TD
	*         >LOADING</TD
	*     ><TD
	*         >The body is being received\n
	*
	*         The application can call the following, which do not cause a state
	*         change:\n
	*         <TT>getResponseHeader</TT>,\n
	*         <TT>getAllResponseHeaders</TT>,\n
	*         <TT>getStatus</TT>,\n
	*         <TT>getStatusText</TT>,\n
	*         <TT>getReceiveBuffer</TT>\n
	*
	*         Note: <TT>getReceiveBuffer</TT> is used to access the body of the
	*         HTTP response
	*
	*         When the last response data is received, state becomes DONE</TD
	*     ></TR><TR><TD
	*         >DONE</TD
	*     ><TD
	*         >The complete body has been received or an error has occured
	*
	*         The application can call the same functions as when in the UNSENT state\n
	*
	*         The application can also call the following, which do not cause a state
	*         change:\n
	*         <TT>getResponseHeader</TT>,\n
	*         <TT>getAllResponseHeaders</TT>,\n
	*         <TT>getStatus</TT>,\n
	*         <TT>getStatusText</TT>,\n
	*         <TT>getReceiveBuffer</TT></TD
	*     ></TR
	* ></TABLE
	* >The transitions in the above table are also shown in the
	* \ref st03gdhttprequest
	*
	* <H3>XHR differences</H3>
	* Differences between the GD HTTP Request API and the XmlHttpRequest
	* standard are detailed below, and summarized in the following
	* table:<TABLE
	*     ><TR><TH>XmlHttpRequest</TH><TH>GD HTTP Request</TH
	*     ></TR><TR><TD
	*         >readyState attribute</TD
	*     ><TD
	*         ><TT>getState</TT> function</TD
	*     ></TR><TR><TD
	*         >responseText and responseXML attributes,\n
	*         which provide all data received so far.</TD
	*     ><TD
	*         ><TT>getReceiveBuffer</TT> function,\n
	*         which provides data received since last called</TD
	*     ></TR><TR><TD
	*         >status attribute</TD
	*     ><TD
	*         ><TT>getStatus</TT> function</TD
	*     ></TR><TR><TD
	*         >statusText attribute</TD
	*     ><TD
	*         ><TT>getStatusText</TT> function</TD
	*     ></TR
	* ></TABLE>
	* <H3>Enterprise server connection notes</H3>
	* The GD secure communications APIs can be used to connect to servers that are
	* behind the enterprise firewall.
	* This applies to socket connections and HTTP requests.
	* Note the following when using this capability:
	*
	* The address of the application server to which connection is being made
	* must be registered in the enterprise's Good Control (GC) console.
	* The address could be registered as the application's server, or as an
	* additional server. See detailed instructions in the \ref GC and in the GC
	* console help files.
	*
	* Note. The application server configuration in the GC can
	* be obtained in the application code by using the
	* \link GDiOS::getApplicationConfig getApplicationConfig (GDiOS)\endlink function.
	*
	* The connection to the application server will be made through the Good
	* Dynamics proxy infrastructure.The status of the mobile application's
	* connection to the proxy infrastructure should therefore be checked before
	* attempting to open the socket, or send the HTTP request. The
	* \ref GDPushConnection::isConnected function can be used to check the status.
	* If there is no connection to the proxy infrastructure, this can be initiated
	* in the normal way. See under GDPushConnection.
	* 
	<H3>HTTPS Security</H3>
	* Good Dynamics secure communications support HTTPS, using a
	* Secure Socket Layer connection or Transport Layer Security (SSL/TLS)
	* to send the HTTP request and receive the response.
	*
	* Using SSL/TLS requires that the remote end has a suitable certificate,
	* and that the certificate is valid. A number of checks for validity are
	* madeby the Good Dynamics Runtime, some of which can be disabled
	* by the application.
	*
	* The usual HTTPS request sequence would be as follows.
	* The application makes a first attempt to send the HTTPS request. In the
	* first attempt, full checking is enabled.
	* If a security error is encountered, this request will fail.
	* The application can then disable some checking, and attempt to send
	* a second request to the same address as the first request. With less
	* rigorous checking, the second attempt may succeed where the first failed.
	*
	* The relevant parts of the API are:
	* - Use of HTTPS is specified by addressing the request
	* to a URL with "https" as its scheme, as in "https://www.example.com".
	* - Security errors are treated the same as connection failures. The
	* <TT>getStatusText</TT> return value will begin with <TT>"SSL"</TT>.
	* - The functions <TT>disableHostVerification</TT> and
	* <TT>disablePeerVerification</TT> are used to reduce the level
	* of security checking.
	* Setting <TT>disablePeerVerification</TT> implicitly
	* sets <TT>disableHostVerification</TT>.
	* .
	* 
	* <H4>Secure Protocol Selection</H4>
	* Establishing an SSL/TLS connection can involve negotiating and retrying, in
	* order to select a secure protocol that is supported by client and server. The
	* Good Dynamics (GD) Runtime handles client-side negotiation and retrying, when
	* the secure communication APIs are in use. By default, the GD Runtime does not
	* offer the TLSv1.1 or TLSv1.2 protocols for SSL/TLS connections with an
	* application server.
	*
	* These protocols can be enabled, as follows.
	* -# Add a new row to the application's Info.plist fi<TT></TT>le*:
	*     - Key: <TT>GDControlTLSVersions</TT>
	*     - Type: <TT>String</TT> (the default)
	*     .
	* -# Set the value to:
	*     - <TT>GDEnableTLS1.1</TT> to enable the TLSv1.1 protocol.
	*     - <TT>GDEnableTLS1.2</TT> to enable both TLSv1.1 and TLSv1.2 protocols.
	*     .
	*     Alternatively, the value can be an array containing one or both of the
	*     above strings as separate items.
	* .
	* (*In case there are multiple Info.plist files, check that the correct one has
	* been edited by opening the Info tab of the application target being built.
	* The setting just made should appear there.)
	* 
	* The setting only affects connections to application servers, not the
	* connection with the GD infrastructure itself. The protocols are disabled by
	* default because there are many installed web servers with which a connection
	* cannot be established after one of these protocols has been offered.
	* 
	<H3>HTTP proxy support</H3>
	* HTTP and HTTPS requests can be relayed by an HTTP or HTTPS proxy that resides
	* on the Internet or behind the enterprise firewall.
	* Authentication with the proxy is supported.
	*
	* See the \link
	* GDHttpRequest.EnableHttpProxy
	* EnableHttpProxy\endlink and \link
	* GDHttpRequest.DisableHttpProxy DisableHttpProxy\endlink function
	* references for details.
	*
	* When making HTTPS requests through an HTTP proxy, SSL/TLS certificate
	* verification must be disabled.
	* Certificate verification while using an HTTP proxy is not supported.
	* See under HTTPS Security, above.
	* Good Dynamics HTTP data communication does not go via the proxy specified in the
	* device's native settings, if any.
	* 
	* <H3>HTTP authentication</H3>
	* The Good Dynamics (GD) Runtime supports the following mechanisms for
	* authentication with HTTP servers: Basic Access, Digest Access, NTLM, and
	* Kerberos.
	* Except for Kerberos, all these mechanisms are also supported for
	* authentication with HTTP proxies.
	*
	* <H4>Kerberos Authentication</H4>
	*  \htmlonly <div class="bulletlists"> \endhtmlonly
	* The GD Runtime supports Kerberos version 5 authentication. When using
	* Kerberos authentication:
	* - Supply username and password credentials
	* as documented in the relevant function references.
	* - The username must be in the <EM>user</EM><TT>\@</TT><EM>realm</EM> long
	*   form. The short form <EM>shortrealm</EM><TT>\\</TT><EM>user</EM> is not
	*   supported.
	* - The GD Runtime will use these credentials to request Kerberos tickets. The
	*   tickets are persisted on the device in the Good Dynamics secure store. (The
	*   ticket store is not generally accessible to the application, but see
	*    \link GDCacheController::clearCredentialsForMethod:  clearCredentialsForMethod:\endlink.)
	* - The stored Kerberos tickets are then used to authenticate the user on any
	*   site that supports Kerberos authentication. So long as the ticket continues
	*   to be accepted, there is no need for credentials to be supplied again, and
	*   no authentication challenge.
	* - This continues until a site does not accept the stored ticket (e.g. the
	*   ticket has expired and cannot be renewed).
	* - The Kerberos realm must be accessible. Usually, this means that the
	*   Kerberos realm must be listed as an Additional Server in the Good Control
	*   console. See the \ref GC.
	* - Kerberos realms are treated differently to server addresses. An unqualified
	*   server address may be resolved according to configuration in the Good
	*   Control console, but the short form of a Kerberos realm cannot be resolved
	*   in this way. Note that the short form of the Kerberos realm will typically
	*   be the form used when logging in to the enterprise LAN at the desktop. The
	*   long form is often, but not necessarily, the short form with the domain
	*   appended.
	* - Kerberos delegation can be allowed or disallowed. See
	* \link GDCacheController.KerberosAllowDelegation
	* GDCacheController.KerberosAllowDelegation\endlink.
	* .
	*  \htmlonly </div> \endhtmlonly
	* 
	<H3>HTTP Cookie Handling</H3>
	* By default, HTTP cookies received through Good Dynamics secure communication
	* are handled automatically:
	* - Set-cookie: headers that are received as part of an HTTP response are
	*   processed and then added to subsequent matching requests.
	* - Persistent cookies are written to cookie storage in the Good Dynamics
	*   secure store. Storage takes place when the request's ready state becomes
	*   <TT>GDHttpRequestDone</TT>, if <TT>GDHttpRequest</TT> is in use.
	* .
	* The Good Dynamics cookie store persists between executions of the
	* application, and if the mobile device is switched off. The contents of the
	* store can be managed with the native <TT>NSHTTPCookieStorage</TT> API, as can
	* non-persistent cookies received through Good Dynamics secure communication.
	*
	* Automatic handling of HTTP cookies received through Good Dynamics secure
	* communication can be disabled, as follows:
	* - For <TT>GDHttpRequest</TT>, call the
	*   <TT>DisableCookieHandling</TT> function in the
	*   <TT>GDHttpRequest</TT> class.
	* - For <TT>GDURLLoadingSystem</TT>, call the
	*   <TT>SetHTTPShouldHandleCookies</TT> function in the native
	*   <TT>NSMutableURLRequest</TT> class, as usual.
	* .
	* \see <A
	*     HREF="http://developer.apple.com/library/ios/#documentation/Cocoa/Reference/Foundation/Classes/NSHTTPCookieStorage_Class/Reference/Reference.html"
	*     target="blank"
	* >NSHttpCookieStorage class reference</A> in the iOS Developer Library on
	* apple.com
	* \see <A
	*     HREF="http://developer.apple.com/library/ios/#documentation/Cocoa/Reference/Foundation/Classes/NSMutableURLRequest_Class/Reference/Reference.html"
	*     target="blank"
	* >NSMutableURLRequest class reference</A> in the iOS Developer Library on
	* apple.com
	*/																			
	[BaseType (typeof(NSObject), Delegates = new string[] { "WeakDelegate" }, Events = new Type[] { typeof(GDHttpRequestDelegate) })]
	public interface GDHttpRequest
	{
		/// <summary>
		/// </summary>
		[Export ("open:withUrl:withAsync:withUser:withPass:withAuth:")]
		bool Open ([PlainString] string method, [PlainString] string url, bool isAsync, [PlainString] string user, [PlainString] string password, [PlainString] string auth);

		/**< Open the HTTP request (all parameters).
		 * Call this function to open the HTTP request, and set the main parameters.
		 *
		 * This is generally the first function called, after <TT>new GDHttpRequest()</TT>, when
		 * the request's ready state is <TT>GDHttpRequestUnsent</TT>. However, in
		 * principle this function can be called at any time, regardless of the
		 * ready state. If the ready state is not <TT>GDHttpRequestUnsent</TT>
		 * then an effective <TT>Abort</TT> is executed, before the <TT>Open</TT>
		 * call is processed.
		 *
		 * This section documents all the parameters that the function supports.
		 * It is valid to use all the parameters, or to use particular subsets.
		 * The following <TT>Open</TT> sections document the valid subsets of
		 * parameters.
		 *
		 * \par Kerberos authentication
		 * To utilize Kerberos authentication, supply the username and password
		 * credentials to the initial call to this function. See also under HTTP
		 * Authentication, above.
		 * 
		 * \param method Null-terminated case-sensitive string containing the HTTP
		 * method, which will be sent to the server.
		 * Typical values are: "GET", "POST", "HEAD", "OPTIONS", "TRACE", "PUT",
		 * "CONNECT". Any other value is sent as a custom method.
		 * \param url Null-terminated string containing the Uniform Resource Locator (URL) that
		 * will be requested.  The URL must be fully qualified, including a scheme,
		 * domain, and path. For example: "http://www.example.com/index.html".
		 * \param isAsync <TT>false</TT> to use synchronous fetching,
		 * <TT>true</TT> to use asynchronous fetching.\n
		 * See under <TT>Send</TT> and <TT>Abort</TT> for details of the difference.
		 * \param user Null-terminated string containing authentication username.
		 * For Kerberos, this is in the <EM>user</EM><TT>\@</TT><EM>realm</EM> format.
		 * \param password Null-terminated string containing authentication password
		 * \param auth Null-terminated string specifying the authentication scheme:\n
		 * <TT>"BASIC"</TT> or a null pointer to use Basic Access authentication.\n
		 * <TT>"DIGEST"</TT> to use Digest Access authentication.\n
		 * <TT>"NEGOTIATE"</TT> to use negotiated Kerberos authentication, see note
		 * above.\n
		 * <TT>"NTLM"</TT> to use NTLM authentication.\n
		 * The following forms of the NTLM authentication protocol are supported:
		 * NTLMv1, NTLMv2, and NTLM2 Session.
		 *
		 * \return <TT>true</TT> if the request was opened.
		 * \return <TT>false</TT> if the parameters were not valid or the request could not
		 * be opened.
		 *
		 * If the request was opened then the ready state changes,
		 * to <TT>GDHttpRequestOpened</TT>.
		 * If asynchronous fetching was specified, then the delegate
		 * <TT>OnStateChange</TT> callback is invoked.
		 */

		/// <summary>
		/// </summary>
		[Export ("open:withUrl:withUser:withPass:withAuth:")]
		bool Open ([PlainString] string method, [PlainString] string url, [PlainString] string user, [PlainString] string password, [PlainString] string auth);

		/**< Open the HTTP request with synchronous fetching.
		 * Call with these parameters to open the HTTP request with authentication and synchronous fetching.
		 * See \ref Open (string method, string url, string user, string password, string auth) "Open" for full
		 * details.
		 */

		/// <summary>
		/// </summary>
		[Export ("open:withUrl:withAsync:")]
		bool Open ([PlainString] string method, [PlainString] string url, bool isAsync);

		/**< Open the HTTP request with specified fetching.
		 * Call with these parameters to open the HTTP request specifying
		 * synchronous or asynchronous fetching.
		 * The request will not use any new authentication.
		 *
		 * If Kerberos authentication
		 * is in use then existing Kerberos tickets will be attempted if the server
		 * returns an HTTP 401 response requesting to Negotiate Authentication.
		
		 * See \ref Open (string method, string url, string user, string password, string auth) "Open" for full
		 * details.
		 */
		
		/// <summary>
		/// </summary>
		[Export ("open:withUrl:")]
		bool Open ([PlainString] string method, string url);

		/**< Open the HTTP request with synchronous fetching.
		 * Call with these parameters to open the HTTP request with synchronous
		 * fetching.
		 * The request will not use any new authentication.
		 *
		 * If Kerberos authentication
		 * is in use then existing Kerberos tickets will be attempted if the server
		 * returns an HTTP 401 response requesting to Negotiate Authentication.
		 *
		 * See \ref Open (string method, string url, string user, string password, string auth) "Open" for full
		 * details.
		 */

		/// <summary>
		/// </summary>
		[Export ("disableHostVerification")]
		bool DisableHostVerification { get; }

		/**< Security option: Disable SSL/TLS host name verification.
		 * Call this function to disable host name verification, when
		 * making an HTTPS request.
		 * Host name verification is an SSL/TLS security option.
		 * \par Host Name Verification
		 * When negotiating an SSL/TLS connection, the server sends a certificate
		 * indicating its identity. The certificate includes a number of host names.
		 * By default, when using HTTPS, one of the host names in the certificate
		 * must match with the host name in the URL being opened,
		 * or the connection fails.
		 * When host name verification is disabled, the connection succeeds regardless
		 * of whether there is a matching host name in the certificate.\n
		 * When enabled, the Good Dynamics Runtime checks server identity in a way that
		 * conforms with the relevant RFC.
		 * See under section 3.1 Server Identity, in <A
		 *     href="http://www.rfc-editor.org/rfc/rfc2818.txt"
		 *     target="_blank"
		 * >RFC 2818</A>.
		 *
		 * Note that connections may remain open after the HTTP transaction completes.
		 * Even if another instance of GD HTTP Request is constructed, the connection
		 * may still be reused. If subsequent transactions to the server require host
		 * verification, <TT>Close</TT> must be called immediately after the last
		 * unverified transaction completes.
		 *
		 * \see HTTPS Security, above
		 *
		 * This function should be called before <TT>Send</TT> has been called,
		 * when the request's ready state is <TT>GDHttpRequest_UNSENT</TT> or
		 * <TT>GDHttpRequest_OPENED</TT>.
		 *
		 * Disabling host name verification does not disable authenticity verification,
		 * see \ref disablePeerVerification.
		 *
		 * \return <TT>YES</TT> if the security option was disabled.
		 * The disabled check will not be made when the request is sent.
		 * \return <TT>NO</TT> if the security option could not be disabled.
		 *
		 * This function does not affect the ready state.
		 */

		/// <summary>
		/// </summary>
		[Export ("disablePeerVerification")]
		bool DisablePeerVerification { get; }

		/**< Security option: Disable SSL/TLS authenticity verification.
		 * Call this function to disable certificate authenticity
		 * verification, when making an HTTPS request.
		 * Authenticity verification is an SSL/TLS security option.
		 *
		 * \par Certificate Authenticity Verification
		 * When negotiating an SSL/TLS connection, the server sends a certificate
		 * indicating its identity.
		 * By default, when using HTTPS, the certificate must be verified as
		 * trustworthy, or the connection fails.
		 * In this context, trustworthiness derives from a chain of
		 * digital signatures, rooted in a certification authority.
		 * When authenticity verification is disabled, the connection succeeds
		 * regardless of the certificate's trustworthiness.\n
		 * When enabled, the Good Dynamics Runtime checks certificate
		 * trustworthiness using operating system services.
		 * See the <A
		 *   HREF="http://developer.apple.com/library/ios/documentation/Security/Reference/certifkeytrustservices/"
		 *   target="_blank"
		 * >Certificate, Key, and Trust Services Reference</A> in the iOS Developer
		 * Library on apple.com
		 *
		 * Note that connections may remain open after the HTTP transaction completes.
		 * Even if another instance of GD HTTP Request is constructed, the connection
		 * may still be reused. If subsequent transactions to the server require peer
		 * verification, <TT>Close</TT> must be called immediately after the last
		 * unverified transaction completes.
		 *
		 * \see HTTPS Security, above
		 *
		 * This function should be called before <TT>Send</TT> has been called,
		 * when the request's ready state is <TT>GDHttpRequestUnsent</TT> or
		 * <TT>GDHttpRequestOpened</TT>.
		 *
		 * Disabling authenticity verification implicitly disables host name verification.
		 *
		 * \return <TT>true</TT> if the security option was disabled.
		 * The disabled check will not be made when the request is sent.
		 * \return <TT>false</TT> if the security option could not be disabled.
		 *
		 * This function does not affect the ready state.
		 */

		/// <summary>
		/// </summary>
		[Export ("disableFollowLocation")]
		bool DisableFollowLocation { get; }

		/**< Disable automatic following of redirections.
		 * Call this function to disable automatic following of redirections.
		 * When automatic following is disabled, the application must handle redirection
		 * itself, including handling Location: headers, and HTTP statuses in the 30x
		 * range.
		 *
		 * When automatic following is enabled, any Location: header that the server
		 * sends as part of an HTTP header will be automatically followed.
		 * This means that the same request will be re-sent to the new location.
		 * The re-sent request may itself be redirected, receiving a new Location:
		 * header. Automatic redirection continues until a request receives no location
		 * headers.
		 *
		 * This function should be called before <TT>Send</TT> has been called,
		 * when the request's ready state is <TT>GDHttpRequestUnsent</TT> or
		 * <TT>GDHttpRequestOpened</TT>.
		 *
		 * \return <TT>true</TT> if the option was disabled.
		 * Location: header URL will not be followed.
		 * \return <TT>false</TT> if the option could not be disabled.
		 *
		 * This function does not affect the ready state.
		 */

		/// <summary>
		/// </summary>
		[Export ("disableCookieHandling")]
		bool DisableCookieHandling { get; }

		/**< Disable automatic handling of cookies.
		 * Call this function to disable automatic cookie handling.
		 * When automatic handling is disabled, the application must store and process
		 * cookies itself.
		 *
		 * When automatic handling is enabled, the GD Runtime processes and stores HTTP
		 * cookies automatically, as described under HTTP Cookie Handling, above.
		 * 
		 * This function should be called before <TT>Send</TT> has been called,
		 * when the request's ready state is <TT>GDHttpRequestUnsent</TT> or
		 * <TT>GDHttpRequestOpened</TT>.
		 *
		 * \return <TT>true</TT> if the option was disabled.
		 * \return <TT>false</TT> if the option could not be disabled.
		 *
		 * This function does not affect the ready state.
		 */

		/// <summary>
		/// </summary>
		[Export ("clearCookies:")]
		void ClearCookies (bool includePersistentStore);

		/**< Delete automatically stored cookies.
		 * \deprecated
		 * This function is deprecated and will be removed in a future release. Cookies
		 * can be directly cleared by using the native <TT>NSHTTPCookieStorage</TT> API.
		 * See under HTTP Cookie Handling, above.
		 *
		 * Call this function to clear cookies that were automatically stored.
		 * Cookies can be cleared from memory only, or from the persistent cookie
		 * store too. If cleared from memory only, cookies will still be reloaded from
		 * the persistent cookie store when the application is next launched.
		 *
		 * This function should be called before <TT>Send</TT> has been called,
		 * when the request's ready state is <TT>GDHttpRequestUnsent</TT> or
		 * <TT>GDHttpRequestOpened</TT>.
		 *
		 * This function is most useful when automatic cookie handling is enabled. See
		 * the \ref disableCookieHandling function, above.
		 *
		 * This function does not affect the ready state.
		 * \param includePersistentStore <TT>true</TT> to clear cookies from memory and
		 * from persistent Good Dynamics cookie storage.\n
		 * <TT>false</TT> to clear cookies from memory only.
		 */

		/// <summary>
		/// </summary>
		[Export ("enableHttpProxy:withPort:withUser:withPass:withAuth:")]
		bool EnableHttpProxy ([PlainString] string host, int port, [PlainString] string user, [PlainString] string password, [PlainString] string auth);

		/**< Configure and enable an HTTP proxy (all parameters).
		 * Call this function to configure an HTTP proxy address and credentials,
		 * and enable connection through the proxy.
		 *
		 * The proxy server can be located behind the enterprise firewall. In this case
		 * its address must be registered in the enterprise's Good Control (GC) console.
		 * Registration would usually be as a GC additional server. See the
		 * \ref GC.
		 *
		 * Certificate authenticity verification while using a proxy is not
		 * currently supported.
		 * When making HTTPS requests through a proxy, SSL/TLS certificate
		 * verification must be disabled, see the <TT>DisablePeerVerification</TT>
		 * function.
		 *
		 * This function should be called before <TT>Send</TT> has been called,
		 * when the request's ready state is <TT>GDHttpRequestUnsent</TT> or
		 * <TT>GDHttpRequestOpened</TT>.
		 *
		 * \param host Null-terminated string containing the address of the proxy.
		 * Can be either an Internet Protocol address (IP address, for example
		 * <TT>"192.168.1.10"</TT>), or a fully qualified domain name
		 * (for example <TT>"www.example.com"</TT>).
		 * \param port Number of the port on the proxy to which connection will be made.
		 * \param user Null-terminated string containing the proxy authentication
		 * username.
		 * \param password Null-terminated string containing the proxy authentication
		 * password.
		 * \param auth Null-terminated string specifying the proxy authentication
		 * scheme:\n
		 * <TT>"NTLM"</TT> to use NTLM authentication.\n
		 * <TT>"DIGEST"</TT> to use Digest Access authentication.\n
		 * <TT>"BASIC"</TT> or any other value to use Basic Access authentication.\n
		 * The following forms of the NTLM authentication protocol are supported:
		 * NTLMv1, NTLMv2, and NTLM2 Session.
		 *
		 * \return <TT>true</TT> if proxy connection was enabled.
		 * \return <TT>false</TT> if proxy connection could not be enabled.
		 *
		 * This function does not affect the ready state.
		 */

		/// <summary>
		/// </summary>
		[Export ("enableHttpProxy:withPort:")]
		bool EnableHttpProxy ([PlainString] string host, int port);

		/**< Configure and enable an HTTP proxy without authentication.
		 * Call this function to configure an HTTP proxy address and credentials,
		 * and enable connection through the proxy.
		 * No authentication scheme will be used when connecting to the proxy.
		 *
		 * See
		 * \ref EnableHttpProxy (string host, int port, string user, string password, string auth) "EnableHttpProxy"
		 * for full details.
		 */

		/// <summary>
		/// </summary>
		[Export ("disableHttpProxy")]
		bool DisableHttpProxy { get; }

		/**< Disable HTTP proxy.
		 * Call this function to disable connection through an HTTP proxy.
		 *
		 * This function should be called before <TT>Send</TT> has been called,
		 * when the request's ready state is <TT>GDHttpRequestUnsent</TT> or
		 * <TT>GDHttpRequestOpened</TT>.
		 *
		 * \return <TT>true</TT> if proxy connection was disabled.
		 * \return <TT>false</TT> if proxy connection could not be disabled.
		 *
		 * This function does not affect the ready state.
		 */
 
		/// <summary>
		/// </summary>
		[Export ("setRequestHeader:withValue:")]
		bool SetRequestHeader ([PlainString] string header, [PlainString] string value);

		/**< Add an HTTP Header Field.
		 * Call this function to add a Header Field to the HTTP request. This is for
		 * standard HTTP Header Fields such as "Authorization".
		 * Headers are added after the request is open, and prior to sending.
		 *
		 * This function should be called before <TT>Send</TT> has been called,
		 * when the request's ready state is <TT>GDHttpRequestOpened</TT>.
		 *
		 * This function can be called zero or more times, since not all HTTP
		 * requests will require headers to be added by the application.
		 *
		 * Parameter data is copied and stored internally.
		 * The application does not need to keep the data after calling the function.
		 *
		 * \param header Null-terminated string of the HTTP Header Field to be added
		 * \param value Null-terminated string of the header field's value
		 *
		 * \return <TT>true</TT> if the header was added OK.
		 * \return <TT>false</TT> if the header could not be added.
		 *
		 * This function does not affect the ready state.
		 */
	
		/// <summary>
		/// </summary>
		[Export ("setPostValue:forKey:")]
		void SetPostValue ([PlainString] string value, [PlainString] string key);

		/**< Add a name/value pair for a "POST" request.
		 * Call this function to add a name/value pair to the HTTP request.
		 * The request method must be "POST".
		 * Multiple name/value pairs can be added, by calling this function multiple
		 * times.
		 *
		 * When the request is sent, name/value pairs will be encoded in the request
		 * body in a way that is compatible with HTML form submission.
		 * No other body data can be passed in the send call.
		 *
		 * This function should be called before <TT>Send</TT> has been called,
		 * when the request's ready state is <TT>GDHttpRequestOpened</TT>.
		 *
		 * \param value Null-terminated string containing the value to be set.
		 * \param key Null-terminated string containing the name associated with the
		 * value.
		 *
		 * This function does not affect the ready state.
		 */

		/// <summary>
		/// </summary>
		[Export ("clearPostValues")]
		void ClearPostValues ();

		/**< Clear all name/value pairs.
		 * Call this function to remove all name/value pairs from the HTTP request.
		 * Name/value pairs would have been added with the <TT>setPostValue</TT>
		 * function, see above.
		 *
		 * Note that all name/value pairs will be cleared if the request is re-opened.
		 * This function need only be called if it is required to clear name/value pairs
		 * before sending.
		 *
		 * This function should be called before <TT>Send</TT> has been called,
		 * when the request's ready state is <TT>GDHttpRequestOpened</TT>.
		 *
		 * This function does not affect the ready state.
		 */

		/// <summary>
		/// </summary>
		[Export ("send:withLength:withTimeout:")]
		bool Send (IntPtr data, uint len, int timeout_s);

		/**< Send the HTTP request (all parameters).
		 * Call this function to send the HTTP request to the server.
		 *
		 * This section documents all the parameters that the function supports.
		 * It is valid to use all the parameters, or to use particular subsets.
		 * The following <TT>Send</TT> sections document the valid subsets of
		 * parameters.
		 *
		 * This function can only be called after <TT>Open</TT> has succeeded,
		 * when the ready state is <TT>GDHttpRequestOpened</TT>. The subsequent
		 * behavior of <TT>Send</TT> depends on what kind of
		 * fetching was specified in the <TT>Open</TT> call.
		 * See the <TT>isAsync</TT> parameter to <TT>Open</TT>, above.
		 *
		 * If synchronous fetching was specified, then the <TT>Send</TT> call
		 * returns when HTTP response data is received from the server.
		 *
		 * If asynchronous fetching was specified, then
		 * the <TT>Send</TT> call returns immediately. State transitions then
		 * take place as the request progresses:
		 * -# <TT>GDHttpRequestSent</TT> once the HTTP request has been sent, then
		 * -# <TT>GDHttpRequestHeadersReceived</TT> once the HTTP response headers
		 * have been received, then
		 * -# <TT>GDHttpRequestLoading</TT> when the first HTTP response data is
		 * received, then
		 * -# <TT>GDHttpRequestDone</TT> once all HTTP response data has been
		 * received.
		 * .
		 * If an error is encountered, in any state, then the request
		 * makes an immediate transition to the <TT>GDHttpRequestDone</TT> state.
		 * This includes connection errors, security errors, and time out expiry.
		 * (See also the Ready State table in the class documentation, above.)
		 *
		 * \param data Pointer to the HTTP request body.
		 * This would be used in, for example, a "POST" method request.
		 * Parameter data is <EM>not </EM>copied. The application must ensure that
		 * the data remains available until the request is in the
		 * <TT>GDHttpRequestDone</TT> state.
		 *
		 * \param len Numeric value for the number of bytes in the request body,
		 * i.e. what is pointed to by the data parameter.
		 *
		 * \param timeout_s Length of time out in seconds, or 0 (zero) for never.
		 * If the function is called without this parameter, see below, zero is assumed.
		 *
		 * \return <TT>true</TT> if the request was accepted.
		 * \return <TT>false</TT> if the parameters were invalid.
		 *
		 * If the request was sent, and asynchronous fetching was specified,
		 * then a state transition should be expected. The next state would
		 * be <TT>GDHttpRequestHeadersReceived</TT> if the request is
		 * proceeding, or <TT>GDHttpRequestDone</TT> if there is a connection
		 * failure.
		 *
		 * \see \ref SendWithFile (string pathAndFileName, double timeoutSeconds) "SendWithFile"
		 * \see \ref SendData (NSData data) "SendData"
		 */

		/// <summary>
		/// </summary>
		[Export ("send:withTimeout:")]
		bool Send (IntPtr data, int timeout_s);

		/**< Send the HTTP request with null-terminated body and specified time out.
		 * Call this function to send an HTTP request with body,
		 * and specified time out. The body must be null-terminated.
		 *
		 * See \ref Send (IntPtr data, uint len, int timeout_s) "Send" for details.
		 */
		 
		/// <summary>
		/// </summary>
		[Export ("send:")]
		bool Send (IntPtr data);

		/**< Send the HTTP request with null-terminated body.
		 * Call this function to send an HTTP request with body,
		 * and the default time out setting. The body must be null-terminated.
		 *
		 * See \ref Send (IntPtr data, uint len, int timeout_s) "Send" for details.
		 */

		/// <summary>
		/// </summary>
		[Export ("send")]
		bool Send ();

		/**< Send the HTTP request without body (e.g.\ "GET" method).
		 * Call this function to send an HTTP request that has no body, for
		 * example a "GET" method request, using the default time out setting.
		 *
		 * To send an HTTP request with no body, and override the time out setting,
		 * use the full form of <TT>Send</TT> but pass a
		 * null pointer as the data parameter.
		 *
		 * See \ref Send (IntPtr data, uint len, int timeout_s) "Send" for details.
		 */

		/// <summary>
		/// </summary>
		[Export ("sendData:withTimeout:")]
		bool SendData (NSData data, int timeout_s);

		/**< Send the HTTP request with NSData body and specified time out.
		 * Call this function to send an HTTP request with body,
		 * and specified time out.
		 * The body will be the contents of an <TT>NSData</TT> object.
		 *
		 * See \ref Send (IntPtr data, uint len, int timeout_s) "Send" for details.
		 */

		/// <summary>
		/// </summary>
		[Export ("sendData:")]
		bool SendData (NSData data);

		/**< Send the HTTP request with NSData body.
		 * Call this function to send an HTTP request with body,
		 * and the default time out setting.
		 * The body will be the contents of an <TT>NSData</TT> object.
		 *
		 * See \ref Send (IntPtr data, uint len, int timeout_s) "Send" for details.
		 */

		/// <summary>
		/// </summary>
		[Export ("sendWithFile:withTimeout:")]
		bool SendWithFile (string pathAndFileName, double timeoutSeconds);

		/**< Send the HTTP request with file contents as body, with specified time out.
		 * Call this function to use the open HTTP request to upload a file. The HTTP
		 * request's method will be overridden to "PUT" unless it is a custom method. A
		 * time out can be specified.
		 *
		 * This function causes the HTTP request to be sent, similarly to the
		 * <TT>Send</TT> function, above. The body of the request will be the contents
		 * of the specified file.
		 *
		 * The file will not be deleted after it is uploaded. Uploading directly from
		 * the Good Dynamics secure file system is not supported.
		 *
		 * \param pathAndFileName <TT>string</TT> containing the path (optional) and
		 *                        filename of the file to upload. If path is omitted,
		 *                        the file is read from the current working directory.
		 * \param timeoutSeconds Length of time out in seconds, or 0 (zero) for never.
		 *                       If the function is called without this parameter, see
		 *                       below, zero is assumed.
		 *
		 * \return <TT>true</TT> if the request was accepted.
		 * \return <TT>false</TT> if the parameters were invalid.
		 *
		 * \see \ref sSend (IntPtr data, uint len, int timeout_s) "Send" for details of sending.
		 * \see \ref Open (string method, string url, string user, string password, string auth) "Open" for
		 * how to set the request method.
		 */

		/// <summary>
		/// </summary>
		[Export ("sendWithFile:")]
		bool SendWithFile (string pathAndFileName);

		/**< Send the HTTP request with file contents as body, with default time out.
		 * Call this function to send the HTTP request, reading the body of the request
		 * from a file, with the default time out setting.
		 *
		 * See \ref SendWithFile (string pathAndFileName, double timeoutSeconds) "SendWithFile" for details.
		 */

		/// <summary>
		/// </summary>
		[Export ("getState")]
		GDHttpRequestState GetState { get; }

		/**< Get the ready state of the HTTP request.
		 * This function returns the ready state of the HTTP Request. See the
		 * <TT>GDHttpRequestState</TT> documentation for a list of values
		 * and ready states. This function is generally the first function called in
		 * the delegated event handler, see \ref GDHttpRequestDelegate.
		 *
		 * This function is the GD HTTP Request equivalent to the
		 * standard XHR read-only attribute, readyState.
		 *
		 * \return Numeric value that can be compared to the
		 * \ref GDHttpRequestState enumerated constants.
		 */

		/// <summary>
		/// </summary>
		[Export ("getResponseHeader:")]
		IntPtr GetResponseHeader ([PlainString] string header);

		/**< Get a specified HTTP response header.
		 * Call this function to obtain a specific HTTP response header. (Compare
		 * \ref GetAllResponseHeaders.)
		 * HTTP response headers will be sent by the server as part of its
		 * response to the HTTP request. Response headers are sent before the content
		 * part of the response. (Compare \ref GetReceiveBuffer.)
		 *
		 * If asynchronous fetching is in use, this function can be used after
		 * the <TT>Send</TT> call has been made and the request's ready state has
		 * progressed to <TT>GDHttpRequestHeadersReceived</TT>.\n
		 * If synchronous fetching is in use, this function can be used after
		 * <TT>Send</TT> has returned. (By that time, the ready state will
		 * already have progressed to <TT>GDHttpRequestDone</TT>.)
		 *
		 * \param header Null-terminated string of the required HTTP response header field.
		 *
		 * \return Null-terminated string containing the value of the specified header,
		 * if present.
		 * \return Empty string if the server did not send the specified header,
		 * or if there was an error and the request never reached the server.
		 */

		/// <summary>
		/// </summary>
		[Export ("getAllResponseHeaders")]
		IntPtr GetAllResponseHeaders { get; }

		/**< Get all HTTP response headers.
		 * Call this function to obtain all HTTP response headers. (Compare
		 * \ref GetResponseHeader:.)
		 * HTTP response headers will be sent by the server as part of its
		 * response to the HTTP request. Response headers are sent before the content
		 * part of the response. (Compare \ref GetReceiveBuffer.)
		 *
		 * This function can be used at the same point in the HTTP request cycle
		 * as <TT>GetResponseHeader</TT>, see above.
		 *
		 * \return Null-terminated string containing all HTTP response header fields,
		 * and their values.
		 * Different headers will be separated by newline characters.
		 * On each line, field and value will be separated by a colon (:) character.
		 *
		 * This function does not affect the ready state.
		 */

		/// <summary>
		/// </summary>
		[Export ("getStatus")]
		int GetStatus { get; }

		/**< Get the numeric HTTP response status, or 0 (zero) if an error occurred.
		 * Call this function to determine the success or failure of the HTTP
		 * request.
		 * If the request was sent OK, this function returns the status code received
		 * from the HTTP server, which could be a success code or an error code.
		 * Otherwise, if the request was not sent, or there was a connection failure,
		 * this function returns zero.
		 *
		 * In normal HTTP request processing, the status code is sent before the content
		 * of the response. (Compare \ref GetReceiveBuffer.)
		 *
		 * This function can be used at the same point in the HTTP request cycle
		 * as <TT>GetResponseHeader</TT> see above.
		 *
		 * This function is the GD HTTP Request equivalent to the
		 * standard XHR read-only attribute, status.
		 *
		 * \return Numeric value for the final request status,
		 * interpreted as follows:<DL
		 *     ><DT
		 *         >0 (zero)</DT
		 *     ><DD
		 *         >Server connection failed.\n
		 *         This includes:
		 *         - DNS errors, or other problems where a connection to the server
		 *         could not even be established,
		 *         - Certificate verification failures, when HTTPS is in use,
		 *         - Connection failure during receipt of the HTTP response,
		 *         - Time out expiry while waiting for the server,
		 *         - Connection closure initiated by the application, see \ref abort.</DD
		 *     ><DT
		 *         >200 to 299</DT
		 *     ><DD
		 *         >HTTP request successful at server.\n
		 *         The number is the success code returned by the server.</DD
		 *     ><DT
		 *         >Other values</DT
		 *     ><DD
		 *         >HTTP request failed at server.\n
		 *         This the includes all the standard HTTP errors, such as:
		 *         404&nbsp;'Not&nbsp;found' or 403&nbsp;'Forbidden'.</DD
		 *     ></DL
		 * >
		 *
		 * Note that, when asynchronous fetching is in use, it is possible that this
		 * function returns different values at different points in the request cycle.
		 * For example, suppose there is a network failure during receipt of a long
		 * response. When the <TT>GDHttpRequestLoading</TT> state is entered, 200 might
		 * be returned. But, when the request later enters the
		 * <TT>GDHttpRequestDone</TT> state after the connection failure, 0 would be
		 * returned.
		 *
		 * \see \ref GetStatusText
		 */

		/// <summary>
		/// </summary>
		[Export ("getStatusText")]
		[PlainString] string GetStatusText { get; }

		/**< Get the textual HTTP response status, as sent by the server,
		 * or details of error if \ref getStatus returns 0.
		 * This function returns the status message received from the HTTP
		 * server, if the request was sent OK.
		 * If the request was not sent, or there was a connection failure, this
		 * function will return a description of the condition that caused the failure.
		 *
		 * The status message is sent at the same time as the status code, see
		 * <TT>GetStatus</TT> above.
		 *
		 * This function can be used at the same point in the HTTP request cycle
		 * as <TT>GetResponseHeader</TT>, see above.
		 *
		 * This function is the GD HTTP Request equivalent to the
		 * standard XHR read-only attribute, statusText.
		 *
		 * \return Null-terminated string containing the status text.
		 * The contents depend on the <TT>GetStatus</TT> return code, as follows:<TABLE
		 *     ><TR><TH><TT>GetStatus</TT> return code</TH><TH>Message contents</TH
		 *     ></TR><TR><TD
		 *         >0 (zero)\n
		 *         Connection failure</TD
		 *     ><TD
		 *         >Description of the error condition that caused the failure.
		 *         For example:\n
		 *         SSL/TLS negotiation failed</TD
		 *     ></TR><TR><TD
		 *         >Other\n
		 *         Request sent OK</TD
		 *     ><TD
		 *         >Success or failure message provided by the HTTP server.\n
		 *         In the failure case, this includes the standard HTTP errors, such as:
		 *         404&nbsp;'Not&nbsp;found' or 403&nbsp;'Forbidden'.</TD
		 *     ></TR
		 * ></TABLE>
		 *
		 * \see \ref GetStatus
		 */

		/// <summary>
		/// </summary>
		[Export ("getReceiveBuffer")]
		GDDirectByteBuffer GetReceiveBuffer { get; }

		/**< Get HTTP response data.
		 * Call this function to obtain the response data, i.e. the body of the HTTP
		 * response.
		 * Response data will be sent by the server as part of its
		 * response to the HTTP request. Response data is sent after response
		 * headers. (Compare \ref GetResponseHeader and \ref GetAllResponseHeaders.)
		 *
		 * If asynchronous fetching is in use, this function can be used after
		 * the <TT>Send</TT> call has been made and the request's ready state has
		 * progressed to <TT>GDHttpRequestLoading</TT>.\n
		 * If synchronous fetching is in use, this function can be used after
		 * <TT>Send</TT> has returned. (By that time, the ready state will
		 * already have progressed to <TT>GDHttpRequestDone</TT>.)
		 *
		 * The first time this function is called, all data received so far is
		 * returned. Subsequent calls return only the data received since the
		 * previous call. (If synchronous fetching is in use, then this
		 * function would only be called once per request, and would return
		 * all the response data.)
		 *
		 * This function is the GD HTTP Request equivalent to the
		 * standard XHR read-only attributes, responseText and responseXML.
		 *
		 * \return Pointer to a GDDirectByteBuffer object that contains
		 * the response data received since last called.\n
		 * The application must read the data prior to releasing or re-using the
		 * GD HTTP Request object.
		 *
		 * This function does not affect the ready state.
		 */

		/// <summary>
		/// </summary>
		[Export ("close")]
		bool Close { get; }

		/**< Close connection and reset disabled options.
		 * Call this function to force closure of all connections that were used by the
		 * HTTP request, after the request has completed.
		 * If any options were disabled then these will be re-enabled when
		 * the first connection is re-opened. (See also the <TT>DisableHostVerification</TT>,
		 * <TT>DisablePeerVerification</TT> and other disable functions, above.)
		 *
		 * This function should only be called when:\n
		 * Some options were disabled when the request was sent, and\n
		 * A new request is to be sent to the same endpoint, and\n
		 * For the new request, the options that were disabled are now to be re-enabled.
		 *
		 * Connections may remain open after the HTTP transaction completes.
		 * Even if another instance of GD HTTP Request is constructed, connections
		 * may still be reused.
		 * Calling this function immediately after the transaction completes will
		 * ensure that connections are closed, and any SSL/TLS verifications that were
		 * disabled are re-enabled.
		 *
		 * After calling this function, it may take longer to make another HTTP request
		 * to the same host.
		 *
		 * This function can be called when the ready state
		 * is <TT>GDHttpRequestDone</TT>. Compare \ref abort.
		 *
		 * \return <TT>true</TT> if the request was closed and the options reset.
		 * \return <TT>false</TT> if the request could not be closed.
		 *
		 * This function does not affect the ready state.
		 */

		/// <summary>
		/// </summary>
		[Export ("abort")]
		bool Abort ();

		/**< Cancel the request.
		 * Call this function to cancel the HTTP request.
		 * Any response data that had been received will be discarded.
		 * Any HTTP request headers that were set will be cleared.
		 * Further changes also take place, depending on the request's ready state.
		 *
		 * If the ready state is <TT>GDHttpRequestSent</TT> or
		 * <TT>GDHttpRequestHeadersReceived</TT> or
		 * <TT>GDHttpRequestLoading</TT>, then the ready state is set to
		 * <TT>GDHttpRequestDone</TT> and the delegated event handler is invoked. See
		 * GDHttpRequestDelegate. The final status will be set to zero, i.e.
		 * <TT>getStatus</TT> will return 0.
		 *
		 * If the ready state is <TT>GDHttpRequestDone</TT>,
		 * <TT>GDHttpRequest_OPENED</TT>, or <TT>GDHttpRequestUnsent</TT>, then this
		 * function does nothing and returns NO.
		 *
		 * \return <TT>true</TT> if the request was aborted.
		 * \return <TT>false</TT> if the request could not be aborted, had not been sent, or
		 * had already completed.
		 */

		/// <summary>
		/// </summary>
		[Export ("enablePipelining")]
		bool EnablePipelining { get; set; }

		/**< Enable and disable HTTP pipelining of the request.
		 * Set this property to enable and disable HTTP pipelining on the associated
		 * request.
		 *
		 * The effect of enabling is to notify the Good Dynamics Runtime that this HTTP
		 * request should be pipelined with other requests to the same server. Disabling
		 * notifies the Good Dynamics Runtime that this request must not be pipelined.
		 *
		 * This property should be set before <TT>send</TT> has been called, when the
		 * request's ready state is <TT>GDHttpRequestUnsent</TT> or <TT>GDHttpRequestOpened</TT>.
		 *
		 * Setting this property does not affect the ready state.
		 *
		 * Set this property to <TT>true</TT> to enable HTTP pipelining, or to <TT>false</TT> to
		 * disable HTTP pipelining. By default, HTTP pipelining is enabled.
		 */

		/// <summary>
		/// </summary>
		[Wrap ("WeakDelegate")]
		GDHttpRequestDelegate Delegate { get; set; }

		/**< Delegated event-handling.
		 * The GD HTTP Request object can work asynchronously, at the option of the
		 * application. See <TT>isAsync</TT> under the <TT>Open</TT> function, above.
		 *
		 * When working asynchronously, if the ready state changes or response data is
		 * received, an event is generated by the Good Dynamics Runtime, and passed to a
		 * callback function in the application.
		 *
		 * Set this property to an instance of a class that contains the code for the
		 * required callback function, i.e. a class that implements
		 * the GDHttpRequestDelegate protocol.
		 */

		/// <summary>
		/// </summary>
		[Export ("delegate", ArgumentSemantic.Assign)]
		NSObject WeakDelegate { get; set; }
	}

	/// <summary>
	/// </summary>
	/** NSURLCache category with additional features.
	 * This class is a category of the native <TT>NSURLCache</TT> class that adds
	 * the functions documented below to the API. The additional functions can
	 * be used when the Good Dynamics proxy infrastructure is enabled in the URL
	 * Loading System (see \ref GDURLLoadingSystem). This class provides additional
	 * features to the default cache.
	 *
	 * This documentation includes only additional operations that are not part
	 * of the default <TT>NSURLCache</TT> API.
	 *
	 * Note that the additional features in this API cannot be used when the Good
	 * Dynamics proxy infrastructure is disabled in the URL Loading System, even if
	 * temporarily. If the functions are called in this state, they have no effect.
	 *
	 * \see <A
	 *     HREF="http://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class"
	 *     target="_blank"
	 * >NSURLCache class reference</A> in the iOS Developer Library on apple.com
	 */
	[Category, BaseType (typeof(NSUrlCache))]
	public interface GDURLCache_NSURLCache
	{
		/// <summary>
		/// </summary>
		[Export ("setMaxCacheFileAge:")]
		void MaxCacheFileAge (double age);

		/**< Set the default maximum age of cached files.
		 * Call this function to set a default maximum age for cached files.
		 * The default maximum age will be used where it is less than the maximum age
		 * specified in the server cache directive, if any.
		 *
		 * The default maximum only applies when the Good Dynamics proxy infrastructure
		 * is enabled in the URL Loading System, see \ref GDURLLoadingSystem.
		 *
		 * \param age <TT>double</TT> representing the maximum age in
		 *            seconds.
		 */

		/// <summary>
		/// </summary>
		[Export ("setMaxCacheFileSize:")]
		void MaxCacheFileSize (int fileSize);

		/**< Set the maximum permitted size of a cached file.
		 * Call this function to set the maximum permitted size of a cached file.
		 * If not set, a default maximum of 1 megabyte will be used.
		 *
		 * This function sets the limit for a single file, not for the size of the whole
		 * cache. The capacity of the cache as a whole can be set using the
		 * native <TT>NSURLCache</TT> API. See the <A
		 *     HREF="http://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class"
		 *     target="_blank"
		 * >NSURLCache class reference</A> in the iOS Developer Library on apple.com for
		 * details.
		 *
		 * The permitted maximum only applies when the Good Dynamics proxy
		 * infrastructure is enabled in the URL Loading System, see
		 * \ref GDURLLoadingSystem.
		 *
		 * \param fileSize <TT>int</TT> representing the maximum file size in
		 *                 bytes.
		 */
		 
		[Export ("maxCacheFileSize")]
		int MaxCacheFileSize ();
		/**< Get the maximum permitted size of a cached file.
		 * Call this function to get the maximum permitted size of a cached file.
		 *
		 * This function returns the limit for a single file, not for the size of the
		 * whole cache. The native <TT>NSURLCache</TT> API can be used to access
		 * information about the cache as a whole. See the <A
		 *     HREF="http://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class"
		 *     target="_blank"
		 * >NSURLCache class reference</A> in the iOS Developer Library on apple.com for
		 * details.
		 *
		 * The permitted maximum only applies when the Good Dynamics proxy
		 * infrastructure is enabled in the URL Loading System, see
		 * \ref GDURLLoadingSystem.
		 *
		 * \returns <TT>int</TT> representing the maximum file size in bytes.
		 */
	}

	/// <summary>
	/// </summary>
	/** Manage access across the firewall via the URL Loading System.
	 * Good Dynamics applications can utilize the native URL Loading System to
	 * communicate with servers that are behind the enterprise firewall.
	 * This is an alternative approach to using GDHttpRequest.
	 * Communication across the enterprise firewall utilizes the Good Dynamics
	 * proxy infrastructure, which is secure.
	 *
	 * Access across the firewall is enabled in the URL Loading System by default,
	 * when authorization of the application succeeds.
	 * The application can subsequently disable and enable access.
	 * If the application's or the user's authorization is withdrawn, access is
	 * implicitly disabled for the duration of the withdrawal.
	 *
	 * Access across the firewall utilizes the Good Dynamics proxy infrastructure.
	 * The Good Dynamics Runtime includes a class that interfaces with the
	 * infrastructure. The interfacing class is also compatible to be registered as
	 * a URL handler in the URL Loading System. Enabling and disabling access across
	 * the firewall actually registers and de-registers the interfacing class. This
	 * means that, when access is disabled, the default URL Loading System handlers
	 * will service any URL requests.
	 *
	 * <B>Note that synchronous request calls should not be made from the main
	 * application thread.</B>
	 *
	 *  \htmlonly <div class="bulletlists"> \endhtmlonly
	 * When access is enabled, the normal URL Loading System classes can be used
	 * to communicate with servers that are behind the firewall, using standard
	 * Internet protocols. For an overview, refer to the <A
	 * HREF="http://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/URLLoadingSystem/"
	 * target="_blank">URL Loading System Programming Guide in the iOS Developer
	 * Library on apple.com</A>. Note the following details:
	 * - Only the HTTP and HTTPS schemes are ever handled by the Good Dynamics
	 *   Runtime. FTP and other schemes are never handled by the Good Dynamics
	 *   Runtime, and hence cannot be used to access resources that are behind the
	 *   firewall.
	 * - Enterprise servers that are not listed in the Good Control console cannot
	 *   be accessed, unless they are accessible from the Internet.
	 * - Authorization credentials are supported with the following notes:\n
	 *   <TT>NSURLAuthenticationMethodHTTPBasic</TT> is supported.\n
	 *   <TT>NSURLAuthenticationMethodDefault</TT> is treated as
	 *   <TT>NSURLAuthenticationMethodHTTPBasic</TT>.\n
	 *   <TT>NSURLAuthenticationMethodHTTPDigest</TT> is supported.\n
	 *   <TT>NSURLAuthenticationMethodNTLM</TT> is supported, specifically: NTLMv1,
	 *   NTLMv2, and NTLM2 Session.\n
	 *   <TT>NSURLAuthenticationMethodNegotiate</TT> is supported for Kerberos
	 *   version 5.
	 * - When Kerberos authentication is in use, note the following:
	 *   - Credentials are initially taken in the same way as other credentials,
	 *     with the same specified persistence.
	 *   - The credentials will be a username in the form
	 *     <EM>user</EM><TT>\@</TT><EM>realm</EM>, and a password.
	 *   - The credentials are used to request Kerberos tickets, which are stored.
	 *   - The stored Kerberos tickets are then used to authenticate the user on
	 *     any site that supports Kerberos authentication. So long as the ticket
	 *     continues to be accepted, there is no need for credentials to be supplied
	 *     again, and no authentication challenge.
	 *   - This continues until a site does not accept the stored ticket (e.g. the
	 *     ticket has expired and cannot be renewed).
	 *   - The Kerberos realm must be accessible. Usually, this means that the
	 *     Kerberos realm must be listed as an Additional Server in the Good
	 *     Control console. See the \ref GC.
	 *   - Kerberos delegation can be allowed or disallowed. See
	 *     \link GDCacheController::kerberosAllowDelegation:\endlink.
	 *   .
	 * - Authorization credentials are persisted as per the
	 *   <TT>NSURLCredentialPersistence</TT> flag of <TT>NSURLCredential</TT>:\n
	 *   <TT>NSURLCredentialPersistenceNone</TT> credential is used for this
	 *   connection only\n
	 *   <TT>NSURLCredentialPersistenceForSession</TT> credential is persisted in
	 *   memory\n
	 *   <TT>NSURLCredentialPersistencePermanent</TT> treated as
	 *   <TT>NSURLCredentialPersistenceForSession</TT>\n
	 * - The Good Dynamics secure store is utilized, as follows:
	 *   - Browser cookies are persisted in the secure store. See HTTP Cookie
	 *     Handling below.
	 *   - The default store is not used to cache retrieved files. Instead, a
	 *     separate secure cache is used.
	 *   - Kerberos tickets are persisted on the device in the secure store.
	 *   .
	 *   General access to these secure stores by the application is not
	 *   supported, but see \ref GDCacheController.
	 * - Data communication does not go via the proxy specified in the device's
	 *   native settings, if any.
	 * - The value <TT>YES</TT> is assumed for the <TT>setAllowsCellularAccess</TT>
	 *   flag. See the <A
	 *     HREF="http://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSMutableURLRequest_Class"
	 *     target="_blank"
	 *   >NSMutableURLRequest class reference</A > in the iOS Developer Library on
	 *   apple.com for details of this flag.
	 * .
	 *  \htmlonly </div> \endhtmlonly
	 *
	 * Additional features are made available, using the
	 * \ref NSMutableURLRequest(GDNET) category, and the \ref NSURLCache(GDURLCache)
	 * subclass.
	 *
	 * \see \ref GDiOS, for Good Dynamics authorization
	 * \see \ref background_execution
	 * \see <A HREF="https://community.good.com/docs/DOC-1061" target="_blank" >Good Dynamics Administrator and Developer Overview</A > for an introduction to Good Dynamics.
	 * \see \ref GC, under Registering an Application, for how to list a server
	 *
	 * <H3>Multiple Authentication Methods</H3>
	 * An HTTP server may support multiple authentication methods. For example, a
	 * server could support both NTLM and Kerberos authentication. By default, the
	 * GD Runtime handles this by selecting the first authentication method
	 * presented.
	 *
	 * The application can implement its own handling for multiple authentication
	 * methods, as follows:
	 * -# Add a new row to the application's Info.plist fi<TT></TT>le:
	 *     - Key: <TT>GDRejectAuthSupport</TT>
	 *     - Type: <TT>Boolean</TT>
	 *     - Value: <TT>YES</TT>
	 *     .
	 *     (In case there are multiple Info.plist files, check that the correct one
	 *     has been edited by opening the Info tab of the application target being
	 *     built. The setting just made should appear there.)
	 * -# Implement a <TT>connection::willSendRequestForAuthenticationChallenge</TT>
	 *    callback.
	 * -# In the application code for the callback, call the
	 *    <TT>rejectProtectionSpaceAndContinueWithChallenge</TT> function, where
	 *    necessary.
	 * .
	 * The following code snippet illustrates a simple implementation of the
	 * callback mentioned in the above.
	 * \code
	 * public void SendRequestForAuthenticationChallend (NSUrlConnection connection, NSUrlAuthenticationChallenge challenge)
	 *	{
	 *		if (challenge.ProtectionSpace.AuthenticationMethod != NSUrlProtectionSpace.AuthenticationMethodNTLM) {
	 *			challenge.Sender.RejectProtectionSpaceAndContinue (challenge);
	 *		} else {
	 *			NSUrlCredential cred = new NSUrlCredential ("abc", "abc", NSUrlCredentialPersistence.ForSession);
	 *			challenge.Sender.UseCredential (cred, challenge);
	 *		}
	 *	}
	 * \endcode
	 * \see <A
	 *     HREF="http://developer.apple.com/library/ios/#documentation/Foundation/Reference/NSURLConnectionDelegate_Protocol/Reference/Reference.html"
	 *     target="_blank"
	 * >NSURLConnectionDelegate protocol reference</A> in the iOS Developer Library
	 * on apple.com
	 *
	 * <H3>HTTP Cookie Handling</H3>
	 * By default, HTTP cookies received through Good Dynamics secure communication
	 * are handled automatically:
	 * - Set-cookie: headers that are received as part of an HTTP response are
	 *   processed and then added to subsequent matching requests.
	 * - Persistent cookies are written to cookie storage in the Good Dynamics
	 *   secure store. Storage takes place when the request's ready state becomes
	 *   <TT>GDHttpRequest_DONE</TT>, if <TT>GDHttp</TT><TT>Request</TT> is in use.
	 * .
	 * The Good Dynamics cookie store persists between executions of the
	 * application, and if the mobile device is switched off. The contents of the
	 * store can be managed with the native <TT>NSHTTPCookieStorage</TT> API, as can
	 * non-persistent cookies received through Good Dynamics secure communication.
	 *
	 * Automatic handling of HTTP cookies received through Good Dynamics secure
	 * communication can be disabled, as follows:
	 * - For <TT>GDHttp</TT><TT>Request</TT>, call the
	 *   <TT>DisableCookieHandling</TT> function in the
	 *   <TT>GDHttp</TT><TT>Request</TT> class.
	 * - For <TT>GDURLLoad</TT><TT>ingSystem</TT>, call the
	 *   <TT>DetHTTPShouldHandleCookies:</TT> function in the native
	 *   <TT>NSMutableURLRequest</TT> class, as usual.
	 * .
	 * \see <A
	 *     HREF="http://developer.apple.com/library/ios/#documentation/Cocoa/Reference/Foundation/Classes/NSHTTPCookieStorage_Class/Reference/Reference.html"
	 *     target="blank"
	 * >NSHttpCookieStorage class reference</A> in the iOS Developer Library on
	 * apple.com
	 * \see <A
	 *     HREF="http://developer.apple.com/library/ios/#documentation/Cocoa/Reference/Foundation/Classes/NSMutableURLRequest_Class/Reference/Reference.html"
	 *     target="blank"
	 * >NSMutableURLRequest class reference</A> in the iOS Developer Library on
	 * apple.com
	 */
	[BaseType (typeof(NSObject))]
	public interface GDURLLoadingSystem
	{
		/// <summary>
		/// </summary>
		[Static, Export ("enableSecureCommunication")]
		void EnableSecureCommunication ();

		/**< Enable access across the enterprise firewall via the URL Loading System.
		 * Call this function to enable, or re-enable, access across the enterprise
		 * firewall via the URL Loading System.
		 *
		 * Access across the enterprise firewall is provided by the Good Dynamics
		 * proxy infrastructure. Only servers that have been specifically listed in the
		 * Good Control console are accessible. See under Registering an Application
		 * in the \ref GC for how to list a server.
		 *
		 * Access is enabled by default during authorization processing, which is
		 * initiated by the  \link GDiOS.Authorize Authorize (GDiOS)\endlink function. The
		 * <TT>EnableSecure</TT><TT>Communication</TT> function need only be called if
		 * access was disabled after authorization, see the
		 * \ref disableSecureCommunication function, below.
		 */

		/// <summary>
		/// </summary>
		[Static, Export ("disableSecureCommunication")]
		void DisableSecureCommunication ();

		/**< Disable access across the enterprise firewall via the URL Loading System.
		 * Call this function to disable access across the enterprise firewall via the
		 * URL Loading System.
		 *
		 * Access can be re-enabled using the \ref enableSecureCommunication function.
		 * Access will also be re-enabled during authorization processing, which is
		 * initiated by the  \link GDiOS.Authorize Authorize (GDiOS)\endlink function.
		 *
		 * Calling this function has no impact on access across the firewall using
		 * \ref GDHttpRequest.
		 */
		 
		/// <summary>
		/// </summary>
		[Static, Export ("isSecureCommunicationEnabled")]
		bool IsSecureCommunicationEnabled ();
		/**< Check whether access across the enterprise firewall via the URL Loading
		 *   System is enabled.
		 * Call this function to check whether access across the enterprise firewall via
		 * the URL Loading System is enabled.
		 *
		 * Access can be re-enabled using the \ref EnableSecureCommunication function.
		 * Access will also be re-enabled during authorization processing, which is
		 * initiated by the  \link GDiOS.Authorize Authorize (GDiOS)\endlink function.
		 *
		 * Calling this function has no impact on access across the firewall using
		 * \ref GDHttpRequest.
		 *
		 * \return <TT>true</TT> if access is enabled.
		 * \return <TT>false</TT> otherwise.
		 */
	}

	/// <summary>
	/// </summary>
	/** Control the secure authentication cache.
	 * Use this class to control the secure authentication caches of the
	 * \ref GDURLLoadingSystem and \ref GDHttpRequest classes. (Currently, there are
	 * only two controls.)
	 * The secure authentication cache is used by these classes as follows:<DL
	 * ><DT>GD URL Loading System</DT><DD
	 * >Stores credentials for all authentication methods.\n
	 * Stores tickets for Kerberos authentication.</DD
	 * ><DT>GD HTTP Request</DT><DD
	 * >Stores tickets for Kerberos authentication.</DD
	 * ></DL>
	 */
	[BaseType (typeof(NSObject))]
	public interface GDCacheController
	{
		/// <summary>
		/// </summary>
		[Static, Export ("clearCredentialsForMethod:")]
		void ClearCredentialsForMethod (string method);

		/**< Clear cached authentication credentials.
		 * Call this function to clear the cached credentials for a particular
		 * authentication method, or to clear for all methods.
		 * Calling this function clears the session cache, and the permanent cache if
		 * present. (Currently, the Good Dynamics Runtime only has a permanent
		 * cache for Kerberos authentication tickets.)
		 *
		 * \param method
		 * One of the following constants, specifying which cache or
		 * caches are to be cleared:\n
		 * <TT>NSURLAuthenticationMethodHTTPBasic</TT>
		 * clears Basic Authentication credentials,\n
		 * <TT>NSURLAuthenticationMethodDefault</TT>
		 * also clears Basic Authentication credentials,\n
		 * <TT>NSURLAuthenticationMethodHTTPDigest</TT>
		 * clears Digest Authentication credentials,\n
		 * <TT>NSURLAuthenticationMethodNTLM</TT>
		 * clears NTLM Authentication credentials,\n
		 * <TT>NSURLAuthenticationMethodNegotiate</TT>
		 * clears Kerberos Authentication credentials and tickets,\n
		 * <TT>nil</TT>
		 * clears all of the above.
		 */

		[Static, Export ("kerberosAllowDelegation:")]
		void KerberosAllowDelegation (bool allow);
		/**< Allow or disallow Kerberos delegation.
		 * Call this function to allow or disallow Kerberos delegation within
		 * Good Dynamics secure communications. By default, Kerberos delegation is not
		 * allowed.
		 *
		 * When Kerberos delegation is allowed, the Good Dynamics Runtime behaves as
		 * follows:
		 * - Kerberos requests will be for tickets that can be delegated.
		 * - Application servers that are trusted for delegation can be sent tickets
		 *   that can be delegated, if such tickets were issued.
		 * .
		 *
		 * When Kerberos delegation is not allowed, the Good Dynamics Runtime behaves as
		 * follows:
		 * - Kerberos requests will not be for tickets that can be delegated.
		 * - No application server will be sent tickets that can be delegated, even if
		 *   such tickets were issued.
		 * .
		 *
		 * After this function has been called, delegation will remain allowed or
		 * disallowed until this function is called again with a different setting.
		 *
		 * Note: User and service configuration in the Kerberos Domain Controller
		 * (typically a Microsoft Active Directory server) is required in order for
		 * delegation to be successful. On its own, calling this function will not
		 * make Kerberos delegation work in the whole end-to-end application.
		 * 
		 * When this function is called, the Kerberos ticket and credentials caches
		 * will be cleared. I.e. there is an effective call to the
		 * \link GDCacheController.ClearCredentialsForMethod
		 * ClearCredentialsForMethod:\endlink function with an <TT
		 * >NSURLAuthenticationMethodNegotiate</TT> parameter.
		 *
		 * \param allow <TT>bool</TT> for the setting: <TT>true</TT> to allow delegation,
		 *              <TT>false</TT> to disallow.
		 */
	}

	/// <summary>
	/// </summary>
	/** Delegate for handling GDPushConnection state transition.
	 * Errors and state changes that occur when using
	 * \link GDPushConnection GDPushConnection\endlink are handled by creating a class that implements
	 * this protocol.
	 *
	 *  <H2>Code Snippets</H2> The following code snippets illustrate some common tasks.
	 * <H3>Print State-Change</H3>
	 * \code
	 * public class BasicHandler : GDPushConnectionDelegate
	 * {
	 * 		public void OnStatus(int status)
	 * 		{
	 *			if (GDPushConnection.SharedConnection.IsConnected){
	 *         		Console.WriteLine("Connected OK. Push Channel service available.");
	 *     		}
	 *     		else {
	 *         		Console.WriteLine("Push Channel service not available.");
	 *			}
	 *     	}
	 * }
	 * @end
	 * \endcode
	 * The above snippet shows a very simple handler for \link GDPushConnection GDPushConnection\endlink
	 * state-change. The availability of the Push Channel service is written to the
	 * system log.
	 *
	 * <H3>Set Event Handler</H3>
	 * \code
	 * basicDelegate = new BasicHandler();
	 * connection.delegate = basicDelegate;
	 * \endcode
	 * The above snippet shows how the above handler could be associated with the
	 * Push Connection.
	 */
	[Model, BaseType (typeof(NSObject))]
	public interface GDPushConnectionDelegate
	{
		/// <summary>
		/// </summary>
		[Export ("onStatus:")]
		void OnStatus (int status);
		/**< Callback for all status changes.
		 * The callback is invoked when the Push Connection changes state, or
		 * when an error occurs.
		 *
		 * The function that is invoked could call
		 *  \link GDPushConnection.IsConnected IsConnected\endlink to determine the availability of the
		 * following features:
		 * - Push Channel service
		 * - Communication through the Good Dynamics proxy infrastructure
		 * .
		 * If the features are available (i.e. <TT>IsConnected</TT> returns <TT>true</TT>),
		 * then any of the following actions that were waiting could now proceed:
		 * - Establishing a Push Channel, see \link GDPushChannel.Connect Connect\endlink
		 * - Opening a socket connection to an enterprise server, see
		 * \ref GDSocket.Connect
		 * - Sending an HTTP request to an enterprise server, see
		 * \ref GDHttpRequest.Send
		 * .
		 * If the features are not available (i.e. <TT>IsConnected</TT> returns
		 * <TT>false</TT>) then the function that is invoked could alert the user, or
		 * display this as an ongoing state.
		 * In this state, Push Channel notifications would not be received.
		 *
		 * \param status Internal numeric code for the new status.
		 * Specific values are not documented, and should not be relied upon.
		 *
		 * During establishment or termination of the Push Connection with the Good
		 * Dynamics proxy infrastructure, see <TT>GDPush</TT><TT>Connection</TT>
		 *  \link GDPushConnection.Connect Connect\endlink and  \link GDPushConnection.Disconnect Disconnect\endlink,
		 * the callback will be invoked a number of times, as the action progresses.
		 *
		 * Events that have an impact on the state of the Push Connection also
		 * result in the callback being invoked. This would include loss of
		 * network coverage and other losses of data connection, as well as the
		 * subsequent automatic re-establishment of the connection.
		 */
	}

	/// <summary>
	/// </summary>
	/** Manage Push Channel connection.
	 * This API is part of the Good Dynamics Push Channel feature.
	 * For an overall description of how to use the feature, see under
	 * \link GDPushChannel GDPushChannel\endlink.
	 *
	 * The Push Connection is the container and conduit for the device's Push
	 * Channels. An application may open multiple Push Channels; all will be
	 * managed within a single Push Connection.
	 *
	 * The Push Connection is automatically established during Good Dynamics
	 * authorization processing, and then maintained by the Good Dynamics
	 * Runtime under application control.
	 * The application can instruct the runtime to switch the Push Connection
	 * off and on.
	 *
	 * When instructed to switch off, the GD Runtime will terminate the Push
	 * Connection, and suspend its maintenance. When instructed to switch
	 * back on, the GD Runtime will re-establish the Push Connection, and
	 * resume maintenance.
	 *
	 * Switching off the Push Connection might be an option that the application
	 * offers to the end user, for example, allowing them to
	 * reduce power consumption on the device.
	 *
	 * Push Connection functions cannot be called until Good Dynamics
	 * authorization processing is complete.
	 * \see \link GDPushChannel GDPushChannel\endlink
	 * \see \link GDiOS\endlink, for Good Dynamics authorization
	 * \see \ref threads
	 * \see \ref background_execution
	 *
	 * <H3>Push Channel Network</H3>
	 * The Push Connection is a link between the mobile application and the Good
	 * Dynamics proxy infrastructure Network Operation Center (NOC).
	 * The Push Channel is a link between the mobile application and its application
	 * server (App Server). There can be more than one Push Channel; the mobile
	 * application can receive push communications from more than one App Server.
	 * Push Channels are mediated by the NOC, and sometimes other proxy
	 * infrastructure elements.
	 *
	 * This is shown in the following diagram.
	 *  \image html "Push Channel network.png"
	 \image rtf "Push Channel network.png"
	
	 *
	 * <H3>API Overview</H3>
	 * The GD Push Connection API consists of a small number of functions that must
	 * be used in a particular order. Whilst some other APIs are general-purpose
	 * toolkits, the Push Connection API has only a single purpose: to enable
	 * the Push Channel API.
	 *
	 * The normal sequence of operations is as follows.
	 * -# Application started.
	 * -# Good Dynamics initialization and authorization, see under \link GDiOS\endlink.
	 * -# When the application needs a Push Channel...
	 * -# Call
	 *  \link GDPushConnection.SharedConnection SharedConnection\endlink 
	 * to access the Push Connection object,
	 * -# Call  \link GDPushConnection.IsConnected IsConnected\endlink to check the connection state,
	 * -# If the state is not connected:
	 *   -# Set a  \link GDPushConnectionDelegate GDPushConnectionDelegate\endlink to handle connection state changes
	 *   -# Call  \link GDPushConnection.Connect Connect\endlink to ensure that connection is
	 *      being attempted,
	 *   -# When the  \link GDPushConnectionDelegate.OnStatus OnStatus\endlink callback in the
	 *      handler is invoked, go back and check the connection state again.
	 * -# If the state is connected, proceed to setting up a Push Channel.
	 * .
	 * For details of Push Channel set-up, see under \link GDPushChannel GDPushChannel\endlink.
	 *
	 *  <H2>Code Snippets</H2> The following code snippets illustrate some common tasks.
	 * <H3>Terminate Push Connection</H3>
	 * \code
	 * GDPushConnection.SharedConnection.Disconnect();
	 * \endcode
	 * After the disconnect, the connection can be re-opened later.
	 *
	 * <H3>Re-open Push Connection</H3>
	 * \code
	 * if (!GDPushConnection.SharedConnection.IsConnected) {
	 *     myHandler = new AppHandler();
	 *     myConnection.Delegate = myHandler;
	 *     myConnection.Connect();
	 * }
	 * \endcode
	 * The above snippet shows a check for whether the Push Channel service is
	 * already available. If it is not, then a connection is initiated.
	 * The connection attempt is asynchronous. The <TT>OnStatus</TT>
	 * callback would be invoked, with <TT>IsConnected</TT> returning <TT>YES</TT>,
	 * when the attempt succeeds (not shown). See  \link GDPushConnectionDelegate GDPushConnectionDelegate\endlink.
	 */
	[BaseType (typeof(NSObject))]
	public interface GDPushConnection
	{
		/// <summary>
		/// </summary>
		[Static, Export ("sharedConnection")]
		NSObject SharedConnection { get; }

		/**< Get a reference to the Push Connection object.
		 * This function returns a reference to the Push Connection object.
		 *
		 * The Push Connection object is a "singleton class".
		 *
		 * \return Reference that can be used to call, for example,
		 * the <TT>IsConnected</TT> function.
		 */

		/// <summary>
		/// </summary>
		[Export ("connect")]
		void Connect ();

		/**< Initiate connection to the overall Push Channel service.
		 * Call this function to establish, or re-establish, the Push
		 * Channel connection with the Good Dynamics proxy infrastructure Network
		 * Operation Center (NOC).
		 *
		 * Establishing the connection involves a number of messages being
		 * exchanged with the NOC. The <TT>OnStatus</TT> callback in the
		 * delegate will be invoked as this progresses.
		 *
		 * If mobile data coverage is lost after this function has been called,
		 * the Push Channel connection will stop operating.
		 * The Good Dynamics Runtime will automatically attempt to re-establish
		 * the Push Channel connection when coverage is regained.
		 * The Good Dynamics Runtime uses the native
		 * System Configuration feature to
		 * be notified of coverage status.
		 * 
		 */

		/// <summary>
		/// </summary>
		[Export ("disconnect")]
		void Disconnect ();

		/**< Terminate the connection to the Push Channel service.
		 * Call this function to terminate the Push Channel connection with
		 * the Good Dynamics proxy infrastructure Network Operation Center (NOC).
		 *
		 * If the connection was open and operating, termination will result in the
		 * <TT>OnStatus</TT> callback in the delegate being
		 * invoked.
		 * 
		 */

		/// <summary>
		/// </summary>
		[Export ("isConnected")]
		bool IsConnected { get; }

		/**< Get state of the connection to the Push Channel service.
		 * This function returns the current status of the Push
		 * Channel connection.
		 * \return <TT>true</TT> if the Push Channel connection is open and operating, and
		 * the Push Channel service is available.
		 * \return <TT>false</TT> otherwise.
		 * 
		 */

		/// <summary>
		/// </summary>
		[Export ("delegate", ArgumentSemantic.Assign)]
		GDPushConnectionDelegate Delegate { get; set; }
		/**< Delegated event-handling.
		 * The Push Connection object works asynchronously.
		 * When its state changes, an event is generated by the Good Dynamics Runtime,
		 * and passed to a callback function in the application.
		 *
		 * Set this property to an instance of a class that contains the code for the
		 * required callback function, i.e. a class that implements the
		 *  \link GDPushConnectionDelegate GDPushConnectionDelegate\endlink protocol.
		 */
	}

	/// <summary>
	/// </summary>
	/** Delegate for handling GDPushChannel state transitions and received Push Channel notifications.
	 * State changes that occur when using \link GDPushChannel GDPushChannel\endlink
	 * are handled by creating a class that implements this protocol.
	 * The callback for handling received Push Channel notifications is also part
	 * of this protocol.
	 * \see \ref st01pushchannel
	 *
	 *  <H2>Code Snippets</H2> The following code snippets illustrate some common tasks.
	 * <H3>Receive Push Channel Token</H3>
	 * \code
	 * public void OnChannelOpen(string channel)
	 * {
	 *     Console.WriteLine(String.Format("OnChannelOpen token: {0}", token));
	 *     myApp.PushIsOpen = true;
	 *     myApp.PushToken = token;
	 *     myApp.SendPushToken();
	 * }
	 * \endcode
	 * The above snippet shows a simple <TT>OnChannelOpen</TT> handler. The
	 * following takes place when the Push Channel is opened:
	 * - The token is logged to the system monitor
	 * - The application's channel state is flagged as connected
	 * - The token is stored in the application
	 * - The application's <TT>SendPushToken</TT> function is called
	 *
	 * The <TT>SendPushToken</TT> function, which would be written by the
	 * application developer, would send the token to the
	 * application server. This could use a socket, an HTTP
	 * request, or another means of communication. From the Push Channel
	 * point of view, this is an out-of-band communication.
	 *
	 * The server will use the token to address Push Channel notification messages
	 * back to the mobile application. These would be received by the mobile
	 * application's onChannelMessage handler.
	 *
	 * <H3>Receive Push Channel notification</H3>
	 * \code
	 * public void OnChannelMessage(string data)
	 * {
	 *     Console.WriteLine(String.Format("OnChannelMessage: {0}", data));
	 *     myApp.ProcessPush(data);
	 * }
	 * \endcode
	 * The above snippet shows a simple <TT>OnChannelMessage</TT> handler.
	 *
	 * The handler logs the received data to the system monitor, then calls the
	 * application <TT>ProcessPush</TT> function. The "payload" of the notification
	 * is passed as a parameter to the <TT>ProcessPush</TT> function.
	 *
	 * The <TT>ProcessPush</TT> function, which would be written by the
	 * application developer, could initiate any of the following actions:
	 * - Alert the user that new data is available.
	 * - Connect to the application server to retrieve the data. (Connection
	 * could use a socket, an HTTP
	 * request, or another means of communication. From the Push Channel
	 * point of view, this is an out-of-band communication.)
	 *
	 * <H3>Handle Channel Closure</H3>
	 * \code
	 * public void OnChannelClose(string data)
	 * {
	 *     Console.WriteLine(String.Format("OnChannelClose: {0}", data));
	 *     myApp.PushIsOpen = false;
	 *     myApp.DiscardPushToken(data);
	 * }
	 * \endcode
	 * The above snippet shows a simple <TT>OnChannelClose</TT> handler. The
	 * following takes place when the Push Channel is closed:
	 * - The token is logged to the system monitor
	 * - The application's channel state is flagged as not connected
	 * - The application <TT>DiscardPushToken</TT> function is called. The
	 * token of the closed channel is passed as a parameter.
	 *
	 * The <TT>DiscardPushToken</TT> function would delete the application's
	 * copy of the token, possibly after checking that it matches the
	 * <TT>whichWas</TT> parameter.
	 * The function could also initiate connection of a new Push Channel, which
	 * would have a new token. See \link GDPushChannel.Connect Connect\endlink.
	 *
	 * <H3>Handle Channel Error</H3>
	 * \code
	 * public void OnChannelError(int error)
	 * {
	 *     Console.WriteLine(String.Format("OnChannelError: {0}", error));
	 *     myApp.PushIsOpen = false;
	 *     myApp.PushErr = error;
	 *     myApp.DiscardPushToken();
	 * }
	 * \endcode
	 * The above snippet shows a simple <TT>OnChannelError</TT> handler.
	 *
	 * The handler logs the error code to the system monitor, flags
	 * the channel's state as not connected, records the error code in
	 * the application, then calls the application <TT>DiscardPushToken</TT>
	 * function.
	 *
	 * The <TT>DiscardPushToken</TT> function could do any of the following:
	 * - Delete the application's copy of the token.
	 * - Set the error state in an ongoing status display.
	 * - Depending on the error code, initiate connection of a new
	 * Push Channel, which would have a new token. See \link GDPushChannel.Connect Connect\endlink.
	 *
	 * <H3>Handle Ping Failure</H3>
	 * See under  \link GDPushChannelDelegate.OnChannelPingFail: OnChannelPingFail\endlink
	 * for an explanation of the Ping Failure feature.
	
	 * \code
	 * public void OnChannelPingFail(int error)
	 * {
	 *     Console.WriteLine(String.Format("OnChannelPingFail {0}", error));
	 *     if ( error == 605 ) {
	 *         myApp.ResendPushToken();
	 *     }
	 * }
	 * \endcode
	 * The above snippet shows a simple <TT>OnChannelPingFail</TT> handler.
	 *
	 * The handler logs the error code to the system monitor,
	 * then calls the application <TT>ResendPushToken</TT> function if the
	 * token was lost.
	 *
	 * The <TT>ResendPushToken</TT> function, which would be written by the
	 * application developer, would send the application's stored token to the
	 * application server. This could use a socket, an HTTP
	 * request, or another means of communication. From the Push Channel
	 * point of view, this is an out-of-band communication.
	 *
	 * The <TT>ResendPushToken</TT> function should expect that the server is
	 * not immediately available, perhaps employing a retry policy.
	 */
	[Protocol, Model, BaseType (typeof(NSObject))]
	public interface GDPushChannelDelegate
	{
		/// <summary>
		/// </summary>
		[Export ("onChannelOpen:")]
		void OnChannelOpen (string token);

		/**< Channel opened callback.
		 * This callback will be invoked when the associated Push Channel is
		 * opened in the Good Dynamics proxy infrastructure. See 
		 * \link GDPushChannel.Connect Connect\endlink. At this point, a Push
		 * Channel token will have been issued by the Good Dynamics proxy
		 * infrastructure Network Operation Center (NOC).
		 *
		 * The function that is invoked must initiate sending of the token to
		 * the application server, out of band.
		 * The application server will then be able to use the token to address
		 * Push Channel notifications back to the application on the device,
		 * via the NOC.
		 *
		 * \see \ref GNP
		 *
		 * Invocation of this callback also notifies the application on the device
		 * that any of the following callbacks could now be invoked:
		 * <TT>OnChannelMessage</TT>, <TT>OnChannelPingFail</TT>, <TT>OnChannelClose</TT>.
		 *
		 * \param token <TT>string</TT> containing the
		 * Push Channel token issued by the NOC.
		 */

		/// <summary>
		/// </summary>
		[Export ("onChannelMessage:")]
		void OnChannelMessage (string data);

		/**< Push Channel notification callback.
		 * This callback will be invoked when a Push Channel notification is
		 * received on the associated Push Channel. The message will have been sent by the
		 * application server, using the Push Channel notify service, which is hosted
		 * by the Good Dynamics Network Operation Center (NOC).
		 *
		 * The service supports a "payload" of data to be included in the notification.
		 * The data could be in any format chosen by the application developer.
		 * The payload could also be empty.
		 *
		 * Note that Push Channel notifications can be received at any time when
		 * the channel is open, and the Push Connection is open and operating.
		 * This includes the interval between the request for disconnection
		 * (<TT>Disconnect</TT> called) and channel disconnection being finalized
		 * (<TT>OnChannelClose</TT> received).
		 *
		 * The function that is invoked could initiate the following actions:
		 * - Alert the user that new data is available.
		 * - Connect to the application server to retrieve the data.
		 * .
		 *
		 * \param data <TT>string</TT> containing the data
		 * payload included by the application server, encoded in UTF-8.
		 *
		 * \note
		 * Because of this callback, the mobile application code does not need to
		 * maintain a constant connection with the server. This is an important benefit
		 * of using the Good Dynamics Push Channel framework.
		 * \see \link GDPushConnection GDPushConnection\endlink
		 * \see \ref GNP
		 */

		/// <summary>
		/// </summary>
		[Export ("onChannelClose:")]
		void OnChannelClose (string data);

		/**< Channel closed callback.
		 * This callback will be invoked when the associated Push Channel is
		 * closed.
		 * This means closed by the remote end, or by the application having
		 * called \link GDPushChannel.Disconnect Disconnect\endlink.
		 *
		 * Invocation of this callback notifies the application on the device
		 * that:
		 * - The associated Push Channel token cannot be used any more
		 * - No more Push Channel notifications will be received on this channel
		 *
		 * If the <TT>OnChannelClose</TT> was not expected, the function that is
		 * invoked could alert the user that Push Channel notifications will not be
		 * received, or cause this to be displayed as an ongoing state.
		 * The function could also initiate release of the Push Channel object.
		 * Alternatively, reconnection could be initiated, see
		 * \link GDPushChannel.Connect Connect\endlink.
		 *
		 * \param data Token for the Push Channel that was closed.
		 *
		 * Note that this callback is only invoked for permanent Push Channel closure.
		 * This callback is not invoked for transient losses of channel communication.
		 * For example, this callback is not invoked when the mobile device loses
		 * packet data coverage or otherwise cannot connect to the Good Dynamics proxy
		 * infrastructure.
		 * Losses of connection, which affect all Push Channels, can be monitored
		 * by the GD Push Connection event handler. See  \link GDPushConnectionDelegate GDPushConnectionDelegate\endlink.
		 */

		/// <summary>
		/// </summary>
		[Export ("onChannelError:")]
		void OnChannelError (int error);

		/**< Generic channel error callback.
		 * This callback is invoked when a permanent error condition is encountered on
		 * the associated Push Channel.
		 *
		 * Invocation of this callback notifies the application that the Push
		 * Channel token cannot be used any more, or that the channel could not
		 * be connected in the first place. Furthermore, no (more) Push Channel
		 * notifications will be received on this channel.
		 *
		 * The function that is invoked could alert the user that Push Channel
		 * notifications will not be received, or cause this to be displayed as an
		 * ongoing state.
		 * The function that is invoked should initiate reconnection, see
		 * \link GDPushChannel.Connect Connect\endlink, after checking that the Push Channel service is
		 * available, see  \link GDPushConnection.IsConnected IsConnected\endlink.
		 *
		 * \param error Reason code for the condition encountered,
		 * as follows.<TABLE
		 *     ><TR><TH>error</TH><TH>Channel Error reason</TH
		 *     ></TR><TR><TD
		 *         >0</TD
		 *     ><TD
		 *         >Push is not currently connected.</TD
		 *     ></TR><TR><TD
		 *         >200-499</TD
		 *     ><TD
		 *         >Internal error.</TD
		 *     ></TR><TR><TD
		 *         >500-599</TD
		 *     ><TD
		 *         >Internal server error.</TD
		 *     ></TR
		 * ></TABLE>
		 */
 
		/// <summary>
		/// </summary>
		[Export ("onChannelPingFail:")]
		void OnChannelPingFail (int error);
		/**< Specific Ping Failure callback.
		 * This callback is invoked when Ping Failure is encountered on
		 * the associated Push Channel.
		 *
		 * \par Ping Failure
		 * Ping Failure is an optional feature of the Push Channel
		 * framework.
		 * The application server registers for ping after receiving the Push Channel
		 * token from the mobile application.\n
		 * If an application server registers for ping, then the
		 * server will be periodically checked ("pinged") by the Good Dynamics
		 * Network Operation Center (NOC).
		 * If the server does not respond to a ping, then the NOC notifies the mobile
		 * application.\n
		 * The purpose of this feature is to support servers that lose the Push Channel
		 * token when they are restarted.
		 *
		 * The function that is invoked should initiate resending of the Push
		 * Channel token to the application server, if the token has been lost. This is
		 * similar to the processing when the channel is initially opened, see
		 *  \link GDPushChannelDelegate.OnChannelOpen OnChannelOpen\endlink. If the application server is
		 * able to accept the token, then Push Channel notification can resume.
		 *
		 * \see \ref GNP
		 *
		 * Note that Ping Fail notifications can be received at any time when
		 * the channel is open.
		 * This includes the interval between the request for disconnection
		 * (<TT>Disconnect</TT> called) and channel disconnection being finalized
		 * (<TT>OnChannelClose</TT> received).
		 *
		 * \param error Reason code for the condition encountered,
		 * as follows.<TABLE>
		 *     <TR><TH>error</TH><TH>Ping Failure reason</TH
		 *     ></TR><TR><TD
		 *         >600</TD
		 *     ><TD
		 *         >Application server address could not be resolved via DNS</TD
		 *     ></TR><TR><TD
		 *         >601</TD
		 *     ><TD
		 *         >Could not connect to application server address</TD
		 *     ></TR><TR><TD
		 *         >602</TD
		 *     ><TD
		 *         >Application server TLS/SSL certificate invalid</TD
		 *     ></TR><TR><TD
		 *         >603</TD
		 *     ><TD
		 *         >Timed out waiting for application server HTTP response</TD
		 *     ></TR><TR><TD
		 *         >604</TD
		 *     ><TD
		 *         >Application server returned an invalid response</TD
		 *     ></TR><TR><TD
		 *         >605</TD
		 *     ><TD
		 *         >Application server indicated that token is unknown</TD
		 *     ></TR>
		 * </TABLE>
		 * Note that only error 605 means that the token has been lost and must be
		 * resent.
		 */
	}

	/// <summary>
	/// </summary>
	/** Manage Push Channel tokens and notifications.
	 * The Push Channel framework is a Good Dynamics (GD) feature
	 * used to receive notifications from an application server.
	 *
	 * Note that the GD Push Channel feature is not part of the native iOS
	 * notification feature set.
	 *
	 * Push Channels cannot be established until Good Dynamics authorization
	 * processing is complete.
	 * In addition, Push Channels are dependent on the Push Connection.
	 * Push Channels can only be established when the Push Connection is open and
	 * operating.
	 *
	 * Push Channel data communication does not go via the proxy specified in the
	 * device's native settings, if any.
	 *
	 * \see \link GDPushConnection GDPushConnection\endlink
	 * \see <A HREF="https://community.good.com/docs/DOC-1061" target="_blank" >Good Dynamics Administrator and Developer Overview</A > for an introduction to Good Dynamics.
	 * \see \ref threads
	 * \see \ref background_execution
	 * \see <A
	 *     HREF="http://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Introduction/Introduction.html"
	 *     target="_blank"
	 * >Local and Push Notification Programming Guide</A> in the iOS Developer
	 * Library on apple.com
	 *
	 * <H3>Push Channel Usage</H3>
	 * Push Channels are established by the mobile application, then used by the
	 * server when needed. The sequence of events is as follows:
	 * -# The mobile application sets an event handler for Push Channel
	 *    notifications.
	 * -# The mobile application requests a Push Channel token from the Good
	 *    Dynamics proxy infrastructure.
	 * -# The mobile application sends the token to its server using, for example, a
	 *    socket or HTTP request.
	 * -# The mobile application can now wait for a Push Channel notification.\n\n
	 * Later, when the server has data for the user, the following steps take
	 * place:\n\n
	 * -# The server sends a Push Channel notification message through the Good
	 *    Dynamics proxy infrastructure. The message is addressed using the token.
	 * -# The message is sent on, to the device, and the waiting application's event
	 *    handler is invoked.\n\n
	 * Later, when the server has more data for the user, the following steps
	 * take place:\n\n
	 * -# The server sends another Push Channel notification message through the
	 *    Good Dynamics proxy infrastructure. The message is addressed using the
	 *    same token.
	 * -# The message is sent on, to the device, and the waiting mobile
	 *    application's event handler is invoked again.
	 * .
	 * (The above is also shown in the \ref sq01pushchannel.)
	 *
	 * The Good Dynamics platform keeps data communications between mobile
	 * application and server alive while the mobile application is waiting for a
	 * Push Channel notification. This is achieved by sending "heartbeat" messages
	 * at an interval that is dynamically optimized for battery and network
	 * performance.
	 *
	 * <H3>API Overview</H3>
	 * The Push Channel API is asynchronous and state-based.
	 * The application attaches its own event-handler callbacks to the
	 * Push Channel object.
	 * The callbacks are invoked when channel events occur, or when the channel
	 * changes state.
	 * Which API functions can be called by the application at any time also
	 * depend on the channel's state.
	 *
	 * Callbacks are attached through a delegate class.
	 * The states in which each callback may be expected to be invoked are
	 * detailed in the delegate class's documentation, see 
	 *  \link GDPushConnectionDelegate GDPushConnectionDelegate\endlink.
	 *
	 * The availability of API functions, and what actions take place,
	 * are detailed below, and summarized in the following table.
	 * The table also summarizes which callbacks may expect to be invoked
	 * in each state.
	 * <TABLE>
	 *     <TR><TH>State</TH><TH>Functions / Actions</TH><TH>Expected callbacks</TH
	 *
	 *     ></TR><TR><TD
	 *         >Prepared</TD
	 *     ><TD
	 *         >Application can call <TT>Connect</TT>: state becomes Connecting</TD
	 *     ><TD
	 *         >None</TD
	 *
	 *     ></TR><TR><TD
	 *         >Connecting</TD
	 *     ><TD
	 *         >Good Dynamics Runtime requests a new channel from the
	 *         Good Dynamics proxy infrastructure</TD
	 *     ><TD
	 *         ><TT>OnChannelError</TT>: new state is Failed\n
	 *         <TT>OnChannelOpen</TT>: new state is Open</TD
	 *
	 *     ></TR><TR><TD
	 *         >Open</TD
	 *     ><TD
	 *         >Application can call <TT>Disconnect</TT>: state becomes
	 *         Disconnecting</TD
	 *     ><TD
	 *         ><TT>OnChannelMessage</TT>: no state change\n
	 *         <TT>OnChannelPingFail</TT>: no state change\n
	 *         <TT>OnChannelClose</TT>: new state is Disconnected</TD
	 *
	 *     ></TR><TR><TD
	 *         >Disconnecting</TD
	 *     ><TD
	 *         >Good Dynamics Runtime requests the Good Dynamics proxy
	 *         infrastructure to close the channel</TD
	 *     ><TD
	 *         ><TT>OnChannelMessage</TT>: no state change\n
	 *         <TT>OnChannelPingFail</TT>: no state change\n
	 *         <TT>OnChannelClose</TT>:&nbsp;new&nbsp;state&nbsp;is&nbsp;Disconnected</TD
	 *
	 *     ></TR><TR><TD
	 *         >Disconnected</TD
	 *     ><TD
	 *         >Application can call <TT>Connect</TT>: state becomes Connecting</TD
	 *     ><TD
	 *         >None</TD
	 *
	 *     ></TR><TR><TD
	 *         >Failed</TD
	 *     ><TD
	 *         >Application can call <TT>Connect</TT>: state becomes Connecting</TD
	 *     ><TD
	 *         >None</TD
	 *     ></TR
	 * ></TABLE
	 * >The transitions in the above table are also shown in the
	 * \ref st01pushchannel.
	 * Note that an individual Push Channel might or might not be closed when the
	 * overall Push Connection is terminated.
	 *
	 * \see \ref GNP
	 * 
	 * <H3>Notification feature differences</H3>
	 * The capabilities of the GD Push Channel feature are different to the
	 * capabilities of the native iOS notification features in the following ways.
	 *
	 * Only native notifications can be received when the application is in
	 * background. This might change in a future release of iOS.
	 *
	 * In principle, native notifications alert the user, not the application.
	 * Having been alerted, the user may choose to open the application.
	 * GD Push Channel notifications alert the application, which in turn may alert
	 * the user.
	 *
	 * GD Push Channel notification messages can include a "payload" of application
	 * data from the server. The application data is conveyed by the proxy
	 * infrastructure from the server to the mobile application.
	 *
	 * Native push notifications are sent through the Apple Push Notification
	 * service (APNs). Native notifications may therefore be received whenever the
	 * device has a connection to the APNs.
	 * GD Push Channel notification messages are sent through the GD Push
	 * Connection, which is the mobile application's connection to the Good Dynamics
	 * proxy infrastructure. GD notifications may therefore be received whenever the
	 * Push Connection is open and operating.
	 *
	 *  <H2>Code Snippets</H2> The following code snippets illustrate some common tasks.
	 * <H3>Create Push Channel</H3>
	 * The following snippet shows a Push Channel being created as soon as the
	 * Push Connection is ready. In this case, the code to create the Push Channel
	 * is in the Push Connection's state-change handler, see also
	 *  \link GDPushConnectionDelegate GDPushConnectionDelegate\endlink
	 * \code
	 * public void OnStatus(int status)
	 * {
	 * 		Console.WriteLine(String.Format("OnStatus {0}!", status));
	 *		if(GDPushConnection.SharedConnection.IsConnected){
	 *			Console.WriteLine("Push Channel service available");
	 *			myChannel = new GDPushChannel();
	 *			myHandler = new AppChannelHandler();
	 *			myChannel.Delegate = myHandler;
	 *			myChannel.Connect();
	 *		}
	 * }
	 * \endcode
	 * The above snippet shows the following taking place when the Push Channel
	 * service becomes available:
	 * - Availability logged to the system monitor
	 * - Allocation and preparation of a Push Channel object
	 * - Allocation and preparation of a Push Channel event handler
	 * - Association of the handler with the new Push Channel object
	 * - Initiation of Push Channel connection
	 * .
	 * The attempt to connect is asynchronous, with the associated
	 *  \link GDPushChannelDelegate.OnChannelOpen: OnChannelOpen\endlink
	 * callback being invoked when the attempt succeeds (not shown).
	 *
	 * <H3>Close Push Channel</H3>
	 * \code
	 * myChannel.Disconnect();
	 * \endcode
	 * The request to disconnect is asynchronous, with the associated
	 *  \link GDPushChannelDelegate.OnChannelClose OnChannelClose\endlink
	 * callback being invoked when the attempt succeeds (not shown).
	 */
	[BaseType (typeof(NSObject))]
	public interface GDPushChannel
	{
		/// <summary>
		/// </summary>
		[Export ("connect")]
		void Connect ();

		/**< Connect Push Channel.
		 * Call this function to open the Push Channel.
		 * This function can only be called when the channel is not open.
		 *
		 * This function causes a request for a Push Channel to be sent to the
		 * Good Dynamics proxy infrastructure Network Operation Center (NOC).
		 * The NOC will create the channel, and issue a Push Channel token, which can
		 * then be used to identify the channel.
		 *
		 * The connection attempt is asynchronous. If the attempt succeeds, the Push
		 * Channel token will be passed to the
		 *  \link GDPushChannelDelegate.OnChannelOpen: OnChannelOpen\endlink callback in the
		 * delegate.
		 * If the attempt fails, an error code will be passed to the 
		 *  \link GDPushChannelDelegate.OnChannelError: OnChannelError\endlink callback in the
		 * delegate instead.
		 *
		 * Logically, Push Channels exist within the Push Connection.
		 * Opening a Push Channel will not succeed if the Push Connection is not open
		 * and operating.
		 * \see \link GDPushConnection GDPushConnection\endlink
		 * 
		 */

		[Export ("disconnect")]
		void Disconnect ();

		/**< Disconnect Push Channel.
		 * Call this function to initiate permanent disconnection of the
		 * Push Channel. This function can only be called when the channel is open.
		 *
		 * This function causes a request for Push Channel termination to be sent to
		 * the Good Dynamics proxy infrastructure Network Operation Center (NOC).
		 * The NOC will delete the channel, and invalidate the Push Channel token that
		 * was issued when the channel was initially opened, see
		 * \link GDPushChannel.Connect Connect\endlink.
		 *
		 * Disconnection is asynchronous. Once disconnection is complete, the
		 *  \link GDPushChannelDelegate.OnChannelClose OnChannelClose\endlink callback in the 
		 * delegate will be invoked.
		 *
		 * Note. This function is for permanent closure of the channel. Transient
		 * suspension of Push Channel notifications may be more easily accomplished
		 * out-of-band, by direct communication with the application server.
		 *
		 * If the connection with the NOC is open and operating, and the
		 * application server that was sent the token registered for
		 * <TT>IsDisconnected</TT>, then a disconnect notification will be sent to the
		 * application server, by the NOC. See the \ref GNP.
		 * 
		 */

		[Export ("delegate", ArgumentSemantic.Assign)]
		GDPushChannelDelegate Delegate { get; set; }
		/**< Delegated event-handling.
		 * The Push Channel object works asynchronously. When its state changes, or a
		 * Push Channel notification is received, an event is generated by the Good
		 * Dynamics Runtime, and passed to a callback function in the application code.
		 *
		 * Set this property to an instance of a class that contains the code for the
		 * required callback functions, i.e. a class that implements
		 * the  \link GDPushChannelDelegate GDPushChannelDelegate\endlink protocol.
		 */
	}

	/// <summary>
	/// </summary>
	/** Securely exchange data with the Good for Enterprise&tm; email and PIM
	 * application (deprecated).
	 * \deprecated
	 * This class is deprecated and will be removed in a future release.
	 * \deprecated
	 * Enterprise Single Sign-On is deprecated in favor of Authentication Delegation
	 * using Good Inter-Container Communication (ICC). ICC Authentication Delegation
	 * is controlled by policy settings in the Good Control console.\n
	 * \deprecated
	 * Sending and receiving files with the Secure Documents API is deprecated in
	 * favor of the Good Dynamics AppKinetics&tm; Transfer File service. See the
	 *   \link GDService GDService class reference\endlink and the <A
	 *     href="https://community.good.com/docs/DOC-1645" target="_blank"
	 * >com.good.gdservice.transfer-file Service Description</A>.
	 * 
	 * This class includes the functions and structures required to send and receive
	 * data using the Good Secure Documents API.
	 *
	 * The Good Secure Documents API is a means of exchanging data between two
	 * applications running on the same device.
	 * One of the applications must be a Good Dynamics (GD) application, the other
	 * must be the Good for Enterprise (GFE) email and PIM application.
	 *
	 * The security of data is not compromised during exchange. The data remains
	 * in Good secure storage throughout.
	 *
	 * The Secure Documents API can be used to exchange any type of data
	 * between applications. The Secure Documents API can also be used to
	 * delegate user authentication from GD to GFE.
	 * See Enterprise Single Sign-On Authorization, below.
	 *
	 * To utilize this API for application data exchange, or for Enterprise
	 * Single Sign-On, the application must register a specific URL type for use
	 * with iOS OpenURL.
	 * Registration is configured in the project's build resources, see below.
	 *
	 * \see <A
	 *     href="https://www.good.com/products/good-for-enterprise.php"
	 *     target="_blank"
	 * >Good for Enterprise product information</A> on the good.com corporate
	 * website.
	 * \see <A
	 *     href="http://www.good.com/support/documentation/"
	 *     target="_blank"
	 * >Good for Enterprise documentation</A> on the good.com corporate website.
	 * \see <A
	 *     href="https://community.good.com/docs/DOC-1239" target="_blank"
	 * >Secure Documents API Question & Answer</A> document for an introduction to
	 * the Secure Documents feature.
	 * \see \ref GDService class reference
	 *
	 * <H3>Enterprise Single Sign-on Authorization</H3>
	 * Enterprise Single Sign-on (SSO) authorization is an extension to default
	 * Good Dynamics authorization. The differences are as follows:
	 *  \htmlonly <div class="bulletlists"> \endhtmlonly
	 * - The application will "pair" with the Good for Enterprise (GFE)
	 * application after completing its default authorization processing. Default
	 * processing includes communication with the proxy infrastructure and any
	 * necessary user interaction, such as the initial entry of the activation key.
	 * - When the user has to enter their password, they do so in the GFE user
	 *   interface, not in the GD Runtime user interface.
	 * - Password requirements are based on the security policies in place for GFE,
	 *   not GD.
	 * .
	 *  \htmlonly </div> \endhtmlonly
	 *
	 * To select SSO for a GD application:
	 * -# Enable the Secure Documents API in the build-time configuration, see
	 *    the \link GDiOS\endlink class reference for details.
	 * -# Add the following setting in the application's Info.plist fi<TT></TT>le:
	 * \code
	 * GDLibraryMode : GDEnterpriseSingleSignOn
	 * \endcode
	 *    (In case there are multiple Info.plist files, check that the correct one
	 *    has been edited by opening the Info tab of the application target being
	 *    built. The setting just made should appear there.)
	 * -# In the application code, call  \link GDiOS::authorize: authorize (GDiOS)\endlink in the usual way.
	 * .
	 * The GD Runtime will then process default authorization, then attempt to
	 * pair with GFE.
	 * Success or failure will be notified by invoking the delegate
	 * \ref GDiOSDelegate::handleEvent: "handleEvent (GDiOSDelegate)"
	 * callback, as for default authorization processing.
	 *
	 * Note: changing authorization mode with an application over-install is not supported,
	 * i.e. it is not supported to over-install a <TT>GDEnterprise</TT> application with a
	 * <TT>GDEnterpriseSingleSignOn</TT> application.
	 *
	 * <H3>Sending Files</H3>
	 * Sending a file to another application involves the following steps:
	 * -# Check that sending is possible.\n
	 * Call either the \link GDSecureDocs::canSendFileToGFE canSendFileToGFE\endlink function or the
	 * \ref canSendFileToApplication: "canSendFileToApplication:" function to
	 * check that sending is possible.
	 * Sending will be possible if:
	 *  - The other application is installed, and
	 *  - The other application supports receiving files
	 *  .
	 * -# Send the file, if sending is confirmed as possible.\n
	 * Call either the \ref SendFileToGFE "SendFileToGFE"
	 * function or the
	 * \ref SendFile "SendFile"
	 * function to send the file.\n
	 * If required, a <TT>UIDocumentInteractionController</TT> (UIDIC) can be used,
	 * although this is not necessary. To use a UIDIC with the Secure Documents API,
	 * proceed as follows.
	 *  -# Create a temporary copy of the file to be sent
	 *  -# In the <TT>willBeginSendingToApplication</TT> delegate, delete the
	 *  temporary file
	 *  -# Call one of the send functions, as above.
	 *  .
	 * .
	 * \see <A
	 *     HREF="http://developer.apple.com/library/ios/documentation/UIKit/Reference/UIDocumentInteractionController_class/"
	 *     target="_blank"
	 * >UIDocumentInteractionController class reference</A> in the iOS Developer
	 * Library on apple.com
	 *
	 * <H3>Receiving Files</H3>
	 * Receipt of files can be supported in Good Dynamics applications by use of
	 * the openURL mechanism.
	 *
	 * Implement an <TT>application:openURL:sourceApplication:annotation:</TT>
	 * handler in the application's <TT>UIApplicationDelegate</TT> class.
	 * The handler will be invoked when a file is sent to the application, by
	 * another application.
	 *
	 * In the handler, check that the URL has the correct scheme, by comparing with
	 * the \ref kGDSecureDocsScheme value.
	 * Then move the file to a working area and process as required.
	 * Moving the file prevents it from being overwritten by a subsequently received
	 * file of the same name.
	 * 
	 * \see Look for <TT>openURL</TT> in the <A
	 *     HREF="http://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplication_class/"
	 *     target="_blank"
	 * >UIApplication class reference</A> in the iOS Developer Library on apple.com
	 *
	 *  <H2>Code Snippets</H2> The following code snippets illustrate some common tasks.
	 * <H3>Send a file to GFE</H3>
	 * \code
	 * if(GDSecureDocs.CanSendFileToGFE)
	 * {
	 * 		bool bRet = GDSecureDocs.SendFileToGFE(secContainerPath, (error) => {
	 *						if(error)
	 *						{
	 *							Console.WriteLine(String.Format("There was an error sending file: {0}", error.LocalizedDescription));
	 *						}
	 *					});
	 * }
	 * \endcode
	 *
	 *
	 * <H3>Send a file to GFE using UIDocumentInteractionController</H3>
	 * \code
	 *
	 * // Creating the UIDocumentInteractionController
	 * // In order to have ability to cancel UIDocumentInteractionController we need to create a temp file
	 * // which we can remove if the application selected is not supported.
	 *
	 * public void SendFile(NSURL url)
	 * {
	 * 		// ...
	 * 		
	 *		string filePath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments), "..", "tmp", url.LastPathComponent);
	 *      
	 *		// set the URL of the controller to the temp file
	 *      this.DocInteractionController.URL = new NSURL(filePath);
	 *		// store the actual secure container path for later use
	 *		this.CurrentSecurePath = url.Path;
	 *
	 *		this.DocInteractionController.PresentOptionsMenu(longPressGesture.View.Frame, longPressGesture.View, true);
	 * }
	 *
	 * // Handling the delegate methods
	 * public UIViewController ViewControllerForPreview(UIDocumentInteractionController interactionController)
	 * {
	 * 		return this;
	 * }
	 *
	 * public void WillBeginSending(UIDocumentInteractionController controller, string application)
	 * {
	 * 		if(GDSecureDocs.CanSendFileToApplication(application))
	 *		{
	 *			// Removing the temporary file will cause UIDocumentInteractionController to dismiss the menu and cancel the transfer
	 *			// so we can do it using the secure APIs instead.
	 *			GDNSFileManager.DefaultManager.RemoveItemAtURL(this.DocInteractionController.URL, null);
	 *			
	 *			bool bRet = GDSecureDocs.SendFile(this.CurrentSecurePath, application, (error) => {
	 *							if(!error == null)
	 *							{
	 *								// transfer was successful
	 *							}
	 *							else
	 *							{
	 *								Console.WriteLine(String.Format("There was an error sending the file: {0}", error.LocalizedDescription));
	 *							}
	 *						});
	 *		}
	 *		else
	 *		{
	 *			//normal, non-secure flow
	 *		}
	 * }
	 *
	 * \endcode
	 *
	 * <H3>Receive a file from GFE</H3>
	 * \code
	 * public bool OpenURL(UIApplication application, NSURL url, string sourceApplication, NSObject annotation)
	 * {
	 *		if(GDSecureDocs.kGDSecureDocsScheme.Compare(url.Scheme) == NSOrderedSame)
	 *		{
	 *			Console.WriteLine(String.Format("secure container openURL path {0}", url.Path));
	 *			string secContainerPath = url.Path;
	 *			// use this path to access the file in the container
	 *		}
	 *		else
	 *		{
	 *			// handling of plain openURL requests
	 *		}
	 * }
	 * \endcode
	 */

	[BaseType (typeof(NSObject))]
	public interface GDSecureDocs
	{
		/// <summary>
		/// </summary>
		[Static, Export ("canSendFileToGFE")]
		bool CanSendFileToGFE { get; }

		/**< Check possibility of sending files to Good for Enterprise.
		 * Call this function to check if it is currently possible to send files to
		 * the Good for Enterprise email and PIM application.
		 *
		 * Sending will be possible if:
		 * - The Good for Enterprise mobile application is installed and activated, and
		 * - The installed version supports inbound Secure Documents API data exchange.
		 *
		 * \return <TT>true</TT> if it is possible to send files to the Good for
		 * Enterprise application.
		 * \return <TT>false</TT> otherwise.
		 */

		[Static, Export ("canSendFileToApplication:")]
		bool CanSendFileToApplication (string application);

		/**< Check possibility of sending files to Good for Enterprise, specified as an
		 * application.
		 * Call this function to check if it is currently possible to send files to
		 * a specified other application.
		 *
		 * This function is provided for <TT>DocumentInteractionController</TT> support.
		 * In practice, the specified application must be the Good for Enterprise (GFE)
		 * email and PIM application.
		 *
		 * Sending will be possible if:
		 * - The specified application is installed and activated, and
		 * - The installed version supports inbound Secure Documents API data exchange.
		 * .
		 *
		 * \param application <TT>string</TT> containing the iOS Application ID of
		 * the application to check.
		 *
		 * \return <TT>true</TT> if it is possible to send files to the other
		 * application.
		 * \return <TT>false</TT> otherwise.
		 */

		[Static, Export ("sendFileToGFE:withSuccessBlock:")]
		bool SendFileToGFE (string relativeSecureFile, SendFileSuccessBlock block);

		/**< Send a file to Good for Enterprise.
		 * Call this function to send a file to the Good for Enterprise (GFE) email
		 * and PIM application using the Secure Documents API.
		 * The file must be in the GD secure store, see \ref GDFileSystem.
		 *
		 * If sending to the application is possible, see \ref canSendFileToGFE,
		 * sending of the specified file will be attempted. After the send attempt, a
		 * specified block of code will be executed.
		 * The code block will be passed a reference to an <TT>NSError</TT> object, or
		 * <TT>null</TT> if the send succeeded.
		 *
		 * \param relativeSecureFile <TT>string</TT> containing the path, within the
		 * secure store, of the file to be sent.
		 * \param block conforming to <TT>SendFileSuccessBlock</TT>, which will be
		 * executed if the send is attempted.
		 *
		 * \return <TT>true</TT> if the send shall be attempted. The success block will
		 * be executed.
		 * \return <TT>false</TT> if the send shall not be attempted. The success block
		 * will not be executed.
		 */

		[Static, Export ("sendFile:toApplication:withSuccessBlock:")]
		bool SendFile (string relativeSecureFile, string application, SendFileSuccessBlock block);

		/**< Send a file to Good for Enterprise by specifying the application.
		 * Call this function to send a file to a specified application, using the
		 * Secure Documents API.
		 * The file must be in the GD secure store, see \ref GDFileSystem.
		 * 
		 * This function is provided for <TT>DocumentInteractionController</TT> support.
		 * In practice, the specified application must be the Good for Enterprise (GFE)
		 * email and PIM application.
		 *
		 * If sending to the application is possible, see \ref CanSendFileToApplication
		 * sending of the specified file will be attempted. After the send attempt, a
		 * specified block of code will be executed.
		 * The code block will be passed a reference to an <TT>NSError</TT> object, or
		 * <TT>null</TT> if the send succeeded.
		 *
		 * \param relativeSecureFile <TT>string</TT> containing the path, within the
		 * secure store, of the file to be sent.
		 * \param application <TT>string</TT> containing the iOS Application ID of
		 * the receiving application.
		 * \param block conforming to <TT>SendFileSuccessBlock</TT>, which will be
		 * executed if the send is attempted.
		 *
		 * \return <TT>true</TT> if the send shall be attempted. The success block will
		 * be executed.
		 * \return <TT>false</TT> if the send shall not be attempted. The success block
		 * will not be executed.
		 */
		
		/// <summary>
		/// </summary>
		[Field ("kGDSecureDocsScheme", "__Internal")]
		NSString GDSecureDocsScheme { get; set; }
		/**< URL scheme for the Secure Documents API, for use with openURL.
		 * In the openURL handler, compare the scheme of the incoming URL to this value
		 * to verify that the calling application is using the Secure Documents API.
		 * \see \ref GDSecureDocs
		 */
	}

	/** Handler for Good Inter-Container Communication consumer events.
	 * Responses to service requests within the Good Inter-Container
	 * Communication (ICC) system are handled by creating a class that implements
	 * this protocol.
	 *
	 * This class is part of the service consumer side of the ICC API.
	 *
	 * The  \link GDServiceClientDelegate.DidReceiveFrom DidRecieveFrom\endlink callback would be
	 * invoked after the application had sent a service request to a service
	 * provider, and the provider had responded or an error had occurred.
	 * 
	 * \see   \link GDService GDService class reference\endlink for an overall description of ICC.
	 *
	 * This class also includes a callback that is invoked whenever transmission of
	 * a service request completes.
	 */
	[Protocol, Model, BaseType (typeof(NSObject))]
	public interface GDServiceClientDelegate
	{

		[Export ("GDServiceClientDidReceiveFrom:withParams:withAttachments:correspondingToRequestID:")]
		void DidRecieveFrom (string application, NSObject parameters, NSObject[] attachments, string requestID);

		/**< Good Inter-Container Communication service response callback.
		 * This callback is invoked when a response is received to a service
		 * request that was sent within the Good Inter-Container Communication (ICC)
		 * system.
		 * The parameters give the details of the service response.
		 * 
		 * For an overall description of ICC see the   \link GDService GDService class reference\endlink.
		 * 
		 * A service response may be received in relation to a call to
		 *  \link GDServiceClient.SendTo SendTo (GDServiceClient)\endlink that was accepted by the ICC system.
		 *
		 * The response can include file attachments and a results object from the
		 * provider application.
		 * Check the type of the results object to determine whether the service
		 * request succeeded.
		 *
		 * If the results object is of type
		 * <TT>NSError</TT> then the service request
		 * failed.
		 * The error domain of the object will either be the
		 * <TT>GDServicesErrorDomain</TT> value, in the case of a generic ICC failure,
		 * or a value that is specific to the service or to the provider application.
		 * In any case, the <TT>NSError</TT> object should have a suitable error
		 * code, a <TT>localizedDescription</TT>, and possibly additional data in its
		 * <TT>userInfo</TT> dictionary. See also the <A
		 *     href="http://developer.apple.com/library/ios/#documentation/Cocoa/Reference/Foundation/Classes/NSError_Class/Reference/Reference.html"
		 *     target="_blank"
		 * >NSError class reference</A> in the iOS Developer Library on apple.com for
		 * the full API.
		 * 
		 * If the results object is not of type
		 * <TT>NSError</TT> then the service request
		 * succeeded. In that case the results object will be of a valid service
		 * parameter type, as defined under Service Parameters in the
		 *   \link GDService GDService class reference\endlink.
		 * 
		 * \param application <TT>string</TT> containing the native application identifier of
		 * the provider application to which the original service request was sent.
		 *
		 * \param params The results object, as returned by the provider application.
		 * 
		 * \param attachments <TT>NSArray</TT> of <TT>NSString</TT>
		 * objects containing the paths of files that were attached to the service
		 * response.
		 * See under File Attachments in the   \link GDService GDService class reference\endlink.
		 * 
		 * \param requestID <TT>string</TT> containing the ID assigned to the original
		 * service request.
		 * An application that makes multiple concurrent service requests can use this
		 * value to tie the response back to the original request.
		 * The application must have retained the ID from when
		 *  \link GDServiceClient.SendTo SendTo (GDServiceClient)\endlink was originally called.
		 */

		[Export ("GDServiceClientDidStartSendingTo:withFilename:correspondingToRequestID:")]
		void DidStartSendingTo (string application, string filename, string requestID);

		/**< Good Inter-Container Communication service request file attachment
		 *   transmission start callback.
		 * This callback is invoked whenever the delivery of a service request
		 * file attachment via the Good Inter-Container Communication (ICC) system
		 * starts. The path of the file is passed as a parameter.
		 *
		 * Invocation of this callback notifies the application that the ICC system has
		 * started transferring the data in the file to the recipient of the service
		 * request.
		 *
		 * The function that is invoked could display a sending status in its user
		 * interface. The sending status could be cleared on receipt of the
		 * <TT>GDServiceClientDidFinishSendingTo:</TT>
		 * callback.
		 *
		 * \see  \link GDServiceClient.SendTo SendTo (GDServiceClient)\endlink for details of sending service requests.
		 * 
		 * \param application <TT>string</TT> containing the native application identifier of
		 *                    the recipient of the file.
		 * 
		 * \param filename <TT>string</TT> containing the path in the secure store of the
		 *                 file that is now being sent.
		 *
		 * \param requestID <TT>string</TT> containing the unique ID of the service request
		 *                  to which the file is attached.
		 */

		[Export ("GDServiceClientDidFinishSendingTo:withAttachments:withParams:correspondingToRequestID:")]
		void DidFinishSendingTo (string application, NSObject[] attachments, NSObject parameters, string requestID);
		/**< Good Inter-Container Communication service request transmission complete
		 *   callback.
		 * This callback is invoked whenever the delivery of a service request
		 * via the Good Inter-Container Communication (ICC) system completes.
		 *
		 * Invocation of this callback notifies the application that:
		 * - Any files that were attached to the service request have been copied to the
		 * secure store of the service provider.
		 * - An independent copy of the parameters of the request, if any, has been made
		 * available to the service provider.
		 * .
		 * The function that is invoked can delete or modify any of the original
		 * file attachments, and free any resources used to hold the request
		 * parameters.
		 *
		 * \see  \link GDServiceClient.SendTo SendTo (GDServiceClient)\endlink for details of sending service requests.
		 * 
		 * \param requestID <TT>string</TT> containing the unique ID of the service request
		 * whose sending has completed.
		 * 
		 * \param attachments <TT>NSArray</TT> of <TT>NSString</TT>
		 * objects containing the paths of any files that were attached to the service
		 * request.
		 *
		 * \param params Reference to the parameters object of the service request.
		 *
		 * \param application <TT>string</TT> containing the native application identifier of
		 * the application to which the service request was sent.
		 */
	}

	/** Good Inter-Container Communication service consumer.
	 * This class is mandatory for service consumer applications within the
	 * Good Inter-Container Communication (ICC) system.
	 * This class also includes the specific API for sending ICC service requests.
	 *
	 * To utilize this API the application must meet the requirements listed under
	 * Service Consumer Requirements, below.
	 * 
	 * For an overall description of ICC see the   \link GDService GDService class reference\endlink.
	 * 
	 * The functions in this API cannot be used until Good Dynamics
	 * authorization processing is
	 * complete, see under  \link GDiOS::authorize: authorize (GDiOS)\endlink.
	 * 
	 * \see  \link iccerrors Good Inter-Container Communication Errors\endlink
	 * 
	 * <H3>Service Consumer Requirements</H3>
	 * To function as an ICC service consumer, a GD application must:
	 * - Instantiate a single object of the <TT>GDServi</TT><TT>ceClient</TT> class.
	 * - Set the delegate to an instance of a class that
	 *   implements the  \link GDServiceClientDelegate GDServiceClientDelegate\endlink
	 *   protocol, typically
	 *   <TT>self</TT>.
	 * - Register the ICC URL type on the
	 *   device. This will normally be achieved by utilizing the mandatory Good
	 *   Dynamics build-time configuration, as detailed in the \link GDiOS\endlink
	 *   class reference.
	 * .
	 * Note that an application that consumes multiple services still instantiates
	 * only a single object of this class.
	 * The delegate of the object handles responses from
	 * all the services that the application consumes.
	 */
	[BaseType (typeof(NSObject))]
	public interface GDServiceClient
	{

		[Static, Export ("sendTo:withService:withVersion:withMethod:withParams:withAttachments:bringServiceToFront:requestID:error:")]
		bool SendTo ([NullAllowed] string application, string service, string version, string method, [NullAllowed] NSObject parameters, [NullAllowed] NSObject[] attachments, GDTForegroundOption option, out string requestID, out NSError error);

		/**< Send a Good Inter-Container Communication service request.
		 * Call this function to send a service request to a service
		 * provider application in the Good Inter-Container Communication (ICC)
		 * system.
		 * The request includes a method name, and can include service parameters and
		 * file attachments to be conveyed to the provider application.
		 *
		 * For an overall description of ICC see the   \link GDService GDService class reference\endlink.
		 * 
		 * The ICC system will assign a unique ID to the service request and make this
		 * available to the application. This value will also be returned with any
		 * response to the request. An application that makes multiple concurrent
		 * requests can use the request ID to match responses with requests.
		 * 
		 * \param application <TT>NSString</TT> containing the
		 * native bundle identifier of the service
		 * provider application.
		 * A suitable value could be obtained from the address field of a
		 * <TT>GDServiceProvider</TT> object returned by the  \link GDiOS.GetServiceProviders  GetServiceProviders  (GDiOS)\endlink
		 * function.
		 *
		 * \param service <TT>string</TT> containing the ID of the service to which the
		 * request is being sent.
		 * The value should correspond to a service that the service provider
		 * application offers.
		 *
		 * \param version <TT>string</TT> containing the version identifier of the service
		 * being requested.
		 * The value should correspond to a version of service that the service provider
		 * application offers.
		 *
		 * \param method <TT>string</TT> containing the name of the method, within the
		 * service, that is being requested.
		 * The value should correspond to the name of a method that the service provider
		 * application offers.
		 *
		 * \param params The service parameters object for the request.
		 * See under Service Parameters in the   \link GDService GDService class reference\endlink.
		 *
		 * \param attachments <TT>NSArray</TT> of <TT>NSString</TT>
		 * objects containing the paths of files
		 * in the Good Dynamics secure file system
		 * that are to be attached to the request.
		 * See under File Attachments in the   \link GDService GDService class reference\endlink.
		 *
		 * \param option <TT>GDTForegroundOption</TT> specifying the foreground execution preference
		 * for processing of the request:\n
		 * <TT>GDEPreferPeerInForeground</TT> for the provider application being in the foreground,\n
		 * <TT>GDEPreferMeInForeground</TT> for this application being in the foreground,\n
		 * <TT>GDENoForegroundPreference</TT> to specify that there is no preference.\n
		 * See also the notes under Foreground Execution in the   \link GDService GDService class reference\endlink.
		 *
		 * \param requestID Location of a an <TT>string</TT> pointer for returning the
		 * unique ID assigned to the request by the ICC system.
		 *
		 * \param error For returning an <TT>NSError</TT> object if an error occurs. If <TT>nil</TT>, no object will be returned.
		 *
		 * \return <TT>YES</TT> if the request was accepted by the ICC system.
		 * The result of the service request could be notified to the application by
		 * invocation of its <TT>GDServiceClientDidReceiveFrom</TT> callback, depending
		 * on the service, and whether the request is able to be delivered. See
		 * \ref iccerrors.
		 * \return <TT>NO</TT> Otherwise. The <TT>error</TT> location, if provided, will
		 * be set to point to an <TT>NSError</TT> object with details of the error
		 * condition.
		 */

		[Static, Export ("cancelRequest:toApplication:")]
		bool CancelRequest (string requestID, string application);

		/**< Cancel a Good Inter-Container Communication service request.
		 * Call this function to cancel service requests in the Good
		 * Inter-Container Communication (ICC) system. The application can only cancel
		 * requests that it sent, not requests sent by other applications.
		 *
		 * This function can be used to cancel a single service request. Specify the
		 * unique ID of the request, which will have been generated when
		 *  \link GDServiceClient.SendTo SendTo (GDServiceClient)\endlink was called.
		 *
		 * This function can also be used to cancel all service requests addressed
		 * to a specific application.
		 *
		 * Cancellation of a request can succeed or fail. If cancellation succeeds:
		 * - The
		 *   <TT>GDServiceClientDidFinishSendingTo:</TT>
		 *   callback in the sending application is not subsequently invoked.
		 * - The  \link GDServiceClientDelegate.DidReceiveFrom GDServiceClient.DidReceiveFrom\endlink callback in the
		 *   receiving application will not be invoked.
		 * .
		 * Cancellation will fail if the service request has already been delivered, in
		 * which case the above callback invocations would take place.
		 *
		 * \param requestID <TT>string</TT> containing the ID of the request to be cancelled,
		 *                  or <TT>nil</TT> to cancel all requests to the specified
		 *                  recipient.
		 *
		 * \param application <TT>string</TT> containing the native application identifier of
		 *                    the recipient to which the request or requests were sent.
		 *
		 * \return <TT>YES</TT> if one or more requests were cancelled.
		 * \return <TT>NO</TT> otherwise. This function returns <TT>NO</TT> if there is
		 *                   no service request that matches the specified values, or if
		 *                   none of the requests that match could be cancelled.
		 */

		[Static, Export ("bringToFront:error:")]
		bool BringToFront (string application, out NSError error);

		/**< Bring another application to the foreground.
		 * Call this function to bring another application to the
		 * foreground. This would typically be used when a service provider application
		 * has requested foreground execution to process a request that has already been
		 * sent. See under Foreground Execution in the   \link GDService GDService class reference\endlink for
		 * details.
		 * 
		 * This function cannot be used outside the context of service
		 * request processing.
		 *
		 * \param application <TT>string</TT> containing the native application identifier of
		 * the application to be brought to the foreground.
		 *
		 * \param error For returning an <TT>NSError</TT> object if an error occurs. If <TT>nil</TT>, no object will be returned.
		 * \return <TT>YES</TT> if the specified application was brought to the
		 * foreground, based on the return code from the native API.
		 * \return <TT>NO</TT> otherwise.
		 */

		[Export ("delegate", ArgumentSemantic.Assign)]
		GDServiceClientDelegate Delegate { [Bind ("getDelegate")] get; set; }
		/**< Handler for responses to service requests.
		 * When a response to an ICC service request is received, the Good
		 * Dynamics Runtime dispatches an event to a callback function within the
		 * application.
		 * 
		 * Set this property to an instance of a class in the application that contains
		 * the code for the required callback function
		 * , i.e. a class that implements
		 * the  \link GDServiceClientDelegate GDServiceClientDelegate\endlink protocol.
		 * The class should be coded to handle responses from service providers to
		 * which the application sends service requests.
		 * 
		 * Note that there is only one delegate, that handles
		 * all service responses received by the application.
		 *
		 */

	}

	/** Good Inter-Container Communication service provider implementation.
	 * Service requests received within the Good Inter-Container
	 * Communication (ICC) system are handled by creating a class that implements
	 * this protocol.
	 * 
	 * This class is part of the service provider side of the ICC API.
	 * 
	 * \see   \link GDService GDService class reference\endlink for an overall description of ICC.
	 *
	 * This class also includes a callback that is invoked whenever transmission of
	 * a service response completes.
	 */
	[Protocol, Model, BaseType (typeof(NSObject))]
	public interface GDServiceDelegate
	{

		[Export ("GDServiceDidReceiveFrom:forService:withVersion:forMethod:withParams:withAttachments:forRequestID:")]
		void DidReceiveFrom (string application, string service, string version, string method, NSObject parameters, NSObject[] attachments, string requestID);

		/**< Good Inter-Container Communication service request callback.
		 * This callback is invoked when a service request is sent to the
		 * application within the Good Inter-Container Communication (ICC) system.
		 * The parameters with which this function is called give the details of
		 * the service request.
		 *
		 * For an overall description of ICC see the   \link GDService GDService class reference\endlink.
		 * 
		 * When this callback is invoked, the application must:
		 * -# Check that the service request is valid.
		 * -# Process the request, if valid.
		 * -# If required by the service definition or other published API, respond to
		 *    the request with a success or failure result by calling the
		 *     \link GDService.ReplyTo ReplyTo (GDService)\endlink function.
		 * .
		 * If the application determines that a service request is invalid then the
		 * application should return an error in the <TT>ReplyTo</TT> call. For some
		 * check failures, the application must set a particular code in the returned
		 * error. These are documented in the Parameters section, below.
		 * \see  \link iccerrors Good Inter-Container Communication Errors\endlink.
		 *
		 * \param application <TT>string</TT> containing the native application identifier of
		 * the consumer application that sent the service request.
		 * The application is not required to check the value, but may do so.
		 * For example, the application could be coded only to process service requests
		 * from a known set of consumer applications, and to fail requests from unknown
		 * applications.
		 *
		 * \param service <TT>string</TT> containing the name of the service being requested.
		 * The application must check the value.
		 * If the application does not offer the requested service then the
		 * <TT>GDServicesErrorServiceNotFound</TT> code must be set.
		 *
		 * \param version <TT>string</TT> containing the version identifier of the service
		 * being requested.
		 * The application must check the value.
		 * If the application does not offer the requested service version then the
		 * <TT>GDServicesErrorServiceVersionNotFound</TT> code must be set.
		 *
		 * \param method <TT>string</TT> containing the name of the method within the service
		 * request.
		 * The application must check the value.
		 * If the application does not offer the requested method then the
		 * <TT>GDServicesErrorMethodNotFound</TT> code must be set.
		 *
		 * \param params The service parameters in the request, sent by the consumer
		 * application.
		 * See under Service Parameters in the   \link GDService GDService class reference\endlink.
		 * If the service parameters are in some way invalid then a service-specific
		 * error code could be set, or this could be handled in some other way according
		 * to the service definition.
		 *
		 * \param attachments <TT>NSArray</TT> of <TT>NSString</TT>
		 * objects containing the paths of files that were attached to the service
		 * request.
		 * See under File Attachments in the   \link GDService GDService class reference\endlink.
		 * If the file attachments are in some way invalid then a service-specific
		 * error code could be set in the results object, or this could be handled in
		 * some other way according to the service definition.
		 * 
		 * \param requestID <TT>string</TT> containing the unique ID assigned to this service
		 * request by the ICC system.
		 * The application must pass this value as the <TT>requestID</TT> parameter in
		 * the  \link GDService.ReplyTo ReplyTo (GDService)\endlink call if it responds to the request.
		 */

		[Export ("GDServiceDidStartSendingTo:withFilename:correspondingToRequestID:")]
		void DidStartSendingTo (string application, string filename, string requestID);

		/**< Good Inter-Container Communication service response file attachment
		 *   transmission start callback.
		 * This callback is invoked whenever the delivery of a service response
		 * file attachment via the Good Inter-Container Communication (ICC) system
		 * starts. The path of the file is passed as a parameter.
		 *
		 * Invocation of this callback notifies the application that the ICC system has
		 * started transferring the data in the file to the recipient of the service
		 * response.
		 *
		 * The function that is invoked could display a sending status in its user
		 * interface. The sending status could be cleared on receipt of the
		 * <TT>GDServiceDidFinishSendingTo:</TT>
		 * callback.
		 *
		 * \see  \link GDService.ReplyTo ReplyTo (GDService)\endlink for details of sending a service response.
		 *
		 * \param application <TT>string</TT> containing the native application identifier of
		 *                    the recipient of the file.
		 *
		 * \param filename <TT>string</TT> containing the path in the secure store of the
		 *                 file that is now being sent.
		 *
		 * \param requestID <TT>string</TT> containing the unique ID of the original service
		 *                  request, the response to which the file is attached.
		 */

		[Export ("GDServiceDidFinishSendingTo:withAttachments:withParams:correspondingToRequestID:")]
		void DidFinishSendingTo (string application, NSObject[] attachments, NSObject parameters, string requestID);
		/**< Good Inter-Container Communication service response transmission complete callback.
		 * This callback is invoked whenever the delivery of a service response
		 * via the Good Inter-Container Communication (ICC) system completes.
		 *
		 * Invocation of this callback notifies the application that:
		 * - Any files that were attached to the service response have been copied to the
		 * secure store of the service consumer.
		 * - An independent copy of the parameters of the response, if any, has been made
		 * available to the service consumer.
		 * .
		 * The function that is invoked can delete or modify any of the original
		 * file attachments, and free any resources used to hold the response
		 * parameters.
		 *
		 * \see  \link GDService.ReplyTo ReplyTo (GDService)\endlink for details of sending service responses.
		 * 
		 * \param requestID <TT>string</TT> containing the unique ID of the service request
		 * to which the sending of the response has completed.
		 * 
		 * \param attachments <TT>NSArray</TT> of <TT>NSString</TT>
		 * objects containing the paths of any files that were attached to the service
		 * response.
		 *
		 * \param params Reference to the parameters object of the service response.
		 *
		 * \param application <TT>string</TT> containing the native application identifier of
		 * the application to which the service response was sent.
		 */
	}

	/** Good Inter-Container Communication service provider.
	 * This class is mandatory for service provider applications within the
	 * Good Inter-Container Communication (ICC) system.
	 * This class also includes the specific API for sending ICC service responses.
	 * This API would be utilized in the code of the
	 * delegate of this class.
	 * 
	 * 
	 * For an overall description of ICC, see under
	 * Good Inter-Container Communication below.
	 * To utilize this API the application must meet the requirements listed under
	 * Service Provider Requirements.
	 *
	 * The functions in the ICC APIs utilize <TT>NSError</TT> in a conventional way. Function calls accept as a parameter the location of a pointer to <TT>NSError</TT>, i.e. a pointer to a pointer, with type <TT>NSError**</TT>. The location may be <TT>nil</TT>. If the location is not <TT>nil</TT>, and an error occurs, the Good Dynamics Runtime overwrites the pointer at the specified location with the address of an object that describes the error that occurred.
	 * 
	 * The functions in this API cannot be used until Good Dynamics
	 * authorization processing is
	 * complete, see under  \link GDiOS::authorize: authorize (GDiOS)\endlink.
	 * 
	 * \see  \link iccerrors Good Inter-Container Communication Errors\endlink
	 * \see \link GDServiceClient GDServiceClient\endlink for the parts of the API that are specific to
	 * service consumers.
	 * \see  \link GDiOS.GetServiceProviders  GetServiceProviders  (GDiOS)\endlink for the service discovery API.
	 * \see \ref GDSecureDocs for details of the deprecated Secure Documents API.
	 * 
	<H3>Good Inter-Container Communication</H3> The Good
	 * Inter-Container Communication (ICC) system is a means of exchanging data
	 * securely between two Good Dynamics applications running on the same mobile
	 * device. The security of data is not compromised during exchange.
	 *
	 * Interaction in the ICC system follows a service consumer-provider model.
	 * One application initiates communication by sending a service request to
	 * another.
	 * The initiating application is the service consumer.
	 * The application that receives the request is the service provider.
	 *
	 * After receiving the service request, the provider executes the necessary
	 * processing and could then send a service response back to the consumer.
	 * Both the service request and the service response, if any, can contain a
	 * number of parameters and file attachments. See under Service Parameters and
	 * File Attachments, below.
	 *
	 * The sequence of APIs used in a typical ICC interaction is as follows:
	 * -# The consumer application calls the service discovery API.
	 * -# The consumer application calls  \link GDServiceClient.SendTo SendTo (GDServiceClient)\endlink.
	 * -# The  \link GDServiceDelegate.DidReceiveFrom DidReceiveFrom\endlink callback in the provider
	 *    application is invoked by the ICC system.
	 * -# The provider application executes any required processing and then calls
	 *     \link GDService.ReplyTo ReplyTo (GDService)\endlink.
	 * -# The  \link GDServiceClientDelegate.DidReceiveFrom DidReceiveFrom\endlink callback in the
	 *    consumer is invoked by the ICC system.
	 * .
	 * Note that an ICC interaction can be initiated with any GD application whose
	 * native application identifier is known in the service consumer.
	 * The identifier could be known by being present in the application code or, as
	 * shown in the above, could be obtained at run time by using Good Dynamics
	 * service discovery.
	 * See  \link GDiOS.GetServiceProviders  GetServiceProviders  (GDiOS)\endlink for details of the service discovery API.
	 *
	 * Note that the service provider does not necessarily send a response, i.e. the
	 * call to <TT>ReplyTo</TT> and subsequent invocation of the callback in the
	 * consumer do not necessarily take place. The service definition specifies when
	 * and whether the provider sends a response, see under Service Definition,
	 * below.
	 * 
	 * The data for requests and responses is sent across a secure connection.
	 * The connection is established and maintained as necessary by the Good
	 * Dynamics Runtime.
	 * This is transparent to the applications, although not always to the end user
	 * since the device may sometimes "flip" between applications during ICC
	 * interaction. See also the Foreground Execution section, below.
	 *
	 * The ICC system cannot be used when running under
	 * \ref enterprisesimulation.
	 *
	 * <H3>Service Definition</H3>
	 * The service provided by an application may conform to a declared service
	 * definition. The declaration, if there is one, will specify the following:
	 * - Name of the service, conventionally a reversed Internet domain followed by
	 *   a number of sub-domains separated by full stops (periods). Formally,
	 *   service names conform to the &lt;subdomain&gt; format defined in section
	 *   2.3.1 of <A
	 *      HREF="http://www.ietf.org/rfc/rfc1035.txt"
	 *      target="_blank"
	 *   >RFC1035</A>.
	 * - Methods that comprise the service.
	 * - Expected parameters to service requests, per method.
	 * - Expected file attachments to service requests, per method.
	 * - Whether and in what circumstances service responses will be issued, per
	 * method.
	 * - What types of service response will be issued, per method.
	 * - Expected parameters to service responses, per method and per type.
	 * - Expected file attachments to service responses, per method and per type.
	 * - Error conditions that are specific to the service.
	 * .
	 * An application that registers as providing a service for which there is a
	 * definition must adhere to the definition. Similarly, an application that
	 * consumes a service that is based on a declared definition should only send
	 * requests that conform to the definition. 
	 * 
	 * The service definition for a public service may be published to the Good
	 * Dynamics Network (GDN) website. The published definition may include a link
	 * to a more detailed API for the service. In any case, the service API may be
	 * obtained from the developer of a service provider application, or from the
	 * creator of the service definition.
	 *
	 * \see \ref ICCServiceDefinition for a description of Good Dynamics service
	 * definition.
	 *
	 * <H3>Service Parameters</H3>
	 * An ICC service request can include a number of parameters, sent by the
	 * consumer.
	 * Service responses can also include parameters, sent by the provider to convey
	 * detailed results to the consumer.
	 * The parameters in a request or response are always provided to the
	 * application as a single object.
	 * The ICC system supports a number of types of service parameter object.
	 * 
	 * Good Dynamics service definitions declare the expected types of parameter
	 * object for requests and responses for each method in a service. The Good
	 * Dynamics service definition language uses platform-independent terms for the
	 * declaration. The terms, and the native types that would be used to represent
	 * a parameter of that type, are listed in the following table.<TABLE
	 *     ><TR><TH
	 *         >Service Definition</TH
	 *     ><TH
	 *         >Native</TH
	 * 
	 *     ></TR><TR><TD
	 *         >string</TD
	 *     ><TD
	 *         ><TT>NSString</TT></TD
	 * 
	 *     ></TR><TR><TD
	 *         >number</TD
	 *     ><TD
	 *         ><TT>NSNumber</TT></TD
	 *
	 *     ></TR><TR><TD
	 *         >integer</TD
	 *     ><TD
	 *         ><TT>NSNumber</TT></TD
	 *
	 *     ></TR><TR><TD
	 *         >boolean</TD
	 *     ><TD
	 *         ><TT>NSNumber</TT></TD
	 *
	 *     ></TR><TR><TD
	 *         >null</TD
	 *     ><TD
	 *         ><TT>NSNull</TT></TD
	 *
	 *     ></TR><TR><TD
	 *         >UInt8Array</TD
	 *     ><TD
	 *         ><TT>NSData</TT></TD
	 *
	 *     ></TR><TR><TD
	 *         >array</TD
	 *     ><TD
	 *         ><TT>NSArray</TT> of any of the
	 *         simple types listed above.</TD
	 *
	 *     ></TR><TR><TD
	 *         >object</TD
	 *     ><TD
	 *         ><TT>NSDictionary</TT> of key-value
	 *         pairs, with any of the above types as values.</TD
	 * 
	 *     ></TR
	 * ></TABLE>
	 *
	 * Note that the service name, version, and method name are not service
	 * parameters as such and are not included in the parameters object.
	 *
	 * Error responses can include additional details of the error condition.
	 * For example, if a parameter exceeds a maximum value, then the additional
	 * details could include the value of the maximum.
	 * Additional details are specified in the service definition, per condition, in
	 * the same way as service parameters. Additional detail values are handled as 
	 * entries in the <TT>userInfo</TT> dictionary in an <TT>NSError</TT> object.
	 * 
	 * <H3>File Attachments</H3>
	 * An ICC service request can include a number of file attachments specified by
	 * the consumer.
	 * Service responses can also include file attachments, when these are sent by
	 * the provider as results.
	 *
	 * File attachments are sent from the secure store of one application, and
	 * copied to the secure store of the other application.
	 * Deletion of the recipient's copy of the file is the responsibility of the
	 * recipient application. The ICC system does not delete copies of files
	 * that were attached to a request or response.
	 *
	 * In the API, the sending application specifies file attachments as paths in
	 * its secure store.
	 * The ICC system copies the files to the receiving application's secure
	 * store, and then invokes a callback in the receiving application.
	 * The callback is passed the paths of the copies, which it can open in the
	 * usual manner.
	 *
	 * The ICC system uses the following naming convention to construct the paths of
	 * the receiving application's copies:\n
	 * <EM>Inbox Directory</EM><TT>/</TT
	 * ><EM>Sender</EM><TT>/</TT
	 * ><EM>Reference time</EM><TT>/</TT
	 * ><EM>Original Path</EM>\n
	 * Where:\n
	 * <EM>Sender</EM> is the native application identifier of the sending
	 * application.\n
	 * <EM>Reference time</EM> is the date and time at which the ICC system started
	 * handling the file attachments, down to a millisecond resolution.
	 *
	 * Note that all the files attached to a particular service request or response
	 * will be placed under one directory. This means that the receiving application
	 * can delete all these files easily, by deleting the directory.
	 *
	 * The ICC system supports the sending of empty files in the current release,
	 * but did not in some earlier releases.
	 * 
	 * \see  \link GDFileSystem\endlink for the secure fi<TT></TT>le system API
	 *
	 * <H3>Foreground Execution</H3>
	 * An ICC service request can specify a preference that the application that
	 * provides the service executes in foreground in order to process the request.
	 * This could be used when request processing always requires user interaction,
	 * for example if the service is a special web browser or document editor.
	 * See the <TT>option</TT> parameter of the  \link GDServiceClient.SendTo SendTo (GDServiceClient)\endlink
	 * function.
	 *
	 * Similarly, an ICC service response can specify a preference that the
	 * service consumer application executes in foreground in order to process the
	 * response. This might be used to return the original application to the
	 * foreground. See the <TT>option</TT> parameter of the  \link GDService.ReplyTo ReplyTo (GDService)\endlink
	 * function.
	 *
	 * It is also possible that a service provider itself determines its need to
	 * execute in foreground in order to process a particular request, after the
	 * request has been received. This is supported in ICC by use of the "Front
	 * Request" API.
	 *
	 * The Front Request API has two parts: send and receive. In principle, any GD
	 * application can send a front request to any other GD application, and any GD
	 * application could receive a front request from any other GD application. In
	 * practice, a front request is typically sent to the consumer of a service by
	 * the provider of the service.
	 *
	 * The following scenario illustrates the typical sequence of events in which
	 * the Front Request API is utilized.
	 * -# Service consumer application sends a request that is to be executed in
	 *    background.
	 * -# Service provider application receives the request but determines that
	 *    processing can only take place in foreground.
	 * -# Service provider sends a front request to the service consumer. See under
	 *    Front Request API, below, for details.
	 * -# Service consumer receives the front request. See under Front Request
	 *    API, below, for details.
	 * -# Service consumer brings the provider to the foreground, by calling the
	 *     \link GDServiceClient::bringToFront:error: bringToFront:\endlink function.
	 * -# Service provider completes processing of the original request.
	 * .
	 * Note that the service consumer could also leave the provider in background,
	 * in which case the service request would be expected to fail in some way.
	 *
	 * A service provider might need to process a service request in foreground
	 * because:
	 * - User interaction is necessary, and this could not be predicted in the
	 *   service consumer before the service request was sent.
	 * - The time needed to process the request exceeds the time that is likely to
	 *   be allowed to the provider to run in background.
	 * .
	 *
	 * In general, only the application that is currently running in foreground can
	 * bring another application to the foreground. In the scenario that neither the
	 * service consumer nor provider are in foreground, for example because the user
	 * chose to take a call or started a third application, then neither application
	 * can be brought to foreground by the other.
	 * 
	 * <H3>Front Request API</H3>
	 * The Front Request API is defined as a Good Dynamics service within the ICC
	 * system.
	 *
	 * The formal service definition of the Front Request API is as follows.
	 * \code
	 * {
	 *     "service-id": "com.good.gd.icc",
	 *     "version": "1.0.0.0",
	 *     "title": "ICC Service ",
	 *     "description": "ICC is a special Good Dynamics service created by Good
	 * Technology. This service is for control of the Inter-Container Communication
	 * channel.",
	 *     "methods": {
	 *         "FRONT_REQ": {
	 *             "description": "The service consumer calls this method to request
	 * that the service provider places the service consumer in foreground."
	 *         }
	 *     }
	 * }
	 * \endcode
	 *
	 * To send a front request, then, an application calls the 
	 * <TT>SendTo</TT> function, with the following
	 * parameter values:
	 * - <TT>application</TT> the native application
	 *   identifier of the other application, which typically will have been
	 *   supplied in a
	 *   <TT>GDService.DidReceiveFrom</TT>
	 *   invocation resulting from the original service request.
	 * - <TT>service</TT> the
	 *   <TT>GDFrontRequestService</TT> constant, which always has the
	 *   service-id value, above.
	 * - <TT>version</TT> <TT>"1.0.0.0"</TT>
	 * - <TT>method</TT> <TT>"FRONT_REQ"</TT>
	 * - <TT>params</TT> <TT>nil</TT>
	 * - <TT>attachments</TT> <TT>nil</TT>
	 * - <TT>option</TT> <TT>GDENoForegroundPreference</TT>
	 * - <TT>requestID</TT> Location of a local pointer or <TT>nil</TT>, as for any
	 *   call to <TT>SendTo</TT>
	 * - <TT>out error</TT> Location of a local pointer or <TT>nil</TT>, as for any
	 *   call to <TT>SendTo</TT>
	 * .
	 * This causes a front request to be sent through the ICC system.
	 *
	 * The ICC system will deliver the front request in the same way as any other
	 * service request, by invoking a callback in the provider application to which
	 * the request is addressed. Note that, in the typical case, the service
	 * provider here will actually be the application that was originally the
	 * service consumer. This means that any application that consumes a service
	 * whose provider might send back a front request must itself be a provider of
	 * the Front Request API service. This includes meeting the generic requirements
	 * for all service provider applications, which are detailed under Service
	 * Provider Requirements, below.
	 *
	 * The invoked callback's application code for handling a Front Request API
	 * service request should be restricted to:
	 * - Identifying the received service request as a front request.
	 * - Any checks that are required to determine whether the application should
	 *   yield foreground execution to the application that sent the front request.
	 * - A call to the  \link GDServiceClient::bringToFront:error: bringToFront:\endlink function, to be
	 *   executed if all checks pass.
	 * .
	 * A minimal handler would identify a front request, make no checks, and then
	 * always call the  \link GDServiceClient.BringToFront BringToFront:\endlink function.
	 * 
	 * Note that the Front Request API service definition does not contain any
	 * service responses or errors so the application must not send any. If the
	 * application code checks do not pass and foreground execution is not to be
	 * yielded, then the application need take no action.
	 *
	 * The following code snippet gives a simple utility function that could be
	 * utilized in a callback as outlined above.
	 * \code
	 *public bool ConsumeFrontRequestService(string serviceID, string application, string method, string version)
	 *{
	 *	if (serviceID.Equals (GoodDynamics.GDService.GDFrontRequestService) && version.Equals ("1.0.0.0")) 
	 *	{
	 *		if (method.Equals (GoodDynamics.GDService.GDFrontRequestMethod)) 
	 *		{
	 *			NSError error = null;
	 *			GDService.BringToFront (application, out error);
	 *		} 
	 *		else 
	 *		{
	 *			NSDictionary errorDetail = new NSDictionary ();
	 *			errorDetail.SetValueForKey (new NSString(kMethodNotImplementedDescription), NSError.LocalizedDescriptionKey);
	 *			NSError serviceError = new NSError (GDService.GDServicesErrorDomain, GDService.GDServicesErrorMethodNotFound, errorDetail); 
	 *			SendErrorTo (application, serviceError);
	 *		}
	 *		return true;
	 *	}
	 *	return false;
	 * }
	 * \endcode
	 *
	 * <H3>Service Provider Requirements</H3>
	 * The following requirements apply to GD applications that are service
	 * providers.
	 *
	 * <H4>Function as a service provider</H4>
	 * To function as an ICC service provider, a GD application must:
	 * - Instantiate a single object of the <TT>GDService</TT> class.
	 * - Set the
	 *   <TT>Delegate</TT> property to point
	 *   to an object of a class that implements the
	 *   <TT>GDServiceDelegate</TT>
	 *   protocol, typically
	 *   <TT>self</TT>.
	 * - Register the ICC URL type on the
	 *   device. This will normally be achieved by utilizing the mandatory Good
	 *   Dynamics build-time configuration, as detailed in the
	 *   \link GDiOS\endlink class reference.
	 * .
	 * Note that an application that provides multiple services still instantiates
	 * only a single object of this class.
	 * The delegate of the object handles requests for all the services that the
	 * application provides.
	 *
	 * <H4>Returned by service discovery query</H4>
	 * To be on the list returned by a service discovery query, an application must
	 * be registered as a service provider. Register the application as a service
	 * provider:
	 * - In the enterprise Good Control console, if an in-house application.
	 * - Using the Good Developer Network website, if a partner application.
	 * .
	 * In either user interface, enter the
	 * native bundle identifier of the application, for example
	 * "com.example.application.name". Different bundle identifiers can be entered
	 * for different device types.
	 * 
	 * 
	 * \see  \link GDiOS.GetServiceProviders GetServiceProvidersFor:  (GDiOS)\endlink for details of the service discovery API.
	 */
	[BaseType (typeof(NSObject))]
	public interface GDService
	{

		[Static, Export ("replyTo:withParams:bringClientToFront:withAttachments:requestID:error:")]
		bool ReplyTo (string application, [NullAllowed] NSObject parameters, GDTForegroundOption option, [NullAllowed] NSObject[] attachments, string requestID, out NSError error);

		/**< Send a Good Inter-Container Communication response or error message.
		 * Call this function to respond to a consumer application from which a
		 * service request has been received in the Good Inter-Container Communication
		 * (ICC) system. The response can include a results object and file attachments
		 * to be conveyed to the consumer application. The results object will notify
		 * the consumer of the success or failure of the request.
		 * 
		 * For an overall description of ICC see the   \link GDService GDService class reference\endlink.
		 *
		 * If the request failed for any reason, pass an <TT>NSError</TT> as the
		 * results object. Populate the <TT>NSError</TT> with a suitable error code and
		 * a <TT>localizedDescription</TT>.
		 * Add any additional data to the <TT>userInfo</TT> dictionary.
		 * The error domain will be set by the Good Dynamics Runtime to be the same as
		 * the service name. See also the <A
		 *     href="http://developer.apple.com/library/ios/#documentation/Cocoa/Reference/Foundation/Classes/NSError_Class/Reference/Reference.html"
		 *     target="_blank"
		 * >NSError class reference</A> in the iOS Developer Library on apple.com for
		 * the full API.
		 * 
		 * If the request succeeded then pass a results object of a valid service
		 * parameter type, as defined under Service Parameters in the
		 *   \link GDService GDService class reference\endlink.
		 * 
		 * \param application <TT>NSString</TT> containing the native application idenitifer of
		 * the consumer, as supplied in the original service request.
		 *
		 * \param params <TT>NSObject</TT> containing the
		 * results object.
		 *
		 * \param option <TT>GDTForegroundOption</TT> specifying the foreground execution preference
		 * after delivery of the response:\n
		 * <TT>GDEPreferPeerInForeground</TT> for the consumer application being in the foreground,\n
		 * <TT>GDEPreferMeInForeground</TT> for this application being in the foreground,\n
		 * <TT>GDENoForegroundPreference</TT> to specify that there is no preference.\n
		 * See also the notes under Foreground Execution in the   \link GDService GDService class reference\endlink.
		 *
		 * \param attachments <TT>NSArray</TT> of <TT>NSString</TT>
		 * objects containing the paths of files in the Good Dynamics secure file system
		 * that are to be attached to the response.
		 * See under File Attachments in the   \link GDService GDService class reference\endlink.
		 *
		 * \param requestID <TT>string</TT> containing the ID of the service request to which
		 * this is a response. The ID will have been passed as a parameter to the
		 * delegated handler that implements the service.
		 *
		 *
		 * \param error For returning an <TT>NSError</TT> object if an error occurs. If <TT>nil</TT>, no object will be returned. Note that this means errors that occur when attempting to deliver the response, and is <EM>not </EM> a reference to the results object.
		 * \return <TT>YES</TT> if the response was accepted by the ICC system.
		 * \return <TT>NO</TT> otherwise. The <TT>error</TT> location, if provided, will
		 * be set to point to an <TT>NSError</TT> object with details of the error
		 * condition.
		 */


		[Static, Export ("bringToFront:error:")]
		bool BringToFront (string application, out NSError error);

		/**< Bring another application to the foreground.
		 * Call this function to bring another application to the
		 * foreground. This could be used when the application is a service provider, to
		 * bring the service consumer back to the foreground without sending a response.
		 * See under Foreground Execution in the   \link GDService GDService class reference\endlink for details.
		 * 
		 * This function cannot be used outside the context of service
		 * request processing.
		 *
		 * \param application <TT>string</TT> containing the native application identifier of
		 * the application to be brought to the foreground.
		 *
		 * \param error For returning an <TT>NSError</TT> object if an error occurs. If <TT>nil</TT>, no object will be returned.
		 * \return <TT>YES</TT> if the specified application was brought to the
		 * foreground, based on the return code from the native API.
		 * \return <TT>NO</TT> otherwise.
		 */

		[Export ("delegate", ArgumentSemantic.Assign)]
		GDServiceDelegate Delegate { [Bind ("getDelegate")] get; set; }
		/**< Handler that implements the services provided by the application.
		 * When an ICC service request is received, the Good Dynamics Runtime
		 * dispatches an event to a callback function within the application.
		 * 
		 * Set this property to an instance of a class in the application that contains
		 * the code for the required callback function.
		 * The callback must:
		 * - Implement the  \link GDServiceDelegate GDServiceDelegate\endlink 
		 *   protocol.
		 * - Process received service requests in accordance with the API of the
		 *   service provided. The API could be, for example, a Good Dynamics service
		 *   definition.
		 * .
		 * The processing could include calling  \link GDService.ReplyTo (GDService)\endlink to issue a
		 * service response.
		 * 
		 */


	}

	/// <summary>
	/// </summary>
	/** Delegate for handling the results of Good Dynamics Authentication Token
	 * requests.
	 * The results of Good Dynamics Authentication Token requests are
	 * handled by creating a class that implements this protocol.
	 * 
	 * Good Dynamics Authentication (GD Auth) tokens can be requested by utilizing a
	 * function in the <TT>GDUti</TT><TT>lity</TT> class.
	 *
	 * For the token request API, and general information about the GD Auth
	 * mechanism, see the \link GDUtility GDUtility\endlink class reference.
	 */
	[Protocol, Model, BaseType (typeof(NSObject))]
	public interface GDAuthTokenDelegate
	{
		/// <summary>
		/// </summary>
		[Export ("onGDAuthTokenSuccess:")]
		void OnGDAuthTokenSuccess (string gdAuthToken);

		/**< Successful token request callback.
		 * This callback will be invoked when a new GD Auth token has been
		 * generated. Token generation is always in response to a call to the
		 * \link GDUtility.GetGDAuthToken: GetGDAuthToken\endlink function.
		 *
		 * The function that is invoked could initiate sending of the token to the
		 * application server, out of band. The application server will then be able to
		 * utilize the token to authenticate the end user of the mobile application.
		 * \param gdAuthToken <TT>string</TT> containing the GD Auth token.
		 */

		[Export ("onGDAuthTokenFailure:")]
		void OnGDAuthTokenFailure (NSError authTokenError);
		/**< Failed token request callback.
		 * This callback will be invoked when a request for a GD Auth token has
		 * failed. Information about the error condition is passed in
		 * a parameter.
		 * 
		 * Requests for tokens are made by calling the
		 * \link GDUtility.GetGDAuthToken: GetGDAuthToken\endlink function. Invocation of this
		 * callback notifies the application that a GD Auth token was not issued in
		 * response to a request.
		 *
		 * Depending on the reason for failure, the function that is invoked could:
		 * - Retry the request, by initiating a new GD Auth token request.
		 * - Notify the user that GD Auth is not available as an authentication
		 *   mechanism.
		 * .
		 *
		 * \param authTokenError <TT>NSError</TT> describing the error condition that
		 * led to the failure of the token request.
		 *
		 * \see \ref gdauthtokendomain
		 */
	}

	/** Good Dynamics Authentication Token request.
	 * The Good Dynamics Authentication Token mechanism enables
	 * applications to utilize the user identification that takes place during Good
	 * Dynamics authorization processing. This allows the user to be authenticated
	 * without the need for entry of any additional credentials at the device.
	 * 
	 * See below for an overall description of the Good Dynamics Authentication
	 * Token mechanism. This class includes the specific API for requesting
	 * tokens.
	 * 
	 * \see  \link GDiOS.Authorize: Authorize (GDiOS)\endlink for more details of Good Dynamics authorization
	 * processing.
	 * \see \ref ServerAPIGDAuthToken
	 * 
	 * <H3>Good Dynamics Authentication Token Mechanism</H3>
	 * The Good Dynamics (GD) platform includes rigorous authentication of the end
	 * user. This is used when, for example, identifying whether the user is
	 * entitled to run the current application, and when applying security policies.
	 * 
	 * The Good Dynamics Authentication Token (GD Auth) mechanism enables
	 * applications to take advantage of the authentication processes of the GD
	 * platform.
	 *
	 * GD Auth tokens can be requested by the GD application on the device. A token
	 * will only be issued if authorization processing has completed, and the end
	 * user's identity has been authenticated.
	 *
	 * Once a token has been issued, the application on the device can send the
	 * token to the application server at the back end. The GD Auth token can then
	 * be checked by the application server, using a verification service provided
	 * by the GD infrastructure.
	 *
	 * The sequence of APIs used in GD Auth is as follows:
	 * -# The mobile application calls \link GDUtility.GetGDAuthToken: GetGDAuthToken\endlink to
	 *    request a token.
	 * -# All being well, a token is issued and the
	 *     \link GDAuthTokenDelegate.OnGDAuthTokenSuccess: OnGDAuthTokenSuccess\endlink callback is
	 *    invoked and passed the new token.
	 * -# The mobile application sends the token, and the user ID of the end user,
	 *    to its application server, using an HTTP request, socket, or some other
	 *    method.
	 * -# The application server checks that the token is valid by calling the
	 *    verification service in the \ref ServerAPIGDAuthToken, hosted by an
	 *    enterprise Good Proxy server.
	 * -# The response from the verification service includes the user ID of the end
	 *    user, if the token is valid. The application server can check that the
	 *    value from the verification service is the same as that originally sent by
	 *    the mobile application.
	 * .
	 * This sequence validates the end user's identity, and the application server
	 * can therefore grant access to resources and other permissions.
	 *
	 * The same token could be sent again later, and verified again. Calling the
	 * verification service does not cause the token to be consumed.
	 *
	 * Note that the mobile application can obtain the user ID of the end user from
	 * the <TT>GDAppConfigKeyUserId</TT> value in the collection returned by the
	 * \link GDiOS.GetApplicationConfig GetApplicationConfig (GDiOS)\endlink function.
	 * 
	 * <H3>Challenge Strings</H3>
	 * A <em>challenge string </em>can be passed as a parameter to the GD Auth token
	 * request by the mobile application. The same challenge string will then be
	 * provided to the application server, in the response from the verification
	 * service.
	 *
	 * The challenge string could have a number of uses for application developers.
	 * A typical usage could be to tie an instance of authentication to a previous
	 * access request, as follows:
	 * -# The mobile application attempts to access a resource on the application
	 *    server.
	 * -# The application server generates a random challenge string.
	 * -# The application server responds to the mobile application with a denial of
	 *    access message that includes the random challenge string.
	 * -# The mobile application requests a new GD Auth token, and passes the value
	 *    from the denial of access message as the challenge string.
	 * -# The mobile application again attempts to access the resource on the
	 *    application server, but this time includes the GD Auth token in the
	 *    request.
	 * -# The application server sends the token to the verification service, which
	 *    responds with a challenge string.
	 * -# The application server checks that the challenge string from the
	 *    verification service is the same as the random challenge string initially
	 *    sent to the mobile application in the denial of access message.
	 * .
	 * In the above, a new random challenge string is generated on every resource
	 * access attempt. This has the effect of making the GD Auth tokens one-use. A
	 * more advanced algorithm might be to store the token and challenge string in
	 * the App Server as a session identifier. To end a session, the App Server
	 * could delete the stored token and challenge string, effectively forcing the
	 * mobile application to generate a new token, based on a new challenge string,
	 * when it next connected.
	 * 
	 * The verification service provides the challenge string to the application
	 * server in an HTTP header, which limits the character set that can be utilized
	 * safely. All letters and numerals that lie in the ASCII range 32 to 126 can be
	 * utilized safely. Use of other characters is not supported.
	 */
	[BaseType (typeof(NSObject))]
	public interface GDUtility
	{

		[Export ("getGDAuthToken:serverName:")]
		void GetGDAuthToken (string challenge, string serverName);

		/**< Good Dynamics Authentication Token request.
		 * Call this function to request a new GD Auth token. Pass the
		 * challenge string and server name as parameters.
		 *
		 * See under Good Dynamics Authentication Token Mechanism, above, for
		 * information on how to use GD Auth tokens and the challenge string.
		 * 
		 * This function requests a GD Auth token from the GD Runtime. The GD
		 * Runtime might connect to the GD infrastructure installed at the enterprise in
		 * order to service the request.
		 * 
		 * The request is asynchronous. If the request succeeds, the GD Auth token will
		 * be passed to the  \link GDAuthTokenDelegate.OnGDAuthTokenSuccess: OnGDAuthTokenSuccess\endlink callback in
		 * the delegate. If the attempt fails, an error will
		 * be passed to the  \link GDAuthTokenDelegate.OnGDAuthTokenFailure: OnGDAuthTokenFailure\endlink callback in
		 * the delegate instead.
		 *
		 * The <TT>delegate</TT> property must be set before this function is called.
		 *
		 * \param challenge <TT>string</TT> containing the challenge string for the token.
		 *                  The challenge string can be empty.
		 *
		 * \param serverName <TT>string</TT> containing additional identification, by
		 *                   convention the fully qualified domain name of the
		 *                   application server for which a token is being requested.
		 *                   Whatever value is passed here will also be returned to the
		 *                   server as part of the token validation response.
		 *
		 */

		[Export ("gdAuthDelegate", ArgumentSemantic.Assign)]
		GDAuthTokenDelegate GdAuthDelegate { [Bind ("getGDAuthDelegate")] get; [Bind ("setGDAuthDelegate:")] set; }

		/**< Delegated event-handling.
		 * GD Auth token requests are asynchronous. When a request succeeds or fails, a
		 * callback in the application code is invoked by the Good Dynamics Runtime.
		 * 
		 * Set this property to an instance of a class in the application that contains
		 * the code for the required callbacks, i.e. a class that implements
		 * the GDAuthTokenDelegate protocol.
		 */
		
		[Field ("GDAuthTokenDomain", "__Internal")]
		NSString GDAuthTokenDomain { get; }
		/**< The error domain for Good Dynamics Authentication Token errors.
		 */
	}

	[Category, BaseType (typeof(NSMutableUrlRequest))]
	public partial interface GDNET_NSMutableURLRequest
	{

		[Export ("failOnAuthorizationChallenge")]
		bool FailOnAuthorizationChallenge ();

		[Export ("setAuthorizationCredentials:withProtectionSpace:")]
		bool SetAuthorizationCredentials (NSUrlCredential credentials, NSUrlProtectionSpace space);

		[Export ("disableHostVerification")]
		bool DisableHostVerification ();

		[Export ("disablePeerVerification")]
		bool DisablePeerVerification ();
	}
}
